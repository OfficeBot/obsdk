{"version":3,"sources":["dist/node_modules/browser-pack/_prelude.js","dist/index.js","dist/node_modules/base64-js/index.js","dist/node_modules/buffer/index.js","dist/node_modules/clone/clone.js","dist/node_modules/deep-equal/index.js","dist/node_modules/deep-equal/lib/is_arguments.js","dist/node_modules/deep-equal/lib/keys.js","dist/node_modules/fast-json-patch/lib/core.js","dist/node_modules/fast-json-patch/lib/duplex.js","dist/node_modules/fast-json-patch/lib/helpers.js","dist/node_modules/ieee754/index.js","dist/node_modules/querystring-es3/decode.js","dist/node_modules/querystring-es3/encode.js","dist/node_modules/querystring-es3/index.js","dist/src/api-config.class.js","dist/src/cache.class.js","dist/src/endpoint-config.class.js","dist/src/endpoint.class.js","dist/src/http-mock.class.js","dist/src/model.class.js","dist/src/request.class.js","dist/src/settings.js","dist/src/transport.class.js","dist/src/url-builder.class.js","dist/src/utils.class.js"],"names":[],"mappings":"AAAA;;;ACAA;;;;AAIA,IAAI,MAAO,UAAS,OAAT,EAAkB;;AAE3B,MAAI,WAAW,QAAQ,mBAAR,CAAf;AACA,WAAS,aAAT,CAAuB,OAAvB;;AAEA,MAAI,UAAU;AACZ,SAAkB,QAAQ,wBAAR,CADN;AAEZ,WAAkB,QAAQ,mBAAR,CAFN;AAGZ,oBAAkB,QAAQ,6BAAR,CAHN;AAIZ,cAAkB,QAAQ,sBAAR,CAJN;AAKZ,cAAkB,QAAQ,uBAAR,CALN;AAMZ,WAAkB,QAAQ,mBAAR,CANN;AAOZ,aAAkB,QAAQ,qBAAR,CAPN;AAQZ,cAAkB,QARN;AASZ,cAAkB,QAAQ,uBAAR,CATN;AAUZ,gBAAkB,QAAQ,yBAAR,CAVN;AAWZ,WAAkB,QAAQ,mBAAR;AAXN,GAAd;;AAcA,SAAO,OAAP;AAED,CArBS,CAqBP,OArBO,CAAV;;AAuBA,OAAO,OAAP,GAAiB,GAAjB;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC3PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrFA;AACA;AACA;AACA;AACA;;;;;;;;ACJA,IAAM,iBAAiB,QAAQ,4BAAR,CAAvB;AACA,IAAM,WAAW,QAAQ,qBAAR,CAAjB;AACA,IAAM,QAAQ,QAAQ,eAAR,CAAd;AACA,IAAM,QAAQ,QAAQ,eAAR,EAAyB,KAAvC;;AAEA;;;;;IAIM,S;AACJ,uBAAc;AAAA;;AACZ,SAAK,MAAL,GAAc,EAA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","file":"officebot-sdk.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/**\n * This creates a simple package that can be exported\n * @namespace OfficeBotSDK.Index\n */\nlet SDK = (function(Promise) {\n\n  let Settings = require('./src/settings.js');\n  Settings.setPromiseLib(Promise);\n\n  let exports = {\n    API             : require('./src/api-config.class'),\n    Cache           : require('./src/cache.class'),\n    EndpointConfig  : require('./src/endpoint-config.class'),\n    Endpoint        : require('./src/endpoint.class'),\n    HTTPMock        : require('./src/http-mock.class'),\n    Model           : require('./src/model.class'),\n    Request         : require('./src/request.class'),\n    Settings        : Settings,\n    Tranport        : require('./src/transport.class'),\n    URLBuilder      : require('./src/url-builder.class'),\n    Utils           : require('./src/utils.class')\n  };\n\n  return exports;\n\n})(Promise);\n\nmodule.exports = SDK;","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return (b64.length * 3 / 4) - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr((len * 3 / 4) - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0; i < l; i += 4) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('Invalid typed array length')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\n// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\nif (typeof Symbol !== 'undefined' && Symbol.species &&\n    Buffer[Symbol.species] === Buffer) {\n  Object.defineProperty(Buffer, Symbol.species, {\n    value: null,\n    configurable: true,\n    enumerable: false,\n    writable: false\n  })\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (isArrayBuffer(value)) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  return fromObject(value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nBuffer.prototype.__proto__ = Uint8Array.prototype\nBuffer.__proto__ = Uint8Array\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj) {\n    if (isArrayBufferView(obj) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n        return createBuffer(0)\n      }\n      return fromArrayLike(obj)\n    }\n\n    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n      return fromArrayLike(obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (isArrayBufferView(string) || isArrayBuffer(string)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  newBuf.__proto__ = Buffer.prototype\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : new Buffer(val, encoding)\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check\n// but they should be treated as valid. See: https://github.com/feross/buffer/issues/166\nfunction isArrayBuffer (obj) {\n  return obj instanceof ArrayBuffer ||\n    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&\n      typeof obj.byteLength === 'number')\n}\n\n// Node 0.10 supports `ArrayBuffer` but lacks `ArrayBuffer.isView`\nfunction isArrayBufferView (obj) {\n  return (typeof ArrayBuffer.isView === 'function') && ArrayBuffer.isView(obj)\n}\n\nfunction numberIsNaN (obj) {\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n","var clone = (function() {\n'use strict';\n\nfunction _instanceof(obj, type) {\n  return type != null && obj instanceof type;\n}\n\nvar nativeMap;\ntry {\n  nativeMap = Map;\n} catch(_) {\n  // maybe a reference error because no `Map`. Give it a dummy value that no\n  // value will ever be an instanceof.\n  nativeMap = function() {};\n}\n\nvar nativeSet;\ntry {\n  nativeSet = Set;\n} catch(_) {\n  nativeSet = function() {};\n}\n\nvar nativePromise;\ntry {\n  nativePromise = Promise;\n} catch(_) {\n  nativePromise = function() {};\n}\n\n/**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n * @param `includeNonEnumerable` - set to true if the non-enumerable properties\n *    should be cloned as well. Non-enumerable properties on the prototype\n *    chain will be ignored. (optional - false by default)\n*/\nfunction clone(parent, circular, depth, prototype, includeNonEnumerable) {\n  if (typeof circular === 'object') {\n    depth = circular.depth;\n    prototype = circular.prototype;\n    includeNonEnumerable = circular.includeNonEnumerable;\n    circular = circular.circular;\n  }\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n\n  var useBuffer = typeof Buffer != 'undefined';\n\n  if (typeof circular == 'undefined')\n    circular = true;\n\n  if (typeof depth == 'undefined')\n    depth = Infinity;\n\n  // recurse this function so we don't reset allParents and allChildren\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null)\n      return null;\n\n    if (depth === 0)\n      return parent;\n\n    var child;\n    var proto;\n    if (typeof parent != 'object') {\n      return parent;\n    }\n\n    if (_instanceof(parent, nativeMap)) {\n      child = new nativeMap();\n    } else if (_instanceof(parent, nativeSet)) {\n      child = new nativeSet();\n    } else if (_instanceof(parent, nativePromise)) {\n      child = new nativePromise(function (resolve, reject) {\n        parent.then(function(value) {\n          resolve(_clone(value, depth - 1));\n        }, function(err) {\n          reject(_clone(err, depth - 1));\n        });\n      });\n    } else if (clone.__isArray(parent)) {\n      child = [];\n    } else if (clone.__isRegExp(parent)) {\n      child = new RegExp(parent.source, __getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (clone.__isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      child = new Buffer(parent.length);\n      parent.copy(child);\n      return child;\n    } else if (_instanceof(parent, Error)) {\n      child = Object.create(parent);\n    } else {\n      if (typeof prototype == 'undefined') {\n        proto = Object.getPrototypeOf(parent);\n        child = Object.create(proto);\n      }\n      else {\n        child = Object.create(prototype);\n        proto = prototype;\n      }\n    }\n\n    if (circular) {\n      var index = allParents.indexOf(parent);\n\n      if (index != -1) {\n        return allChildren[index];\n      }\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n\n    if (_instanceof(parent, nativeMap)) {\n      parent.forEach(function(value, key) {\n        var keyChild = _clone(key, depth - 1);\n        var valueChild = _clone(value, depth - 1);\n        child.set(keyChild, valueChild);\n      });\n    }\n    if (_instanceof(parent, nativeSet)) {\n      parent.forEach(function(value) {\n        var entryChild = _clone(value, depth - 1);\n        child.add(entryChild);\n      });\n    }\n\n    for (var i in parent) {\n      var attrs;\n      if (proto) {\n        attrs = Object.getOwnPropertyDescriptor(proto, i);\n      }\n\n      if (attrs && attrs.set == null) {\n        continue;\n      }\n      child[i] = _clone(parent[i], depth - 1);\n    }\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(parent);\n      for (var i = 0; i < symbols.length; i++) {\n        // Don't need to worry about cloning a symbol because it is a primitive,\n        // like a number or string.\n        var symbol = symbols[i];\n        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);\n        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {\n          continue;\n        }\n        child[symbol] = _clone(parent[symbol], depth - 1);\n        if (!descriptor.enumerable) {\n          Object.defineProperty(child, symbol, {\n            enumerable: false\n          });\n        }\n      }\n    }\n\n    if (includeNonEnumerable) {\n      var allPropertyNames = Object.getOwnPropertyNames(parent);\n      for (var i = 0; i < allPropertyNames.length; i++) {\n        var propertyName = allPropertyNames[i];\n        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);\n        if (descriptor && descriptor.enumerable) {\n          continue;\n        }\n        child[propertyName] = _clone(parent[propertyName], depth - 1);\n        Object.defineProperty(child, propertyName, {\n          enumerable: false\n        });\n      }\n    }\n\n    return child;\n  }\n\n  return _clone(parent, depth);\n}\n\n/**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */\nclone.clonePrototype = function clonePrototype(parent) {\n  if (parent === null)\n    return null;\n\n  var c = function () {};\n  c.prototype = parent;\n  return new c();\n};\n\n// private utility functions\n\nfunction __objToStr(o) {\n  return Object.prototype.toString.call(o);\n}\nclone.__objToStr = __objToStr;\n\nfunction __isDate(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Date]';\n}\nclone.__isDate = __isDate;\n\nfunction __isArray(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Array]';\n}\nclone.__isArray = __isArray;\n\nfunction __isRegExp(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';\n}\nclone.__isRegExp = __isRegExp;\n\nfunction __getRegExpFlags(re) {\n  var flags = '';\n  if (re.global) flags += 'g';\n  if (re.ignoreCase) flags += 'i';\n  if (re.multiline) flags += 'm';\n  return flags;\n}\nclone.__getRegExpFlags = __getRegExpFlags;\n\nreturn clone;\n})();\n\nif (typeof module === 'object' && module.exports) {\n  module.exports = clone;\n}\n","var pSlice = Array.prototype.slice;\nvar objectKeys = require('./lib/keys.js');\nvar isArguments = require('./lib/is_arguments.js');\n\nvar deepEqual = module.exports = function (actual, expected, opts) {\n  if (!opts) opts = {};\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {\n    return opts.strict ? actual === expected : actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected, opts);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isBuffer (x) {\n  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;\n  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {\n    return false;\n  }\n  if (x.length > 0 && typeof x[0] !== 'number') return false;\n  return true;\n}\n\nfunction objEquiv(a, b, opts) {\n  var i, key;\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return deepEqual(a, b, opts);\n  }\n  if (isBuffer(a)) {\n    if (!isBuffer(b)) {\n      return false;\n    }\n    if (a.length !== b.length) return false;\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n  try {\n    var ka = objectKeys(a),\n        kb = objectKeys(b);\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key], opts)) return false;\n  }\n  return typeof a === typeof b;\n}\n","var supportsArgumentsClass = (function(){\n  return Object.prototype.toString.call(arguments)\n})() == '[object Arguments]';\n\nexports = module.exports = supportsArgumentsClass ? supported : unsupported;\n\nexports.supported = supported;\nfunction supported(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n};\n\nexports.unsupported = unsupported;\nfunction unsupported(object){\n  return object &&\n    typeof object == 'object' &&\n    typeof object.length == 'number' &&\n    Object.prototype.hasOwnProperty.call(object, 'callee') &&\n    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||\n    false;\n};\n","exports = module.exports = typeof Object.keys === 'function'\n  ? Object.keys : shim;\n\nexports.shim = shim;\nfunction shim (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n","var equalsOptions = { strict: true };\r\nvar _equals = require('deep-equal');\r\nvar areEquals = function (a, b) {\r\n    return _equals(a, b, equalsOptions);\r\n};\r\nvar helpers_1 = require('./helpers');\r\nexports.JsonPatchError = helpers_1.PatchError;\r\nexports.deepClone = helpers_1._deepClone;\r\n/* We use a Javascript hash to store each\r\n function. Each hash entry (property) uses\r\n the operation identifiers specified in rfc6902.\r\n In this way, we can map each patch operation\r\n to its dedicated function in efficient way.\r\n */\r\n/* The operations applicable to an object */\r\nvar objOps = {\r\n    add: function (obj, key, document) {\r\n        obj[key] = this.value;\r\n        return { newDocument: document };\r\n    },\r\n    remove: function (obj, key, document) {\r\n        var removed = obj[key];\r\n        delete obj[key];\r\n        return { newDocument: document, removed: removed };\r\n    },\r\n    replace: function (obj, key, document) {\r\n        var removed = obj[key];\r\n        obj[key] = this.value;\r\n        return { newDocument: document, removed: removed };\r\n    },\r\n    move: function (obj, key, document) {\r\n        /* in case move target overwrites an existing value,\r\n        return the removed value, this can be taxing performance-wise,\r\n        and is potentially unneeded */\r\n        var removed = getValueByPointer(document, this.path);\r\n        if (removed) {\r\n            removed = helpers_1._deepClone(removed);\r\n        }\r\n        var originalValue = applyOperation(document, { op: \"remove\", path: this.from }).removed;\r\n        applyOperation(document, { op: \"add\", path: this.path, value: originalValue });\r\n        return { newDocument: document, removed: removed };\r\n    },\r\n    copy: function (obj, key, document) {\r\n        var valueToCopy = getValueByPointer(document, this.from);\r\n        // enforce copy by value so further operations don't affect source (see issue #177)\r\n        applyOperation(document, { op: \"add\", path: this.path, value: helpers_1._deepClone(valueToCopy) });\r\n        return { newDocument: document };\r\n    },\r\n    test: function (obj, key, document) {\r\n        return { newDocument: document, test: areEquals(obj[key], this.value) };\r\n    },\r\n    _get: function (obj, key, document) {\r\n        this.value = obj[key];\r\n        return { newDocument: document };\r\n    }\r\n};\r\n/* The operations applicable to an array. Many are the same as for the object */\r\nvar arrOps = {\r\n    add: function (arr, i, document) {\r\n        if (helpers_1.isInteger(i)) {\r\n            arr.splice(i, 0, this.value);\r\n        }\r\n        else {\r\n            arr[i] = this.value;\r\n        }\r\n        // this may be needed when using '-' in an array\r\n        return { newDocument: document, index: i };\r\n    },\r\n    remove: function (arr, i, document) {\r\n        var removedList = arr.splice(i, 1);\r\n        return { newDocument: document, removed: removedList[0] };\r\n    },\r\n    replace: function (arr, i, document) {\r\n        var removed = arr[i];\r\n        arr[i] = this.value;\r\n        return { newDocument: document, removed: removed };\r\n    },\r\n    move: objOps.move,\r\n    copy: objOps.copy,\r\n    test: objOps.test,\r\n    _get: objOps._get\r\n};\r\n/**\r\n * Retrieves a value from a JSON document by a JSON pointer.\r\n * Returns the value.\r\n *\r\n * @param document The document to get the value from\r\n * @param pointer an escaped JSON pointer\r\n * @return The retrieved value\r\n */\r\nfunction getValueByPointer(document, pointer) {\r\n    if (pointer == '') {\r\n        return document;\r\n    }\r\n    var getOriginalDestination = { op: \"_get\", path: pointer };\r\n    applyOperation(document, getOriginalDestination);\r\n    return getOriginalDestination.value;\r\n}\r\nexports.getValueByPointer = getValueByPointer;\r\n/**\r\n * Apply a single JSON Patch Operation on a JSON document.\r\n * Returns the {newDocument, result} of the operation.\r\n * It modifies the `document` and `operation` objects - it gets the values by reference.\r\n * If you would like to avoid touching your values, clone them:\r\n * `jsonpatch.applyOperation(document, jsonpatch._deepClone(operation))`.\r\n *\r\n * @param document The document to patch\r\n * @param operation The operation to apply\r\n * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.\r\n * @param mutateDocument Whether to mutate the original document or clone it before applying\r\n * @return `{newDocument, result}` after the operation\r\n */\r\nfunction applyOperation(document, operation, validateOperation, mutateDocument) {\r\n    if (validateOperation === void 0) { validateOperation = false; }\r\n    if (mutateDocument === void 0) { mutateDocument = true; }\r\n    if (validateOperation) {\r\n        if (typeof validateOperation == 'function') {\r\n            validateOperation(operation, 0, document, operation.path);\r\n        }\r\n        else {\r\n            validator(operation, 0);\r\n        }\r\n    }\r\n    /* ROOT OPERATIONS */\r\n    if (operation.path === \"\") {\r\n        var returnValue = { newDocument: document };\r\n        if (operation.op === 'add') {\r\n            returnValue.newDocument = operation.value;\r\n            return returnValue;\r\n        }\r\n        else if (operation.op === 'replace') {\r\n            returnValue.newDocument = operation.value;\r\n            returnValue.removed = document; //document we removed\r\n            return returnValue;\r\n        }\r\n        else if (operation.op === 'move' || operation.op === 'copy') {\r\n            returnValue.newDocument = getValueByPointer(document, operation.from); // get the value by json-pointer in `from` field\r\n            if (operation.op === 'move') {\r\n                returnValue.removed = document;\r\n            }\r\n            return returnValue;\r\n        }\r\n        else if (operation.op === 'test') {\r\n            returnValue.test = areEquals(document, operation.value);\r\n            if (returnValue.test === false) {\r\n                throw new exports.JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', 0, operation, document);\r\n            }\r\n            returnValue.newDocument = document;\r\n            return returnValue;\r\n        }\r\n        else if (operation.op === 'remove') {\r\n            returnValue.removed = document;\r\n            returnValue.newDocument = null;\r\n            return returnValue;\r\n        }\r\n        else if (operation.op === '_get') {\r\n            operation.value = document;\r\n            return returnValue;\r\n        }\r\n        else {\r\n            if (validateOperation) {\r\n                throw new exports.JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', 0, operation, document);\r\n            }\r\n            else {\r\n                return returnValue;\r\n            }\r\n        }\r\n    } /* END ROOT OPERATIONS */\r\n    else {\r\n        if (!mutateDocument) {\r\n            document = helpers_1._deepClone(document);\r\n        }\r\n        var path = operation.path || \"\";\r\n        var keys = path.split('/');\r\n        var obj = document;\r\n        var t = 1; //skip empty element - http://jsperf.com/to-shift-or-not-to-shift\r\n        var len = keys.length;\r\n        var existingPathFragment = undefined;\r\n        var key = void 0;\r\n        var validateFunction = void 0;\r\n        if (typeof validateOperation == 'function') {\r\n            validateFunction = validateOperation;\r\n        }\r\n        else {\r\n            validateFunction = validator;\r\n        }\r\n        while (true) {\r\n            key = keys[t];\r\n            if (validateOperation) {\r\n                if (existingPathFragment === undefined) {\r\n                    if (obj[key] === undefined) {\r\n                        existingPathFragment = keys.slice(0, t).join('/');\r\n                    }\r\n                    else if (t == len - 1) {\r\n                        existingPathFragment = operation.path;\r\n                    }\r\n                    if (existingPathFragment !== undefined) {\r\n                        validateFunction(operation, 0, document, existingPathFragment);\r\n                    }\r\n                }\r\n            }\r\n            t++;\r\n            if (Array.isArray(obj)) {\r\n                if (key === '-') {\r\n                    key = obj.length;\r\n                }\r\n                else {\r\n                    if (validateOperation && !helpers_1.isInteger(key)) {\r\n                        throw new exports.JsonPatchError(\"Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index\", \"OPERATION_PATH_ILLEGAL_ARRAY_INDEX\", 0, operation.path, operation);\r\n                    } // only parse key when it's an integer for `arr.prop` to work\r\n                    else if (helpers_1.isInteger(key)) {\r\n                        key = ~~key;\r\n                    }\r\n                }\r\n                if (t >= len) {\r\n                    if (validateOperation && operation.op === \"add\" && key > obj.length) {\r\n                        throw new exports.JsonPatchError(\"The specified index MUST NOT be greater than the number of elements in the array\", \"OPERATION_VALUE_OUT_OF_BOUNDS\", 0, operation.path, operation);\r\n                    }\r\n                    var returnValue = arrOps[operation.op].call(operation, obj, key, document); // Apply patch\r\n                    if (returnValue.test === false) {\r\n                        throw new exports.JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', 0, operation, document);\r\n                    }\r\n                    return returnValue;\r\n                }\r\n            }\r\n            else {\r\n                if (key && key.indexOf('~') != -1) {\r\n                    key = helpers_1.unescapePathComponent(key);\r\n                }\r\n                if (t >= len) {\r\n                    var returnValue = objOps[operation.op].call(operation, obj, key, document); // Apply patch\r\n                    if (returnValue.test === false) {\r\n                        throw new exports.JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', 0, operation, document);\r\n                    }\r\n                    return returnValue;\r\n                }\r\n            }\r\n            obj = obj[key];\r\n        }\r\n    }\r\n}\r\nexports.applyOperation = applyOperation;\r\n/**\r\n * Apply a full JSON Patch array on a JSON document.\r\n * Returns the {newDocument, result} of the patch.\r\n * It modifies the `document` object and `patch` - it gets the values by reference.\r\n * If you would like to avoid touching your values, clone them:\r\n * `jsonpatch.applyPatch(document, jsonpatch._deepClone(patch))`.\r\n *\r\n * @param document The document to patch\r\n * @param patch The patch to apply\r\n * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.\r\n * @return An array of `{newDocument, result}` after the patch\r\n */\r\nfunction applyPatch(document, patch, validateOperation) {\r\n    if (validateOperation) {\r\n        if (!Array.isArray(patch)) {\r\n            throw new exports.JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');\r\n        }\r\n    }\r\n    var results = new Array(patch.length);\r\n    for (var i = 0, length_1 = patch.length; i < length_1; i++) {\r\n        results[i] = applyOperation(document, patch[i], validateOperation);\r\n        document = results[i].newDocument; // in case root was replaced\r\n    }\r\n    results.newDocument = document;\r\n    return results;\r\n}\r\nexports.applyPatch = applyPatch;\r\n/**\r\n * Apply a single JSON Patch Operation on a JSON document.\r\n * Returns the updated document.\r\n * Suitable as a reducer.\r\n *\r\n * @param document The document to patch\r\n * @param operation The operation to apply\r\n * @return The updated document\r\n */\r\nfunction applyReducer(document, operation) {\r\n    var operationResult = applyOperation(document, operation);\r\n    if (operationResult.test === false) {\r\n        throw new exports.JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', 0, operation, document);\r\n    }\r\n    return operationResult.newDocument;\r\n}\r\nexports.applyReducer = applyReducer;\r\n/**\r\n * Validates a single operation. Called from `jsonpatch.validate`. Throws `JsonPatchError` in case of an error.\r\n * @param {object} operation - operation object (patch)\r\n * @param {number} index - index of operation in the sequence\r\n * @param {object} [document] - object where the operation is supposed to be applied\r\n * @param {string} [existingPathFragment] - comes along with `document`\r\n */\r\nfunction validator(operation, index, document, existingPathFragment) {\r\n    if (typeof operation !== 'object' || operation === null || Array.isArray(operation)) {\r\n        throw new exports.JsonPatchError('Operation is not an object', 'OPERATION_NOT_AN_OBJECT', index, operation, document);\r\n    }\r\n    else if (!objOps[operation.op]) {\r\n        throw new exports.JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);\r\n    }\r\n    else if (typeof operation.path !== 'string') {\r\n        throw new exports.JsonPatchError('Operation `path` property is not a string', 'OPERATION_PATH_INVALID', index, operation, document);\r\n    }\r\n    else if (operation.path.indexOf('/') !== 0 && operation.path.length > 0) {\r\n        // paths that aren't empty string should start with \"/\"\r\n        throw new exports.JsonPatchError('Operation `path` property must start with \"/\"', 'OPERATION_PATH_INVALID', index, operation, document);\r\n    }\r\n    else if ((operation.op === 'move' || operation.op === 'copy') && typeof operation.from !== 'string') {\r\n        throw new exports.JsonPatchError('Operation `from` property is not present (applicable in `move` and `copy` operations)', 'OPERATION_FROM_REQUIRED', index, operation, document);\r\n    }\r\n    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && operation.value === undefined) {\r\n        throw new exports.JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_REQUIRED', index, operation, document);\r\n    }\r\n    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && helpers_1.hasUndefined(operation.value)) {\r\n        throw new exports.JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED', index, operation, document);\r\n    }\r\n    else if (document) {\r\n        if (operation.op == \"add\") {\r\n            var pathLen = operation.path.split(\"/\").length;\r\n            var existingPathLen = existingPathFragment.split(\"/\").length;\r\n            if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {\r\n                throw new exports.JsonPatchError('Cannot perform an `add` operation at the desired path', 'OPERATION_PATH_CANNOT_ADD', index, operation, document);\r\n            }\r\n        }\r\n        else if (operation.op === 'replace' || operation.op === 'remove' || operation.op === '_get') {\r\n            if (operation.path !== existingPathFragment) {\r\n                throw new exports.JsonPatchError('Cannot perform the operation at a path that does not exist', 'OPERATION_PATH_UNRESOLVABLE', index, operation, document);\r\n            }\r\n        }\r\n        else if (operation.op === 'move' || operation.op === 'copy') {\r\n            var existingValue = { op: \"_get\", path: operation.from, value: undefined };\r\n            var error = validate([existingValue], document);\r\n            if (error && error.name === 'OPERATION_PATH_UNRESOLVABLE') {\r\n                throw new exports.JsonPatchError('Cannot perform the operation from a path that does not exist', 'OPERATION_FROM_UNRESOLVABLE', index, operation, document);\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.validator = validator;\r\n/**\r\n * Validates a sequence of operations. If `document` parameter is provided, the sequence is additionally validated against the object document.\r\n * If error is encountered, returns a JsonPatchError object\r\n * @param sequence\r\n * @param document\r\n * @returns {JsonPatchError|undefined}\r\n */\r\nfunction validate(sequence, document, externalValidator) {\r\n    try {\r\n        if (!Array.isArray(sequence)) {\r\n            throw new exports.JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');\r\n        }\r\n        if (document) {\r\n            //clone document and sequence so that we can safely try applying operations\r\n            applyPatch(helpers_1._deepClone(document), helpers_1._deepClone(sequence), externalValidator || true);\r\n        }\r\n        else {\r\n            externalValidator = externalValidator || validator;\r\n            for (var i = 0; i < sequence.length; i++) {\r\n                externalValidator(sequence[i], i, document, undefined);\r\n            }\r\n        }\r\n    }\r\n    catch (e) {\r\n        if (e instanceof exports.JsonPatchError) {\r\n            return e;\r\n        }\r\n        else {\r\n            throw e;\r\n        }\r\n    }\r\n}\r\nexports.validate = validate;\r\n","var equalsOptions = { strict: true };\r\nvar _equals = require('deep-equal');\r\nvar areEquals = function (a, b) {\r\n    return _equals(a, b, equalsOptions);\r\n};\r\nvar helpers_1 = require('./helpers');\r\nvar core_1 = require('./core');\r\n/* export all core functions */\r\nvar core_2 = require('./core');\r\nexports.applyOperation = core_2.applyOperation;\r\nexports.applyPatch = core_2.applyPatch;\r\nexports.applyReducer = core_2.applyReducer;\r\nexports.getValueByPointer = core_2.getValueByPointer;\r\nexports.validate = core_2.validate;\r\nexports.validator = core_2.validator;\r\n/* export some helpers */\r\nvar helpers_2 = require('./helpers');\r\nexports.JsonPatchError = helpers_2.PatchError;\r\nexports.deepClone = helpers_2._deepClone;\r\nexports.escapePathComponent = helpers_2.escapePathComponent;\r\nexports.unescapePathComponent = helpers_2.unescapePathComponent;\r\nvar beforeDict = [];\r\nvar Mirror = (function () {\r\n    function Mirror(obj) {\r\n        this.observers = [];\r\n        this.obj = obj;\r\n    }\r\n    return Mirror;\r\n}());\r\nvar ObserverInfo = (function () {\r\n    function ObserverInfo(callback, observer) {\r\n        this.callback = callback;\r\n        this.observer = observer;\r\n    }\r\n    return ObserverInfo;\r\n}());\r\nfunction getMirror(obj) {\r\n    for (var i = 0, length = beforeDict.length; i < length; i++) {\r\n        if (beforeDict[i].obj === obj) {\r\n            return beforeDict[i];\r\n        }\r\n    }\r\n}\r\nfunction getObserverFromMirror(mirror, callback) {\r\n    for (var j = 0, length = mirror.observers.length; j < length; j++) {\r\n        if (mirror.observers[j].callback === callback) {\r\n            return mirror.observers[j].observer;\r\n        }\r\n    }\r\n}\r\nfunction removeObserverFromMirror(mirror, observer) {\r\n    for (var j = 0, length = mirror.observers.length; j < length; j++) {\r\n        if (mirror.observers[j].observer === observer) {\r\n            mirror.observers.splice(j, 1);\r\n            return;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Detach an observer from an object\r\n */\r\nfunction unobserve(root, observer) {\r\n    observer.unobserve();\r\n}\r\nexports.unobserve = unobserve;\r\n/**\r\n * Observes changes made to an object, which can then be retrieved using generate\r\n */\r\nfunction observe(obj, callback) {\r\n    var patches = [];\r\n    var root = obj;\r\n    var observer;\r\n    var mirror = getMirror(obj);\r\n    if (!mirror) {\r\n        mirror = new Mirror(obj);\r\n        beforeDict.push(mirror);\r\n    }\r\n    else {\r\n        observer = getObserverFromMirror(mirror, callback);\r\n    }\r\n    if (observer) {\r\n        return observer;\r\n    }\r\n    observer = {};\r\n    mirror.value = helpers_1._deepClone(obj);\r\n    if (callback) {\r\n        observer.callback = callback;\r\n        observer.next = null;\r\n        var dirtyCheck = function () {\r\n            generate(observer);\r\n        };\r\n        var fastCheck = function () {\r\n            clearTimeout(observer.next);\r\n            observer.next = setTimeout(dirtyCheck);\r\n        };\r\n        if (typeof window !== 'undefined') {\r\n            if (window.addEventListener) {\r\n                window.addEventListener('mouseup', fastCheck);\r\n                window.addEventListener('keyup', fastCheck);\r\n                window.addEventListener('mousedown', fastCheck);\r\n                window.addEventListener('keydown', fastCheck);\r\n                window.addEventListener('change', fastCheck);\r\n            }\r\n            else {\r\n                document.documentElement.attachEvent('onmouseup', fastCheck);\r\n                document.documentElement.attachEvent('onkeyup', fastCheck);\r\n                document.documentElement.attachEvent('onmousedown', fastCheck);\r\n                document.documentElement.attachEvent('onkeydown', fastCheck);\r\n                document.documentElement.attachEvent('onchange', fastCheck);\r\n            }\r\n        }\r\n    }\r\n    observer.patches = patches;\r\n    observer.object = obj;\r\n    observer.unobserve = function () {\r\n        generate(observer);\r\n        clearTimeout(observer.next);\r\n        removeObserverFromMirror(mirror, observer);\r\n        if (typeof window !== 'undefined') {\r\n            if (window.removeEventListener) {\r\n                window.removeEventListener('mouseup', fastCheck);\r\n                window.removeEventListener('keyup', fastCheck);\r\n                window.removeEventListener('mousedown', fastCheck);\r\n                window.removeEventListener('keydown', fastCheck);\r\n            }\r\n            else {\r\n                document.documentElement.detachEvent('onmouseup', fastCheck);\r\n                document.documentElement.detachEvent('onkeyup', fastCheck);\r\n                document.documentElement.detachEvent('onmousedown', fastCheck);\r\n                document.documentElement.detachEvent('onkeydown', fastCheck);\r\n            }\r\n        }\r\n    };\r\n    mirror.observers.push(new ObserverInfo(callback, observer));\r\n    return observer;\r\n}\r\nexports.observe = observe;\r\n/**\r\n * Generate an array of patches from an observer\r\n */\r\nfunction generate(observer) {\r\n    var mirror;\r\n    for (var i = 0, length = beforeDict.length; i < length; i++) {\r\n        if (beforeDict[i].obj === observer.object) {\r\n            mirror = beforeDict[i];\r\n            break;\r\n        }\r\n    }\r\n    _generate(mirror.value, observer.object, observer.patches, \"\");\r\n    if (observer.patches.length) {\r\n        core_1.applyPatch(mirror.value, observer.patches);\r\n    }\r\n    var temp = observer.patches;\r\n    if (temp.length > 0) {\r\n        observer.patches = [];\r\n        if (observer.callback) {\r\n            observer.callback(temp);\r\n        }\r\n    }\r\n    return temp;\r\n}\r\nexports.generate = generate;\r\n// Dirty check if obj is different from mirror, generate patches and update mirror\r\nfunction _generate(mirror, obj, patches, path) {\r\n    if (obj === mirror) {\r\n        return;\r\n    }\r\n    if (typeof obj.toJSON === \"function\") {\r\n        obj = obj.toJSON();\r\n    }\r\n    var newKeys = helpers_1._objectKeys(obj);\r\n    var oldKeys = helpers_1._objectKeys(mirror);\r\n    var changed = false;\r\n    var deleted = false;\r\n    //if ever \"move\" operation is implemented here, make sure this test runs OK: \"should not generate the same patch twice (move)\"\r\n    for (var t = oldKeys.length - 1; t >= 0; t--) {\r\n        var key = oldKeys[t];\r\n        var oldVal = mirror[key];\r\n        if (helpers_1.hasOwnProperty(obj, key) && !(obj[key] === undefined && oldVal !== undefined && Array.isArray(obj) === false)) {\r\n            var newVal = obj[key];\r\n            if (typeof oldVal == \"object\" && oldVal != null && typeof newVal == \"object\" && newVal != null) {\r\n                _generate(oldVal, newVal, patches, path + \"/\" + helpers_1.escapePathComponent(key));\r\n            }\r\n            else {\r\n                if (oldVal !== newVal) {\r\n                    changed = true;\r\n                    patches.push({ op: \"replace\", path: path + \"/\" + helpers_1.escapePathComponent(key), value: helpers_1._deepClone(newVal) });\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            patches.push({ op: \"remove\", path: path + \"/\" + helpers_1.escapePathComponent(key) });\r\n            deleted = true; // property has been deleted\r\n        }\r\n    }\r\n    if (!deleted && newKeys.length == oldKeys.length) {\r\n        return;\r\n    }\r\n    for (var t = 0; t < newKeys.length; t++) {\r\n        var key = newKeys[t];\r\n        if (!helpers_1.hasOwnProperty(mirror, key) && obj[key] !== undefined) {\r\n            patches.push({ op: \"add\", path: path + \"/\" + helpers_1.escapePathComponent(key), value: helpers_1._deepClone(obj[key]) });\r\n        }\r\n    }\r\n}\r\n/**\r\n * Create an array of patches from the differences in two objects\r\n */\r\nfunction compare(tree1, tree2) {\r\n    var patches = [];\r\n    _generate(tree1, tree2, patches, '');\r\n    return patches;\r\n}\r\nexports.compare = compare;\r\n","var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\n/*!\r\n * https://github.com/Starcounter-Jack/JSON-Patch\r\n * (c) 2017 Joachim Wester\r\n * MIT license\r\n */\r\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\r\nfunction hasOwnProperty(obj, key) {\r\n    return _hasOwnProperty.call(obj, key);\r\n}\r\nexports.hasOwnProperty = hasOwnProperty;\r\nfunction _objectKeys(obj) {\r\n    if (Array.isArray(obj)) {\r\n        var keys = new Array(obj.length);\r\n        for (var k = 0; k < keys.length; k++) {\r\n            keys[k] = \"\" + k;\r\n        }\r\n        return keys;\r\n    }\r\n    if (Object.keys) {\r\n        return Object.keys(obj);\r\n    }\r\n    var keys = [];\r\n    for (var i in obj) {\r\n        if (hasOwnProperty(obj, i)) {\r\n            keys.push(i);\r\n        }\r\n    }\r\n    return keys;\r\n}\r\nexports._objectKeys = _objectKeys;\r\n;\r\n/**\r\n* Deeply clone the object.\r\n* https://jsperf.com/deep-copy-vs-json-stringify-json-parse/25 (recursiveDeepCopy)\r\n* @param  {any} obj value to clone\r\n* @return {any} cloned obj\r\n*/\r\nfunction _deepClone(obj) {\r\n    switch (typeof obj) {\r\n        case \"object\":\r\n            return JSON.parse(JSON.stringify(obj)); //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5\r\n        case \"undefined\":\r\n            return null; //this is how JSON.stringify behaves for array items\r\n        default:\r\n            return obj; //no need to clone primitives\r\n    }\r\n}\r\nexports._deepClone = _deepClone;\r\n//3x faster than cached /^\\d+$/.test(str)\r\nfunction isInteger(str) {\r\n    var i = 0;\r\n    var len = str.length;\r\n    var charCode;\r\n    while (i < len) {\r\n        charCode = str.charCodeAt(i);\r\n        if (charCode >= 48 && charCode <= 57) {\r\n            i++;\r\n            continue;\r\n        }\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\nexports.isInteger = isInteger;\r\n/**\r\n* Escapes a json pointer path\r\n* @param path The raw pointer\r\n* @return the Escaped path\r\n*/\r\nfunction escapePathComponent(path) {\r\n    if (path.indexOf('/') === -1 && path.indexOf('~') === -1)\r\n        return path;\r\n    return path.replace(/~/g, '~0').replace(/\\//g, '~1');\r\n}\r\nexports.escapePathComponent = escapePathComponent;\r\n/**\r\n * Unescapes a json pointer path\r\n * @param path The escaped pointer\r\n * @return The unescaped path\r\n */\r\nfunction unescapePathComponent(path) {\r\n    return path.replace(/~1/g, '/').replace(/~0/g, '~');\r\n}\r\nexports.unescapePathComponent = unescapePathComponent;\r\nfunction _getPathRecursive(root, obj) {\r\n    var found;\r\n    for (var key in root) {\r\n        if (hasOwnProperty(root, key)) {\r\n            if (root[key] === obj) {\r\n                return escapePathComponent(key) + '/';\r\n            }\r\n            else if (typeof root[key] === 'object') {\r\n                found = _getPathRecursive(root[key], obj);\r\n                if (found != '') {\r\n                    return escapePathComponent(key) + '/' + found;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return '';\r\n}\r\nexports._getPathRecursive = _getPathRecursive;\r\nfunction getPath(root, obj) {\r\n    if (root === obj) {\r\n        return '/';\r\n    }\r\n    var path = _getPathRecursive(root, obj);\r\n    if (path === '') {\r\n        throw new Error(\"Object not found in root\");\r\n    }\r\n    return '/' + path;\r\n}\r\nexports.getPath = getPath;\r\n/**\r\n* Recursively checks whether an object has any undefined values inside.\r\n*/\r\nfunction hasUndefined(obj) {\r\n    if (obj === undefined) {\r\n        return true;\r\n    }\r\n    if (obj) {\r\n        if (Array.isArray(obj)) {\r\n            for (var i = 0, len = obj.length; i < len; i++) {\r\n                if (hasUndefined(obj[i])) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        else if (typeof obj === \"object\") {\r\n            var objKeys = _objectKeys(obj);\r\n            var objKeysLength = objKeys.length;\r\n            for (var i = 0; i < objKeysLength; i++) {\r\n                if (hasUndefined(obj[objKeys[i]])) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nexports.hasUndefined = hasUndefined;\r\nvar PatchError = (function (_super) {\r\n    __extends(PatchError, _super);\r\n    function PatchError(message, name, index, operation, tree) {\r\n        _super.call(this, message);\r\n        this.message = message;\r\n        this.name = name;\r\n        this.index = index;\r\n        this.operation = operation;\r\n        this.tree = tree;\r\n    }\r\n    return PatchError;\r\n}(Error));\r\nexports.PatchError = PatchError;\r\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n","'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n","const EndpointConfig = require('./endpoint-config.class.js');\nconst Endpoint = require('./endpoint.class.js');\nconst Cache = require('./cache.class');\nconst clone = require('./utils.class').clone;\n\n/**\n * Defines the base configuration for an API\n * @constructor\n */\nclass APIConfig {\n  constructor() {\n    this.config = { headers : {}, url : '' };\n    this.endpoints = {};\n    this.cache = new Cache();\n  }\n  /**\n   * Gets / Sets base api url\n   * @param {string=} url - Base url that this endpoint talks to\n   * @returns {(this|string)}\n   */\n  baseUrl(url) {\n    if ('undefined' !== typeof url) {\n      if ('string' === typeof url) {\n        this.config.url = url;\n      }\n      return this;\n    }\n    return this.config.url;\n  }\n  /**\n   * Creates a new endpoint\n   * @param {string} endpointName - The name that will be used to get this endpoint\n   * @returns {@link Endpoint} An instance of Endpoint\n   */\n  endpoint(endpointName = '__default__') {\n    let config = new EndpointConfig().api(this);\n    this[ endpointName ] = new Endpoint(config);\n    return this[ endpointName ];\n  }\n  /**\n   * Sets headers that all calls will use. Helpful for authentication\n   * @param {object=} headers - Key / value pairs of headers\n   * @returns {this | object}\n   */\n  commonHeaders(headers) {\n    if ('undefined' !== typeof headers) {\n      this.config.headers = headers;\n      return this;\n    } else {\n      return clone(this.config.headers);\n    }\n  }\n}\n\nmodule.exports = APIConfig;","/**\n * @constructor\n */\nclass Cache {\n  /**\n   * Create a cache object\n   */\n  constructor() {\n    this.objects = new Map();\n    this.config = {\n      ttl : 60000,\n    };\n  }\n  /**\n   * Fetches an object from the cache using the object's name (typically the url)\n   * @param {string} name \n   * @returns {(object|Array|undefined)} The found object or array if exists, otherwise undefined\n   */\n  get(name) {\n    let now = Date.now();\n    let obj = this.objects.get(name);\n    if ('undefined' !== typeof obj && now - obj[0] < this.config.ttl) {\n      let cachedObject = obj[1];\n      Object.defineProperty(cachedObject,'__fromCache', {value : true});\n      return cachedObject;\n    } else {\n      this.objects.delete(name); //in case the object exists but has expired\n      return undefined;\n    }\n  }\n  /**\n   * Stores any object or primitive into the cache using it's name\n   * NOTE: Primitives WILL be converted to objects prior to caching\n   * @param {string} name \n   * @param {(string|number|boolean|object)} value \n   * @returns {boolean} success\n   */\n  put(name, value) {\n    if ('string' !== typeof name) {\n      throw new Error('Invalid name attribute');\n    }\n    //convert primitive strings to string objects so we can add __fromCached\n    if ('string' === typeof value) {\n      value = new String(value); // jshint ignore:line\n    }\n    if ('number' === typeof value) {\n      value = new Number(value); // jshint ignore:line\n    }\n    if ('boolean' === typeof value) {\n      value = new Boolean(value); // jshint ignore:line      \n    }\n    this.objects.set(name, [Date.now(), value]);\n    return true;\n  }\n  /**\n   * Removes an object from the cache\n   * @param {string} name \n   */\n  invalidate(name) {\n    return this.objects.delete(name);\n  }\n  /**\n   * Changes the default time to live of objects in the cache\n   * @param {number} newTTL \n   * @returns {boolean} success\n   */\n  setTTL(newTTL) {\n    if ('number' !== typeof newTTL) {\n      throw new Error('Invalid TTL value');\n    }\n    this.config.ttl = newTTL;\n    return true;\n  }\n \n}\n\nmodule.exports = Cache;","const Model = require('./model.class');\nconst clone = require('./utils.class').clone;\n/**\n * @constructor\n */\nclass EndpointConfig {\n  constructor(config = {}) {\n    this.config = { api : {}};\n\n    let defaults = {\n      'url' : '/',\n      'responseType' : \"application/json\",\n      'instantiator' : Model\n    };\n    Object.assign(this.config, defaults, clone(config));\n  }\n\n  /**\n   * Gets or sets the expected media return type. Ultimately, it is up to the transport\n   * to use this setting to correctly talk to the api\n   * Note - This is currently unused\n   * @param {string=} newType - The new media type that this endpoint communicates with\n   */\n  mediaType(newType) {\n    if ('undefined' !== typeof newType) {\n      if ('string' === typeof newType) {\n        this.config.responseType = newType;\n      }\n      return this;\n    }\n    return this.config.responseType;\n  }\n\n  /**\n   * Gets / sets the API configuration object. This is needed so each\n   * endpoint can share common settings\n   * @param {APIConfig} config - The parent api configuration \n   * @returns {(this | object)}\n   */\n  api(config) {\n    if ('undefined' !== typeof config) {\n      if ('object' === typeof config && config !== null) {\n        this.config.api = clone(config);\n      }\n      return this;\n    }\n    return this.config.api;\n  }\n\n  /**\n   * Gets the base url from the underlying api configuration \n   * @returns {string} Current root url\n   */\n  baseUrl() {\n    if (!this.config.api || !this.config.api.baseUrl) {\n      return '';\n    }\n    return this.config.api.baseUrl();\n  }\n  /**\n   * Gets / sets the endpoint's relative url\n   * @param {string=} newUrl - Url to use for this endpoint\n   * @returns {(this | string)} This instance or the current url\n   */\n  url(newUrl) {\n    if ('undefined' !== typeof newUrl) {\n      if ('string' === typeof newUrl) {\n        this.config.url = newUrl;\n      }\n      return this;\n    }\n    return this.config.url;\n  }\n  /**\n   * Gets / sets the instantiator function to use when creating a new model. \n   * @param {(function|class)=} instantiator - the function or class to use for instantiation\n   * @returns {(this|function)} This instance or the current insantiation function \n   */\n  model(newFn) {\n    if ('undefined' !== typeof newFn) {\n      if ('function' === typeof newFn) {\n        this.config.instantiator = newFn;\n      }\n      return this;\n    }\n    return this.config.instantiator;\n  }\n\n}\n\nmodule.exports = EndpointConfig;","const URLBuilder = require('./url-builder.class');\nconst Request = require('./request.class');\nconst clone = require('./utils.class').clone;\nconst noop = require('./utils.class').noop;\n\n/**\n * Creates an endpoint instance\n * @constructor\n */\nclass Endpoint {\n  constructor(endpointConfig = {}) {\n    if (!endpointConfig || 'function' !== typeof endpointConfig.model) {\n      throw new Error('Invalid endpoint configuration.');\n    }\n    this.endpointConfig = clone(endpointConfig);\n    this.config = {\n      allowFromCache : true,\n      method : 'get',\n      target : '',\n      query : {}\n    };\n    this.cache = this.endpointConfig.api().cache;\n  }\n  /**\n   * Instantiates a new model instance and returns it\n   * @param {object=} data - Initialization data for the new model instance\n   * @returns {@link Model} New instance of Model\n   */\n  createNew(data = {}) {\n    let root = new URLBuilder([\n      this.endpointConfig.baseUrl(),\n      this.endpointConfig.url()\n    ]);\n    data['@root'] = root;\n    let instantiator = this.endpointConfig.model();\n    let instance = new instantiator(data);\n    instance.config(this.endpointConfig);\n    return instance;\n  }\n  /**\n   * Gets / sets instantiator to use when creating a new model instance. Instantiator *should* inherit\n   * from {@link Model}\n   * @param {(function|class)=} instantiator - Function or class to use when instantiating model\n   * @returns {(this|function)} Current instantiator function or this instance\n   */\n  model(instantiator) {\n    if ('undefined' !== typeof instantiator) {\n      this.endpointConfig.model(instantiator);\n      return this;\n    }\n    return this.endpointConfig.model();\n  }\n  /**\n   * Gets / sets the endpoint's relative url\n   * @param {string=} url - The new url value\n   * @returns {(this|string)} This instance or the current url\n   */\n  url(newUrl) {\n    if ('undefined' !== typeof newUrl) {\n      this.endpointConfig.url(newUrl);\n      return this;\n    }\n    return this.endpointConfig.url();\n  }\n  /**\n   * Builds a query to find an object with the specified identifier\n   * @param {string} id - the unique model identifier\n   * @returns {this}\n   */\n  findById(id) {\n    if ('string' !== typeof id) {\n      throw new Error('Invalid model identifier');\n    }\n    this.config.target = new URLBuilder([\n      this.endpointConfig.baseUrl(),\n      this.endpointConfig.url(),\n      id\n    ]);\n    this.config.method = 'get';\n    return this;\n  }\n  /**\n   * Creates a query to find objects that match the optional query\n   * @param {object=} query\n   * @returns {this}\n   */\n  find(query) {\n    this.config.target = new URLBuilder([\n      this.endpointConfig.baseUrl(),\n      this.endpointConfig.url()\n    ]);\n    this.config.method = 'get';\n    this.config.query.search = JSON.stringify(query);\n    return this;\n  }\n\n  /**\n    * At the moment, this behaves exactly the same as .find, but uses the\n    * SEARCH verb instead\n    * @param {object} query\n    * @returns {this}\n    */\n  search(query) {\n    this.config.target = new URLBuilder([\n      this.endpointConfig.baseUrl(),\n      this.endpointConfig.url()\n    ]);\n    this.config.method = 'search';\n    this.config.query.search = JSON.stringify(query);\n    return this;\n  }\n\n  /**\n   * Creates a query to find a unique model with the specified id\n   * and replaces it's data with the specified body object\n   * @param {string} id - the unique model identifier\n   * @param {object} body\n   * @returns {this}\n   */\n  findByIdAndUpdate(id, body) {\n    if ('string' !== typeof id) {\n      throw new Error('Invalid model identifier');\n    }\n    if ('object' !== typeof body) {\n      throw new Error('Invalid body object');\n    }\n    this.config.target = new URLBuilder([\n      this.endpointConfig.baseUrl(),\n      this.endpointConfig.url(),\n      id\n    ]);\n    this.config.body = body;\n    this.config.method = 'put';\n    return this;\n  }\n\n  /**\n   * Creates a query that finds a model with the specified id and\n   * removes it from the database\n   * @param {string} id - the unique model identifier\n   * @returns {this}\n   */\n  findByIdAndRemove(id) {\n    if ('string' !== typeof id) {\n      throw new Error('Invalid model identifier');\n    }\n    this.config.target = new URLBuilder([\n      this.endpointConfig.baseUrl(),\n      this.endpointConfig.url(),\n      id\n    ]);\n    this.config.method = 'delete';\n    return this;\n  }\n\n  /**\n   * Determines if the query request should allow objects from the cache\n   * or require objects be fresh from the api\n   * @param {boolean=} allow - Specify if using the cache is allowed\n   * @returns {(this | boolean)} This instance or the current allow value\n   */\n  allowFromCache(allow) {\n    if ('undefined' !== typeof allow) {\n      if ('boolean' === typeof allow) {\n        this.config.allowFromCache = allow;\n      }\n      return this;\n    }\n    return this.config.allowFromCache;\n  }\n\n  /**\n   * Runs the query that has been created using the find/findBy.. calls\n   * @param {function=} cb - Function to call on completion (success or failure)\n   * @returns {Promise}\n   */\n  exec(cb = noop) {\n    let allowFromCache = this.allowFromCache();\n    let modelConstructor = this.endpointConfig.model();\n    let endpointConfig = this.endpointConfig;\n\n    let headers = {};\n    try {\n      headers = this.endpointConfig.api().commonHeaders();\n    } catch(e) {\n      // console.error('Unable to get common headers. Something went\\'t wrong (unless you are unit testing). ');\n    }\n    Object.assign(headers, this.config.headers);\n\n    let request = new Request()\n      .method(this.config.method)\n      .body(this.config.body || {})\n      .query(this.config.query || {})\n      .headers(headers || {})\n      .url(this.config.target.toString());\n\n    let Promise = require('./settings').getPromise();\n\n    return new Promise((resolve, reject) => {\n      if (this.hasCache()) {\n        let cachedObject = cache.get(request.url());\n        if (cachedObject && allowFromCache) {\n          cb(null, cachedObject);\n          return resolve(cachedObject);\n        }\n      }\n      //do actual 'get'\n      request.exec().then(response => {\n        let data = response.data;\n        let model;\n\n        if (Array.isArray(data)) {\n          model = data.map((item) => {\n            let entry = new modelConstructor(item);\n            entry.config(endpointConfig);\n            Object.defineProperty(entry, '__request', { value : clone(request), enumerable : false });\n            return entry;\n          });\n        } else {\n          model = new modelConstructor(data);\n          model.config(endpointConfig);\n          Object.defineProperty(model, '__request', { value : clone(request), enumerable : false });\n        }\n\n        if (this.hasCache()) {\n          cache.put(request.url(), model);\n        }\n        cb(null, model);\n        return resolve(model);\n      }).catch(err => {\n        if (this.hasCache()) {\n          cache.invalidate(request.url());\n        }\n        cb(err);\n        return reject(err);\n      });\n    });\n  }\n  /**\n   * Query helper to skip records returned from the api (if supported). Combined\n   * with the .limit method, this function is great for pagination\n   * @param {number} skipAmount\n   * @returns this\n   */\n  skip(skipAmount = 0) {\n    if ('number' === typeof skipAmount) {\n      this.config.query.skip = skipAmount;\n    }\n    return this;\n  }\n /**\n  * Query helper to limit the number of results returned (provided the api\n  * supports it)\n  * @param {number} limitAmount\n  * @returns this\n  */\n  limit(limitAmount = 0) {\n    if ('number' === typeof limitAmount) {\n      this.config.query.limit = limitAmount;\n    }\n    return this;\n  }\n  /**\n   * Sets a list of fields to return from the api (if supported).\n   * @param {(string|string[])} fields - a list of fields to return from the api\n   * @returns this\n   */\n  select(fields = '') {\n    if (Array.isArray(fields)) {\n      fields = fields.join(' ');\n    }\n    if ('string' === typeof fields) {\n      this.config.query.fields = fields;\n    }\n    return this;\n  }\n\n  /**\n   * Checks to see if the cache object has been set and is valid\n   * @access private\n   * @returns {boolean}\n   */\n  hasCache() {\n    return this.cache && 'function' === typeof this.cache;\n  }\n}\n\nmodule.exports = Endpoint;\n","/**\n * @constructor\n */\nclass HTTPMock {\n\tconstructor(verbose = false) {\n\t\tthis.listeners = {};\n\t\tthis.verbose = verbose;\n\t}\n\t/**\n\t * Mock representation of the XMLHttpRequest open method\n\t * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/open}\n\t * @param {string} method \n\t * @param {string} url \n\t * @returns {undefined}\n\t */\n\topen(method, url) {\n\t\tthis.log(`Opening ${url} using ${method}`);\n\t}\n\t/**\n\t * Mock representation of the XMLHttpRequest send method\n\t * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/send}\n\t * @param {object} body \n\t * @returns {undefined}\n\t */\n\tsend(body) {\n\t\tthis.log(`Sending with ${body}`);\n\t\tif ('function' === typeof this.listeners.load) {\n\t\t\tlet mockResponse = {\n\t\t\t\tresponse : {'mock_response' : true, 'data' : ['obj1']},\n\t\t\t\tresponseText : \"{'mock_response' : true}\",\n\t\t\t\tstatus : 200,\n\t\t\t\tstatusText : '200',\n\t\t\t\tresponseURL : '/mock-call'\n\t\t\t};\n\t\t\tObject.assign(this, mockResponse);\n\t\t\tthis.listeners.load();\n\t\t}\n\t}\n\t/**\n\t * Mock representation of the XMLHttpRequest getAllResponseHeaders method\n\t * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getAllResponseHeaders}\n\t * @returns {string} The mock headers\n\t */\n\tgetAllResponseHeaders() {\n\t\treturn \"Mock-Headers: true\";\n\t}\n\t/**\n\t * Representation of Javascript's addEventListener designed to hook into this\n\t * mock XMLHttpRequest object\n\t * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener}\n\t * @param {string} name - The name of the event to listen for\n\t * @param {function} callback - Function to call when event is triggered\n\t */\n\taddEventListener(name, callback) {\n\t\tthis.log(`${name} listener registered`);\n\t\tthis.listeners[name] = callback;\n\t}\n\t/**\n\t * Just a stub so we have a uniform interface between this and the real thing\n\t * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/setRequestHeader}\n\t * @param {string} header \n\t * @param {string} value \n\t */\n\tsetRequestHeader(header, value) {\n\t\treturn true;\n\t}\n\t/**\n\t * Helper function for logging status output based on this object's \n\t * verbosity settings (true/false)\n\t * @param {string} message \n\t */\n\tlog(message) {\n\t\tif (this.verbose === true) {\n\t\t\tconsole.log(message);\n\t\t}\n\t}\n}\n\nmodule.exports = HTTPMock;\n","const jsonpatch = require('fast-json-patch');\nconst clone = require('./utils.class').clone;\nconst noop = require('./utils.class').noop;\nconst Request = require('./request.class');\n\n/**\n * @constructor\n */\nclass Model {\n  constructor(data = {}) {\n    Object.defineProperty(this, '__config', {enumerable : false, writable : true});\n    Object.defineProperty(this, '__response', {enumerable : false, writable : true});\n    Object.defineProperty(this, '__original', {value : jsonpatch.deepClone(data), writable : true});\n    Object.defineProperty(this, '__revision', {value : Date.now(), writable : true});\n\n    Object.assign(this, clone(data));\n  }\n  /**\n   * Persists this model back to the api\n   * @param {function=} cb - Callback to invoke on completion (failure or success)\n   * @returns {Request}\n   */\n  save(cb = noop) {\n    let headers = {};\n    try {\n      headers = this.__config.api().commonHeaders();\n    } catch(e) {\n      //ignore\n    }\n\n    let method = this.id ? 'put' : 'post';\n    let instance = this;\n\n    let request = new Request()\n      .url(this.makeHref())\n      .method(method)\n      .headers(headers)\n      .body(this)\n      .exec()\n      .then((response) => {\n        Object.assign(instance, clone(response.data));\n        instance.__revision = Date.now();\n        instance.__response = response;\n        instance.makeClean();\n        cb();\n        return instance;\n      }).catch(err => {\n        cb(err);\n        throw err;\n      });\n\n    return request;\n  }\n\n  /**\n   * Gets a list of changes that have occured since the last get/save\n   * @returns {Request}\n   */\n  changes() {\n    let headers = this.__config.api().commonHeaders();\n    let targetUrl = this['@changes'];\n    let request = new Request()\n      .url(targetUrl)\n      .query({search : {since : this.__revision}})\n      .method('get')\n      .headers(headers)\n      .exec();\n    return request;\n  }\n\n  /**\n   * Starts listening for changes and calls onChange whenever they are detected\n   * @param {function} onChange - Function to call when changes detected\n   * @param {number} refreshRate - the duration (in milliseconds) between checks\n   * @returns {this}\n   */\n  subscribe(onChange, ttl = 3000) {\n    setInterval(() => {\n      this.changes().then(changeList => {\n        if (changeList && changeList.length) {\n          this.__revision = Date.now();\n          onChange(changeList, Date.now());\n        }\n      });\n    },ttl);\n\n    return this;\n  }\n\n  /**\n   * Puts only the changes (in patch notation) back to the api. The\n   * server-side endpoint must support PATCH\n   * @returns {Request}\n   */\n  update() {\n    //use patch\n    let headers = this.__config.api().commonHeaders();\n\n    let patches = this.getDiffs();\n    let targetUrl = this.makeHref();\n    let instance = this;\n    let request = new Request()\n      .url(targetUrl)\n      .method('patch')\n      .headers(headers)\n      .body(patches)\n      .exec()\n      .then((response) => {\n        Object.assign(instance, clone(response.data));\n        instance.__revision = Date.now();\n        instance.__response = response;\n        instance.makeClean();\n      });\n    return request;\n  }\n\n  /**\n   * Sets the underlying API config\n   * @param {EndpointConfig} endpointConfig\n   */\n  config(endpointConfig = {}) {\n    this.__config = endpointConfig;\n  }\n\n  makeHref() {\n    let correctHref;\n    if ('object' === typeof this.__config) {\n      correctHref = this.__config.baseUrl() + '/' + this.__config.url() + '/';\n      if ('string' === typeof this.id ) {\n        correctHref += this.id;\n      }\n    } else {\n      correctHref = '/__unit_test__';\n    }\n    return correctHref;\n  }\n\n  /**\n   * Returns a list of diffs comparing this version to the last\n   * synced version from the server\n   * @private\n   * @returns {object[]} Array of changes\n   */\n  getDiffs() {\n    return jsonpatch.compare(this.__original, this);\n  }\n  /**\n   * Returns the current status of this model\n   * @returns {boolean}\n   */\n  isDirty() {\n    return this.getDiffs().length > 0;\n  }\n  /**\n   * Clears out the change history and syncs the underlying original version\n   * to the current version\n   * @returns {undefined}\n   */\n  makeClean() {\n    this.__original = jsonpatch.deepClone(this);\n  }\n\n  /**\n   * Removes this modal from the api\n   * @param {function=} cb - Function to call on completetion (success or failure)\n   * @returns {Request}\n   */\n  remove(cb = noop) {\n    let headers = {};\n    try {\n      headers = this.__config.api().commonHeaders();\n    } catch(e) {}\n\n    let targetUrl = this.makeHref();\n    let instance = this;\n\n    let request = new Request()\n      .url(targetUrl)\n      .method('delete')\n      .headers(headers)\n      .exec()\n      .then((response) => {\n        instance.__response = response;\n        return cb();\n      }).catch(err => {\n        cb(err);\n        throw err;\n      });\n    return request;\n  }\n\n}\n\nmodule.exports = Model;\n","const Transport = require('./transport.class.js');\nconst clone = require('./utils.class').clone;\n\n/**\n * @constructor\n * @param {object=} config\n */\nclass Request {\n  constructor(config = {}) {\n    var defaults = {\n      method: 'GET',\n      url: '/',\n      headers: {},\n      data: undefined,\n      responseType : 'application/json',\n      params : {}\n    };\n    this.config = {};\n    Object.assign(this.config, defaults, config);\n  }\n  /**\n   * Executes the current request using the underlying transport mechanism (ie http)\n   * @returns {Promise}\n   */\n  exec() {\n    let originalRequest = this;\n    let Promise = require('./settings').getPromise();\n    return new Promise((resolve, reject) => {\n      originalRequest.transport = new Transport(originalRequest);\n\n      originalRequest.transport\n      .exec()\n      .then(function successCallback(response) {\n        response.data = clone(response.response);\n        // originalRequest.response = response;\n        response.request = originalRequest;\n        return resolve(response);\n      }, function errorCallback(response) {\n        // originalRequest.response = response;\n        response.request = originalRequest;        \n        return reject(response);\n      });\n    });\n  }\n  /**\n   * Gets / sets the query object to use\n   * @param {object=} newQuery \n   * @returns {(this | object)}\n   */\n  query(newQuery) {\n    if ('undefined' !== typeof newQuery) {\n      if ('object' === typeof newQuery && newQuery !== null) {\n        newQuery = clone(newQuery);\n      }\n      this.config.params = newQuery;\n      return this;\n    } else {\n      return this.config.params;\n    }\n  }\n  \n  /**\n   * Gets / sets the http verb (method) to use (ie get,put,post, etc)\n   * @param {string=} newMethod \n   * @returns {(this | string)}\n   */\n  method(newMethod) {\n    if ('undefined' !== typeof newMethod) {\n      if ('string' === typeof newMethod) {\n        this.config.method = newMethod;\n      }\n      return this;\n    } else {\n      return this.config.method;\n    }\n  }\n  \n  /**\n   * Gets / sets the target url to make the request to\n   * @param {string=} newUrl \n   * @returns {(this | string)}\n   */\n  url(newUrl) {\n    if ('undefined' !== typeof newUrl) {\n      if ('string' === typeof newUrl) {\n        this.config.url = newUrl;\n      }\n      return this;\n    } else {\n      return this.config.url;\n    }\n  }\n\n  /**\n   * Gets / sets headers (key / value pairs ) to use for the request\n   * @param {object=} newHeaderObj \n   * @returns {(this | object)}\n   */\n  headers(newHeaderObj) {\n    if ('undefined' !== typeof newHeaderObj) {\n      if ('object' === typeof newHeaderObj && newHeaderObj !== null) {\n        this.config.headers = clone(newHeaderObj);\n      }\n      return this;\n    } else {\n      return this.config.headers;\n    }\n  }\n\n  /**\n   * Gets / sets the request body\n   * @param {object=} newBody \n   * @returns {(this | object | undefined)}\n   */\n  body(newBody) {\n    if ('undefined' !== typeof newBody) {\n      if ('object' === typeof newBody && newBody !== null) {\n        this.config.data = clone(newBody);\n      }\n      return this;\n    } else {\n      return this.config.data;\n    }\n  }\n  /**\n   * Gets or sets the response type for the request\n   * @param {string=} newType \n   * @returns {(this | string)}\n   */\n  mediaType(newType) {\n    if ('undefined' !== typeof newType) {\n      if ('string' === typeof newType) {\n        this.config.responseType = newType;\n      }\n      return this;\n    }\n    return this.config.responseType;\n  }\n\n  /**\n   * Returns a copy of this request's configurations\n   * @returns {object}\n   */\n  toJSON() {\n    return JSON.parse( JSON.stringify(this.config) );\n  }\n}\n\nmodule.exports = Request;\n","/**\n * Reference point for all of the sdk modules to find common\n * settings, such as what promise to use\n * @singleton\n * @namespace OfficeBotSDK.Settings\n */\nlet settings = {\n  _p : Promise,\n  setPromiseLib : function(p) {\n    this._p = p;\n  },\n  getPromise : function() {\n    return this._p;\n  }\n};\n\nmodule.exports = settings;","const clone = require('./utils.class').clone;\nconst querystring = require('querystring');\n\n/**\n * @constructor\n */\nclass Transport {\n\tconstructor(request) {\n\t\tif ('undefined' !== typeof window && window.XMLHttpRequest) {\n\t\t\tthis.HTTPRequest = window.XMLHttpRequest;\n\t\t} else {\n\t\t\tthis.HTTPRequest = require('./http-mock.class.js'); //used for Node based tests\n\t\t}\n\t\tthis.setRequest(request);\n\t}\n\t/**\n\t * Stores the request object for use later (ie when .exec() gets called). Helpfull \n\t * if building the transport request up instead of passing everything into constructor.\n\t * @param {Request} request \n\t * @returns {this}\n\t */\n\tsetRequest(request) {\n\t\tthis.request = clone(request);\n\t\treturn this;\n\t}\n\t/**\n\t * Makes the actual api call using the Request object that was passed into the constructor \n\t * or added using the setRequest method.\n\t * @returns {Promise}\n\t */\n\texec() {\n\t\tlet Promise = require('./settings').getPromise();\t\t\n\t\tlet instance = this;\n\t\t\n\t\treturn new Promise((resolve, reject) => {\n\t\t\t\n\t\t\tlet httpInstance = new instance.HTTPRequest();\n\t\t\tlet url = instance.request.url() ;\n\n\t\t\tlet query = querystring.stringify(instance.request.query());\n\t\t\tif (query && query.length) {\n\t\t\t\turl = url + '?' + query;\n\t\t\t}\n\t\t\tlet body = instance.request.body();\n\t\t\tif ('object' === typeof body) {\n\t\t\t\tbody = JSON.stringify(body);\n\t\t\t}\n\t\t\t\n\t\t\thttpInstance.addEventListener(\"load\", transferComplete);\n\t\t\thttpInstance.addEventListener(\"error\", transferFailed);\n\t\t\thttpInstance.addEventListener(\"abort\", transferAborted);\n\t\t\thttpInstance.open( instance.request.method().toUpperCase(), url );\n\t\t\thttpInstance.responseType = 'json';\n\t\t\t\n\t\t\tlet headers = instance.request.headers();\n\t\t\thttpInstance.setRequestHeader(\"Content-Type\", instance.request.mediaType());\t\n\t\t\t\n\t\t\tfor ( let headerName in headers ) {\n\t\t\t\thttpInstance.setRequestHeader(headerName, headers[headerName]);\n\t\t\t}\n\t\t\thttpInstance.send( body );\n\n\t\t\t/**\n\t\t\t\t* Handler:Aborted\n\t\t\t\t*/\n\t\t\tfunction transferAborted() {\n\t\t\t\tlet failed = new Error('Transfer cancelled.');\n\t\t\t\treject(failed);\n\t\t\t}\n\t\t\t/**\n\t\t\t\t* Handler:Failed\n\t\t\t\t*/\n\t\t\tfunction transferFailed(e) {\n\t\t\t\treject(httpInstance);\n\t\t\t}\n\t\t\t/**\n\t\t\t\t* Handler:Finished\n\t\t\t\t*/\n\t\t\tfunction transferComplete() {\t\n\t\t\t\tif (httpInstance.status < 400) {\n\t\t\t\t\tresolve(httpInstance);\n\t\t\t\t} else {\n\t\t\t\t\treject(httpInstance);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n\nmodule.exports = Transport;\n","/**\n * @constructor\n * @param {string[]} args \n */\nclass URLBuilder {\n  constructor(args = []) {\n    if (!args || 'function' !== typeof args.join) {\n      throw new Error('URL Builder requires param 1 to be an array.');\n    }\n    this.target = args.filter(item => {\n      return item !== '/';\n    }).join('/') || \"/\";\n  }\n  /**\n   * @returns {string} url\n   */\n  toString() {\n    return this.target || '';\n  }\n}\n\nmodule.exports = URLBuilder;","var clone_lib = require('clone');\n\n/**\n * @constructor\n */\nclass Utils {\n    constructor() {\n\n    }\n    /**\n     * Does nothing\n     * @returns {undefined}\n     */\n    static noop() {\n\n    }\n\n    /**\n     * Creates a deep copy of the passed in object\n     * @param {object} obj - Object to copy\n     * @returns {object} Copied object\n     */\n    static clone(obj) {\n        return obj;\n        // return clone_lib(obj);\n        // return privateClone(obj);\n    }\n}\n/**\n * Allows our static method to call this recursively\n * @param {object} obj\n * @private\n * @returns {object} Copied object \n */\nfunction privateClone(obj) {\n   if(obj === null || typeof(obj) != 'object') {\n      return obj;\n   }\n   var temp = new obj.constructor();\n   for(var key in obj) {\n      temp[key] = privateClone(obj[key]);\n   }\n   return temp;\n}\n\nmodule.exports = Utils;"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJpbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Nsb25lL2Nsb25lLmpzIiwibm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9saWIvaXNfYXJndW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvbGliL2tleXMuanMiLCJub2RlX21vZHVsZXMvZmFzdC1qc29uLXBhdGNoL2xpYi9jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtanNvbi1wYXRjaC9saWIvZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtanNvbi1wYXRjaC9saWIvaGVscGVycy5qcyIsIm5vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9kZWNvZGUuanMiLCJub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCJzcmMvYXBpLWNvbmZpZy5jbGFzcy5qcyIsInNyYy9jYWNoZS5jbGFzcy5qcyIsInNyYy9lbmRwb2ludC1jb25maWcuY2xhc3MuanMiLCJzcmMvZW5kcG9pbnQuY2xhc3MuanMiLCJzcmMvaHR0cC1tb2NrLmNsYXNzLmpzIiwic3JjL21vZGVsLmNsYXNzLmpzIiwic3JjL3JlcXVlc3QuY2xhc3MuanMiLCJzcmMvc2V0dGluZ3MuanMiLCJzcmMvdHJhbnNwb3J0LmNsYXNzLmpzIiwic3JjL3VybC1idWlsZGVyLmNsYXNzLmpzIiwic3JjL3V0aWxzLmNsYXNzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUNBQTs7OztBQUlBLElBQUksTUFBTyxVQUFTLE9BQVQsRUFBa0I7O0FBRTNCLE1BQUksV0FBVyxRQUFRLG1CQUFSLENBQWY7QUFDQSxXQUFTLGFBQVQsQ0FBdUIsT0FBdkI7O0FBRUEsTUFBSSxVQUFVO0FBQ1osU0FBa0IsUUFBUSx3QkFBUixDQUROO0FBRVosV0FBa0IsUUFBUSxtQkFBUixDQUZOO0FBR1osb0JBQWtCLFFBQVEsNkJBQVIsQ0FITjtBQUlaLGNBQWtCLFFBQVEsc0JBQVIsQ0FKTjtBQUtaLGNBQWtCLFFBQVEsdUJBQVIsQ0FMTjtBQU1aLFdBQWtCLFFBQVEsbUJBQVIsQ0FOTjtBQU9aLGFBQWtCLFFBQVEscUJBQVIsQ0FQTjtBQVFaLGNBQWtCLFFBUk47QUFTWixjQUFrQixRQUFRLHVCQUFSLENBVE47QUFVWixnQkFBa0IsUUFBUSx5QkFBUixDQVZOO0FBV1osV0FBa0IsUUFBUSxtQkFBUjtBQVhOLEdBQWQ7O0FBY0EsU0FBTyxPQUFQO0FBRUQsQ0FyQlMsQ0FxQlAsT0FyQk8sQ0FBVjs7QUF1QkEsT0FBTyxPQUFQLEdBQWlCLEdBQWpCOzs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDSDs7Ozs7QUFFTDs7Ozs7Ozs7QUFNQSxTQUFTLFlBQVQsQ0FBc0IsR0FBdEIsRUFBMkI7QUFDeEIsTUFBRyxRQUFRLElBQVIsSUFBZ0IsUUFBTyxHQUFQLHlDQUFPLEdBQVAsTUFBZSxRQUFsQyxFQUE0QztBQUN6QyxXQUFPLEdBQVA7QUFDRjtBQUNELE1BQUksT0FBTyxJQUFJLElBQUksV0FBUixFQUFYO0FBQ0EsT0FBSSxJQUFJLEdBQVIsSUFBZSxHQUFmLEVBQW9CO0FBQ2pCLFNBQUssR0FBTCxJQUFZLGFBQWEsSUFBSSxHQUFKLENBQWIsQ0FBWjtBQUNGO0FBQ0QsU0FBTyxJQUFQO0FBQ0Y7O0FBRUQsT0FBTyxPQUFQLEdBQWlCLEtBQWpCIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qKlxuICogVGhpcyBjcmVhdGVzIGEgc2ltcGxlIHBhY2thZ2UgdGhhdCBjYW4gYmUgZXhwb3J0ZWRcbiAqIEBuYW1lc3BhY2UgT2ZmaWNlQm90U0RLLkluZGV4XG4gKi9cbmxldCBTREsgPSAoZnVuY3Rpb24oUHJvbWlzZSkge1xuXG4gIGxldCBTZXR0aW5ncyA9IHJlcXVpcmUoJy4vc3JjL3NldHRpbmdzLmpzJyk7XG4gIFNldHRpbmdzLnNldFByb21pc2VMaWIoUHJvbWlzZSk7XG5cbiAgbGV0IGV4cG9ydHMgPSB7XG4gICAgQVBJICAgICAgICAgICAgIDogcmVxdWlyZSgnLi9zcmMvYXBpLWNvbmZpZy5jbGFzcycpLFxuICAgIENhY2hlICAgICAgICAgICA6IHJlcXVpcmUoJy4vc3JjL2NhY2hlLmNsYXNzJyksXG4gICAgRW5kcG9pbnRDb25maWcgIDogcmVxdWlyZSgnLi9zcmMvZW5kcG9pbnQtY29uZmlnLmNsYXNzJyksXG4gICAgRW5kcG9pbnQgICAgICAgIDogcmVxdWlyZSgnLi9zcmMvZW5kcG9pbnQuY2xhc3MnKSxcbiAgICBIVFRQTW9jayAgICAgICAgOiByZXF1aXJlKCcuL3NyYy9odHRwLW1vY2suY2xhc3MnKSxcbiAgICBNb2RlbCAgICAgICAgICAgOiByZXF1aXJlKCcuL3NyYy9tb2RlbC5jbGFzcycpLFxuICAgIFJlcXVlc3QgICAgICAgICA6IHJlcXVpcmUoJy4vc3JjL3JlcXVlc3QuY2xhc3MnKSxcbiAgICBTZXR0aW5ncyAgICAgICAgOiBTZXR0aW5ncyxcbiAgICBUcmFucG9ydCAgICAgICAgOiByZXF1aXJlKCcuL3NyYy90cmFuc3BvcnQuY2xhc3MnKSxcbiAgICBVUkxCdWlsZGVyICAgICAgOiByZXF1aXJlKCcuL3NyYy91cmwtYnVpbGRlci5jbGFzcycpLFxuICAgIFV0aWxzICAgICAgICAgICA6IHJlcXVpcmUoJy4vc3JjL3V0aWxzLmNsYXNzJylcbiAgfTtcblxuICByZXR1cm4gZXhwb3J0cztcblxufSkoUHJvbWlzZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU0RLOyIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIHBsYWNlSG9sZGVyc0NvdW50IChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG4gIC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcbiAgLy8gcmVwcmVzZW50IG9uZSBieXRlXG4gIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuICAvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG4gIHJldHVybiBiNjRbbGVuIC0gMl0gPT09ICc9JyA/IDIgOiBiNjRbbGVuIC0gMV0gPT09ICc9JyA/IDEgOiAwXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICAvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbiAgcmV0dXJuIChiNjQubGVuZ3RoICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciBpLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIHBsYWNlSG9sZGVycyA9IHBsYWNlSG9sZGVyc0NvdW50KGI2NClcblxuICBhcnIgPSBuZXcgQXJyKChsZW4gKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnMpXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW5cblxuICB2YXIgTCA9IDBcblxuICBmb3IgKGkgPSAwOyBpIDwgbDsgaSArPSA0KSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBvdXRwdXQgPSAnJ1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPT0nXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArICh1aW50OFtsZW4gLSAxXSlcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAxMF1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9J1xuICB9XG5cbiAgcGFydHMucHVzaChvdXRwdXQpXG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxudmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmIChpc0FycmF5QnVmZmVyKHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIHZhciBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKGlzQXJyYXlCdWZmZXJWaWV3KG9iaikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChpc0FycmF5QnVmZmVyVmlldyhzdHJpbmcpIHx8IGlzQXJyYXlCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZylcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlcnMgZnJvbSBhbm90aGVyIGNvbnRleHQgKGkuZS4gYW4gaWZyYW1lKSBkbyBub3QgcGFzcyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrXG4vLyBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyB2YWxpZC4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQXJyYXlCdWZmZXInICYmXG4gICAgICB0eXBlb2Ygb2JqLmJ5dGVMZW5ndGggPT09ICdudW1iZXInKVxufVxuXG4vLyBOb2RlIDAuMTAgc3VwcG9ydHMgYEFycmF5QnVmZmVyYCBidXQgbGFja3MgYEFycmF5QnVmZmVyLmlzVmlld2BcbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3IChvYmopIHtcbiAgcmV0dXJuICh0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nKSAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcob2JqKVxufVxuXG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwidmFyIGNsb25lID0gKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfaW5zdGFuY2VvZihvYmosIHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUgIT0gbnVsbCAmJiBvYmogaW5zdGFuY2VvZiB0eXBlO1xufVxuXG52YXIgbmF0aXZlTWFwO1xudHJ5IHtcbiAgbmF0aXZlTWFwID0gTWFwO1xufSBjYXRjaChfKSB7XG4gIC8vIG1heWJlIGEgcmVmZXJlbmNlIGVycm9yIGJlY2F1c2Ugbm8gYE1hcGAuIEdpdmUgaXQgYSBkdW1teSB2YWx1ZSB0aGF0IG5vXG4gIC8vIHZhbHVlIHdpbGwgZXZlciBiZSBhbiBpbnN0YW5jZW9mLlxuICBuYXRpdmVNYXAgPSBmdW5jdGlvbigpIHt9O1xufVxuXG52YXIgbmF0aXZlU2V0O1xudHJ5IHtcbiAgbmF0aXZlU2V0ID0gU2V0O1xufSBjYXRjaChfKSB7XG4gIG5hdGl2ZVNldCA9IGZ1bmN0aW9uKCkge307XG59XG5cbnZhciBuYXRpdmVQcm9taXNlO1xudHJ5IHtcbiAgbmF0aXZlUHJvbWlzZSA9IFByb21pc2U7XG59IGNhdGNoKF8pIHtcbiAgbmF0aXZlUHJvbWlzZSA9IGZ1bmN0aW9uKCkge307XG59XG5cbi8qKlxuICogQ2xvbmVzIChjb3BpZXMpIGFuIE9iamVjdCB1c2luZyBkZWVwIGNvcHlpbmcuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBzdXBwb3J0cyBjaXJjdWxhciByZWZlcmVuY2VzIGJ5IGRlZmF1bHQsIGJ1dCBpZiB5b3UgYXJlIGNlcnRhaW5cbiAqIHRoZXJlIGFyZSBubyBjaXJjdWxhciByZWZlcmVuY2VzIGluIHlvdXIgb2JqZWN0LCB5b3UgY2FuIHNhdmUgc29tZSBDUFUgdGltZVxuICogYnkgY2FsbGluZyBjbG9uZShvYmosIGZhbHNlKS5cbiAqXG4gKiBDYXV0aW9uOiBpZiBgY2lyY3VsYXJgIGlzIGZhbHNlIGFuZCBgcGFyZW50YCBjb250YWlucyBjaXJjdWxhciByZWZlcmVuY2VzLFxuICogeW91ciBwcm9ncmFtIG1heSBlbnRlciBhbiBpbmZpbml0ZSBsb29wIGFuZCBjcmFzaC5cbiAqXG4gKiBAcGFyYW0gYHBhcmVudGAgLSB0aGUgb2JqZWN0IHRvIGJlIGNsb25lZFxuICogQHBhcmFtIGBjaXJjdWxhcmAgLSBzZXQgdG8gdHJ1ZSBpZiB0aGUgb2JqZWN0IHRvIGJlIGNsb25lZCBtYXkgY29udGFpblxuICogICAgY2lyY3VsYXIgcmVmZXJlbmNlcy4gKG9wdGlvbmFsIC0gdHJ1ZSBieSBkZWZhdWx0KVxuICogQHBhcmFtIGBkZXB0aGAgLSBzZXQgdG8gYSBudW1iZXIgaWYgdGhlIG9iamVjdCBpcyBvbmx5IHRvIGJlIGNsb25lZCB0b1xuICogICAgYSBwYXJ0aWN1bGFyIGRlcHRoLiAob3B0aW9uYWwgLSBkZWZhdWx0cyB0byBJbmZpbml0eSlcbiAqIEBwYXJhbSBgcHJvdG90eXBlYCAtIHNldHMgdGhlIHByb3RvdHlwZSB0byBiZSB1c2VkIHdoZW4gY2xvbmluZyBhbiBvYmplY3QuXG4gKiAgICAob3B0aW9uYWwgLSBkZWZhdWx0cyB0byBwYXJlbnQgcHJvdG90eXBlKS5cbiAqIEBwYXJhbSBgaW5jbHVkZU5vbkVudW1lcmFibGVgIC0gc2V0IHRvIHRydWUgaWYgdGhlIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXNcbiAqICAgIHNob3VsZCBiZSBjbG9uZWQgYXMgd2VsbC4gTm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBvbiB0aGUgcHJvdG90eXBlXG4gKiAgICBjaGFpbiB3aWxsIGJlIGlnbm9yZWQuIChvcHRpb25hbCAtIGZhbHNlIGJ5IGRlZmF1bHQpXG4qL1xuZnVuY3Rpb24gY2xvbmUocGFyZW50LCBjaXJjdWxhciwgZGVwdGgsIHByb3RvdHlwZSwgaW5jbHVkZU5vbkVudW1lcmFibGUpIHtcbiAgaWYgKHR5cGVvZiBjaXJjdWxhciA9PT0gJ29iamVjdCcpIHtcbiAgICBkZXB0aCA9IGNpcmN1bGFyLmRlcHRoO1xuICAgIHByb3RvdHlwZSA9IGNpcmN1bGFyLnByb3RvdHlwZTtcbiAgICBpbmNsdWRlTm9uRW51bWVyYWJsZSA9IGNpcmN1bGFyLmluY2x1ZGVOb25FbnVtZXJhYmxlO1xuICAgIGNpcmN1bGFyID0gY2lyY3VsYXIuY2lyY3VsYXI7XG4gIH1cbiAgLy8gbWFpbnRhaW4gdHdvIGFycmF5cyBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcywgd2hlcmUgY29ycmVzcG9uZGluZyBwYXJlbnRzXG4gIC8vIGFuZCBjaGlsZHJlbiBoYXZlIHRoZSBzYW1lIGluZGV4XG4gIHZhciBhbGxQYXJlbnRzID0gW107XG4gIHZhciBhbGxDaGlsZHJlbiA9IFtdO1xuXG4gIHZhciB1c2VCdWZmZXIgPSB0eXBlb2YgQnVmZmVyICE9ICd1bmRlZmluZWQnO1xuXG4gIGlmICh0eXBlb2YgY2lyY3VsYXIgPT0gJ3VuZGVmaW5lZCcpXG4gICAgY2lyY3VsYXIgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZGVwdGggPT0gJ3VuZGVmaW5lZCcpXG4gICAgZGVwdGggPSBJbmZpbml0eTtcblxuICAvLyByZWN1cnNlIHRoaXMgZnVuY3Rpb24gc28gd2UgZG9uJ3QgcmVzZXQgYWxsUGFyZW50cyBhbmQgYWxsQ2hpbGRyZW5cbiAgZnVuY3Rpb24gX2Nsb25lKHBhcmVudCwgZGVwdGgpIHtcbiAgICAvLyBjbG9uaW5nIG51bGwgYWx3YXlzIHJldHVybnMgbnVsbFxuICAgIGlmIChwYXJlbnQgPT09IG51bGwpXG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGlmIChkZXB0aCA9PT0gMClcbiAgICAgIHJldHVybiBwYXJlbnQ7XG5cbiAgICB2YXIgY2hpbGQ7XG4gICAgdmFyIHByb3RvO1xuICAgIGlmICh0eXBlb2YgcGFyZW50ICE9ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cblxuICAgIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIG5hdGl2ZU1hcCkpIHtcbiAgICAgIGNoaWxkID0gbmV3IG5hdGl2ZU1hcCgpO1xuICAgIH0gZWxzZSBpZiAoX2luc3RhbmNlb2YocGFyZW50LCBuYXRpdmVTZXQpKSB7XG4gICAgICBjaGlsZCA9IG5ldyBuYXRpdmVTZXQoKTtcbiAgICB9IGVsc2UgaWYgKF9pbnN0YW5jZW9mKHBhcmVudCwgbmF0aXZlUHJvbWlzZSkpIHtcbiAgICAgIGNoaWxkID0gbmV3IG5hdGl2ZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBwYXJlbnQudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJlc29sdmUoX2Nsb25lKHZhbHVlLCBkZXB0aCAtIDEpKTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KF9jbG9uZShlcnIsIGRlcHRoIC0gMSkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY2xvbmUuX19pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIGNoaWxkID0gW107XG4gICAgfSBlbHNlIGlmIChjbG9uZS5fX2lzUmVnRXhwKHBhcmVudCkpIHtcbiAgICAgIGNoaWxkID0gbmV3IFJlZ0V4cChwYXJlbnQuc291cmNlLCBfX2dldFJlZ0V4cEZsYWdzKHBhcmVudCkpO1xuICAgICAgaWYgKHBhcmVudC5sYXN0SW5kZXgpIGNoaWxkLmxhc3RJbmRleCA9IHBhcmVudC5sYXN0SW5kZXg7XG4gICAgfSBlbHNlIGlmIChjbG9uZS5fX2lzRGF0ZShwYXJlbnQpKSB7XG4gICAgICBjaGlsZCA9IG5ldyBEYXRlKHBhcmVudC5nZXRUaW1lKCkpO1xuICAgIH0gZWxzZSBpZiAodXNlQnVmZmVyICYmIEJ1ZmZlci5pc0J1ZmZlcihwYXJlbnQpKSB7XG4gICAgICBjaGlsZCA9IG5ldyBCdWZmZXIocGFyZW50Lmxlbmd0aCk7XG4gICAgICBwYXJlbnQuY29weShjaGlsZCk7XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfSBlbHNlIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIEVycm9yKSkge1xuICAgICAgY2hpbGQgPSBPYmplY3QuY3JlYXRlKHBhcmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvdG90eXBlID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHBhcmVudCk7XG4gICAgICAgIGNoaWxkID0gT2JqZWN0LmNyZWF0ZShwcm90byk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY2hpbGQgPSBPYmplY3QuY3JlYXRlKHByb3RvdHlwZSk7XG4gICAgICAgIHByb3RvID0gcHJvdG90eXBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaXJjdWxhcikge1xuICAgICAgdmFyIGluZGV4ID0gYWxsUGFyZW50cy5pbmRleE9mKHBhcmVudCk7XG5cbiAgICAgIGlmIChpbmRleCAhPSAtMSkge1xuICAgICAgICByZXR1cm4gYWxsQ2hpbGRyZW5baW5kZXhdO1xuICAgICAgfVxuICAgICAgYWxsUGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgICBhbGxDaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICB9XG5cbiAgICBpZiAoX2luc3RhbmNlb2YocGFyZW50LCBuYXRpdmVNYXApKSB7XG4gICAgICBwYXJlbnQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHZhciBrZXlDaGlsZCA9IF9jbG9uZShrZXksIGRlcHRoIC0gMSk7XG4gICAgICAgIHZhciB2YWx1ZUNoaWxkID0gX2Nsb25lKHZhbHVlLCBkZXB0aCAtIDEpO1xuICAgICAgICBjaGlsZC5zZXQoa2V5Q2hpbGQsIHZhbHVlQ2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIG5hdGl2ZVNldCkpIHtcbiAgICAgIHBhcmVudC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBlbnRyeUNoaWxkID0gX2Nsb25lKHZhbHVlLCBkZXB0aCAtIDEpO1xuICAgICAgICBjaGlsZC5hZGQoZW50cnlDaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpIGluIHBhcmVudCkge1xuICAgICAgdmFyIGF0dHJzO1xuICAgICAgaWYgKHByb3RvKSB7XG4gICAgICAgIGF0dHJzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywgaSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhdHRycyAmJiBhdHRycy5zZXQgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNoaWxkW2ldID0gX2Nsb25lKHBhcmVudFtpXSwgZGVwdGggLSAxKTtcbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHBhcmVudCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRG9uJ3QgbmVlZCB0byB3b3JyeSBhYm91dCBjbG9uaW5nIGEgc3ltYm9sIGJlY2F1c2UgaXQgaXMgYSBwcmltaXRpdmUsXG4gICAgICAgIC8vIGxpa2UgYSBudW1iZXIgb3Igc3RyaW5nLlxuICAgICAgICB2YXIgc3ltYm9sID0gc3ltYm9sc1tpXTtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHBhcmVudCwgc3ltYm9sKTtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IgJiYgIWRlc2NyaXB0b3IuZW51bWVyYWJsZSAmJiAhaW5jbHVkZU5vbkVudW1lcmFibGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZFtzeW1ib2xdID0gX2Nsb25lKHBhcmVudFtzeW1ib2xdLCBkZXB0aCAtIDEpO1xuICAgICAgICBpZiAoIWRlc2NyaXB0b3IuZW51bWVyYWJsZSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjaGlsZCwgc3ltYm9sLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluY2x1ZGVOb25FbnVtZXJhYmxlKSB7XG4gICAgICB2YXIgYWxsUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHBhcmVudCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbFByb3BlcnR5TmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3BlcnR5TmFtZSA9IGFsbFByb3BlcnR5TmFtZXNbaV07XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwYXJlbnQsIHByb3BlcnR5TmFtZSk7XG4gICAgICAgIGlmIChkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IuZW51bWVyYWJsZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkW3Byb3BlcnR5TmFtZV0gPSBfY2xvbmUocGFyZW50W3Byb3BlcnR5TmFtZV0sIGRlcHRoIC0gMSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjaGlsZCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG5cbiAgcmV0dXJuIF9jbG9uZShwYXJlbnQsIGRlcHRoKTtcbn1cblxuLyoqXG4gKiBTaW1wbGUgZmxhdCBjbG9uZSB1c2luZyBwcm90b3R5cGUsIGFjY2VwdHMgb25seSBvYmplY3RzLCB1c2VmdWxsIGZvciBwcm9wZXJ0eVxuICogb3ZlcnJpZGUgb24gRkxBVCBjb25maWd1cmF0aW9uIG9iamVjdCAobm8gbmVzdGVkIHByb3BzKS5cbiAqXG4gKiBVU0UgV0lUSCBDQVVUSU9OISBUaGlzIG1heSBub3QgYmVoYXZlIGFzIHlvdSB3aXNoIGlmIHlvdSBkbyBub3Qga25vdyBob3cgdGhpc1xuICogd29ya3MuXG4gKi9cbmNsb25lLmNsb25lUHJvdG90eXBlID0gZnVuY3Rpb24gY2xvbmVQcm90b3R5cGUocGFyZW50KSB7XG4gIGlmIChwYXJlbnQgPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgdmFyIGMgPSBmdW5jdGlvbiAoKSB7fTtcbiAgYy5wcm90b3R5cGUgPSBwYXJlbnQ7XG4gIHJldHVybiBuZXcgYygpO1xufTtcblxuLy8gcHJpdmF0ZSB1dGlsaXR5IGZ1bmN0aW9uc1xuXG5mdW5jdGlvbiBfX29ialRvU3RyKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cbmNsb25lLl9fb2JqVG9TdHIgPSBfX29ialRvU3RyO1xuXG5mdW5jdGlvbiBfX2lzRGF0ZShvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgX19vYmpUb1N0cihvKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuY2xvbmUuX19pc0RhdGUgPSBfX2lzRGF0ZTtcblxuZnVuY3Rpb24gX19pc0FycmF5KG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBfX29ialRvU3RyKG8pID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuY2xvbmUuX19pc0FycmF5ID0gX19pc0FycmF5O1xuXG5mdW5jdGlvbiBfX2lzUmVnRXhwKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBfX29ialRvU3RyKG8pID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmNsb25lLl9faXNSZWdFeHAgPSBfX2lzUmVnRXhwO1xuXG5mdW5jdGlvbiBfX2dldFJlZ0V4cEZsYWdzKHJlKSB7XG4gIHZhciBmbGFncyA9ICcnO1xuICBpZiAocmUuZ2xvYmFsKSBmbGFncyArPSAnZyc7XG4gIGlmIChyZS5pZ25vcmVDYXNlKSBmbGFncyArPSAnaSc7XG4gIGlmIChyZS5tdWx0aWxpbmUpIGZsYWdzICs9ICdtJztcbiAgcmV0dXJuIGZsYWdzO1xufVxuY2xvbmUuX19nZXRSZWdFeHBGbGFncyA9IF9fZ2V0UmVnRXhwRmxhZ3M7XG5cbnJldHVybiBjbG9uZTtcbn0pKCk7XG5cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xufVxuIiwidmFyIHBTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnLi9saWIva2V5cy5qcycpO1xudmFyIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9saWIvaXNfYXJndW1lbnRzLmpzJyk7XG5cbnZhciBkZWVwRXF1YWwgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhY3R1YWwsIGV4cGVjdGVkLCBvcHRzKSB7XG4gIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIERhdGUgJiYgZXhwZWN0ZWQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5nZXRUaW1lKCkgPT09IGV4cGVjdGVkLmdldFRpbWUoKTtcblxuICAvLyA3LjMuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIH0gZWxzZSBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQgfHwgdHlwZW9mIGFjdHVhbCAhPSAnb2JqZWN0JyAmJiB0eXBlb2YgZXhwZWN0ZWQgIT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gb3B0cy5zdHJpY3QgPyBhY3R1YWwgPT09IGV4cGVjdGVkIDogYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIDcuNC4gRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAvLyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkLCBvcHRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZE9yTnVsbCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKHgpIHtcbiAgaWYgKCF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgeC5sZW5ndGggIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgeC5jb3B5ICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB4LnNsaWNlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh4Lmxlbmd0aCA+IDAgJiYgdHlwZW9mIHhbMF0gIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBvcHRzKSB7XG4gIHZhciBpLCBrZXk7XG4gIGlmIChpc1VuZGVmaW5lZE9yTnVsbChhKSB8fCBpc1VuZGVmaW5lZE9yTnVsbChiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkgcmV0dXJuIGZhbHNlO1xuICAvL35+fkkndmUgbWFuYWdlZCB0byBicmVhayBPYmplY3Qua2V5cyB0aHJvdWdoIHNjcmV3eSBhcmd1bWVudHMgcGFzc2luZy5cbiAgLy8gICBDb252ZXJ0aW5nIHRvIGFycmF5IHNvbHZlcyB0aGUgcHJvYmxlbS5cbiAgaWYgKGlzQXJndW1lbnRzKGEpKSB7XG4gICAgaWYgKCFpc0FyZ3VtZW50cyhiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBkZWVwRXF1YWwoYSwgYiwgb3B0cyk7XG4gIH1cbiAgaWYgKGlzQnVmZmVyKGEpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgICAga2IgPSBvYmplY3RLZXlzKGIpO1xuICB9IGNhdGNoIChlKSB7Ly9oYXBwZW5zIHdoZW4gb25lIGlzIGEgc3RyaW5nIGxpdGVyYWwgYW5kIHRoZSBvdGhlciBpc24ndFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gIC8vIGhhc093blByb3BlcnR5KVxuICBpZiAoa2EubGVuZ3RoICE9IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9IGtiW2ldKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcbiAgLy9+fn5wb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIG9wdHMpKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYjtcbn1cbiIsInZhciBzdXBwb3J0c0FyZ3VtZW50c0NsYXNzID0gKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnRzKVxufSkoKSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNBcmd1bWVudHNDbGFzcyA/IHN1cHBvcnRlZCA6IHVuc3VwcG9ydGVkO1xuXG5leHBvcnRzLnN1cHBvcnRlZCA9IHN1cHBvcnRlZDtcbmZ1bmN0aW9uIHN1cHBvcnRlZChvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcblxuZXhwb3J0cy51bnN1cHBvcnRlZCA9IHVuc3VwcG9ydGVkO1xuZnVuY3Rpb24gdW5zdXBwb3J0ZWQob2JqZWN0KXtcbiAgcmV0dXJuIG9iamVjdCAmJlxuICAgIHR5cGVvZiBvYmplY3QgPT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2Ygb2JqZWN0Lmxlbmd0aCA9PSAnbnVtYmVyJyAmJlxuICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdjYWxsZWUnKSAmJlxuICAgICFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCAnY2FsbGVlJykgfHxcbiAgICBmYWxzZTtcbn07XG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbidcbiAgPyBPYmplY3Qua2V5cyA6IHNoaW07XG5cbmV4cG9ydHMuc2hpbSA9IHNoaW07XG5mdW5jdGlvbiBzaGltIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gIHJldHVybiBrZXlzO1xufVxuIiwidmFyIGVxdWFsc09wdGlvbnMgPSB7IHN0cmljdDogdHJ1ZSB9O1xyXG52YXIgX2VxdWFscyA9IHJlcXVpcmUoJ2RlZXAtZXF1YWwnKTtcclxudmFyIGFyZUVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICByZXR1cm4gX2VxdWFscyhhLCBiLCBlcXVhbHNPcHRpb25zKTtcclxufTtcclxudmFyIGhlbHBlcnNfMSA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xyXG5leHBvcnRzLkpzb25QYXRjaEVycm9yID0gaGVscGVyc18xLlBhdGNoRXJyb3I7XHJcbmV4cG9ydHMuZGVlcENsb25lID0gaGVscGVyc18xLl9kZWVwQ2xvbmU7XHJcbi8qIFdlIHVzZSBhIEphdmFzY3JpcHQgaGFzaCB0byBzdG9yZSBlYWNoXHJcbiBmdW5jdGlvbi4gRWFjaCBoYXNoIGVudHJ5IChwcm9wZXJ0eSkgdXNlc1xyXG4gdGhlIG9wZXJhdGlvbiBpZGVudGlmaWVycyBzcGVjaWZpZWQgaW4gcmZjNjkwMi5cclxuIEluIHRoaXMgd2F5LCB3ZSBjYW4gbWFwIGVhY2ggcGF0Y2ggb3BlcmF0aW9uXHJcbiB0byBpdHMgZGVkaWNhdGVkIGZ1bmN0aW9uIGluIGVmZmljaWVudCB3YXkuXHJcbiAqL1xyXG4vKiBUaGUgb3BlcmF0aW9ucyBhcHBsaWNhYmxlIHRvIGFuIG9iamVjdCAqL1xyXG52YXIgb2JqT3BzID0ge1xyXG4gICAgYWRkOiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XHJcbiAgICAgICAgb2JqW2tleV0gPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCB9O1xyXG4gICAgfSxcclxuICAgIHJlbW92ZTogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xyXG4gICAgICAgIHZhciByZW1vdmVkID0gb2JqW2tleV07XHJcbiAgICAgICAgZGVsZXRlIG9ialtrZXldO1xyXG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZDogcmVtb3ZlZCB9O1xyXG4gICAgfSxcclxuICAgIHJlcGxhY2U6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcclxuICAgICAgICB2YXIgcmVtb3ZlZCA9IG9ialtrZXldO1xyXG4gICAgICAgIG9ialtrZXldID0gdGhpcy52YWx1ZTtcclxuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHJlbW92ZWQ6IHJlbW92ZWQgfTtcclxuICAgIH0sXHJcbiAgICBtb3ZlOiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XHJcbiAgICAgICAgLyogaW4gY2FzZSBtb3ZlIHRhcmdldCBvdmVyd3JpdGVzIGFuIGV4aXN0aW5nIHZhbHVlLFxyXG4gICAgICAgIHJldHVybiB0aGUgcmVtb3ZlZCB2YWx1ZSwgdGhpcyBjYW4gYmUgdGF4aW5nIHBlcmZvcm1hbmNlLXdpc2UsXHJcbiAgICAgICAgYW5kIGlzIHBvdGVudGlhbGx5IHVubmVlZGVkICovXHJcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBnZXRWYWx1ZUJ5UG9pbnRlcihkb2N1bWVudCwgdGhpcy5wYXRoKTtcclxuICAgICAgICBpZiAocmVtb3ZlZCkge1xyXG4gICAgICAgICAgICByZW1vdmVkID0gaGVscGVyc18xLl9kZWVwQ2xvbmUocmVtb3ZlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvcmlnaW5hbFZhbHVlID0gYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIHsgb3A6IFwicmVtb3ZlXCIsIHBhdGg6IHRoaXMuZnJvbSB9KS5yZW1vdmVkO1xyXG4gICAgICAgIGFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCB7IG9wOiBcImFkZFwiLCBwYXRoOiB0aGlzLnBhdGgsIHZhbHVlOiBvcmlnaW5hbFZhbHVlIH0pO1xyXG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZDogcmVtb3ZlZCB9O1xyXG4gICAgfSxcclxuICAgIGNvcHk6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcclxuICAgICAgICB2YXIgdmFsdWVUb0NvcHkgPSBnZXRWYWx1ZUJ5UG9pbnRlcihkb2N1bWVudCwgdGhpcy5mcm9tKTtcclxuICAgICAgICAvLyBlbmZvcmNlIGNvcHkgYnkgdmFsdWUgc28gZnVydGhlciBvcGVyYXRpb25zIGRvbid0IGFmZmVjdCBzb3VyY2UgKHNlZSBpc3N1ZSAjMTc3KVxyXG4gICAgICAgIGFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCB7IG9wOiBcImFkZFwiLCBwYXRoOiB0aGlzLnBhdGgsIHZhbHVlOiBoZWxwZXJzXzEuX2RlZXBDbG9uZSh2YWx1ZVRvQ29weSkgfSk7XHJcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50IH07XHJcbiAgICB9LFxyXG4gICAgdGVzdDogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xyXG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgdGVzdDogYXJlRXF1YWxzKG9ialtrZXldLCB0aGlzLnZhbHVlKSB9O1xyXG4gICAgfSxcclxuICAgIF9nZXQ6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gb2JqW2tleV07XHJcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50IH07XHJcbiAgICB9XHJcbn07XHJcbi8qIFRoZSBvcGVyYXRpb25zIGFwcGxpY2FibGUgdG8gYW4gYXJyYXkuIE1hbnkgYXJlIHRoZSBzYW1lIGFzIGZvciB0aGUgb2JqZWN0ICovXHJcbnZhciBhcnJPcHMgPSB7XHJcbiAgICBhZGQ6IGZ1bmN0aW9uIChhcnIsIGksIGRvY3VtZW50KSB7XHJcbiAgICAgICAgaWYgKGhlbHBlcnNfMS5pc0ludGVnZXIoaSkpIHtcclxuICAgICAgICAgICAgYXJyLnNwbGljZShpLCAwLCB0aGlzLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFycltpXSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRoaXMgbWF5IGJlIG5lZWRlZCB3aGVuIHVzaW5nICctJyBpbiBhbiBhcnJheVxyXG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgaW5kZXg6IGkgfTtcclxuICAgIH0sXHJcbiAgICByZW1vdmU6IGZ1bmN0aW9uIChhcnIsIGksIGRvY3VtZW50KSB7XHJcbiAgICAgICAgdmFyIHJlbW92ZWRMaXN0ID0gYXJyLnNwbGljZShpLCAxKTtcclxuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHJlbW92ZWQ6IHJlbW92ZWRMaXN0WzBdIH07XHJcbiAgICB9LFxyXG4gICAgcmVwbGFjZTogZnVuY3Rpb24gKGFyciwgaSwgZG9jdW1lbnQpIHtcclxuICAgICAgICB2YXIgcmVtb3ZlZCA9IGFycltpXTtcclxuICAgICAgICBhcnJbaV0gPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZDogcmVtb3ZlZCB9O1xyXG4gICAgfSxcclxuICAgIG1vdmU6IG9iak9wcy5tb3ZlLFxyXG4gICAgY29weTogb2JqT3BzLmNvcHksXHJcbiAgICB0ZXN0OiBvYmpPcHMudGVzdCxcclxuICAgIF9nZXQ6IG9iak9wcy5fZ2V0XHJcbn07XHJcbi8qKlxyXG4gKiBSZXRyaWV2ZXMgYSB2YWx1ZSBmcm9tIGEgSlNPTiBkb2N1bWVudCBieSBhIEpTT04gcG9pbnRlci5cclxuICogUmV0dXJucyB0aGUgdmFsdWUuXHJcbiAqXHJcbiAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gZ2V0IHRoZSB2YWx1ZSBmcm9tXHJcbiAqIEBwYXJhbSBwb2ludGVyIGFuIGVzY2FwZWQgSlNPTiBwb2ludGVyXHJcbiAqIEByZXR1cm4gVGhlIHJldHJpZXZlZCB2YWx1ZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VmFsdWVCeVBvaW50ZXIoZG9jdW1lbnQsIHBvaW50ZXIpIHtcclxuICAgIGlmIChwb2ludGVyID09ICcnKSB7XHJcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xyXG4gICAgfVxyXG4gICAgdmFyIGdldE9yaWdpbmFsRGVzdGluYXRpb24gPSB7IG9wOiBcIl9nZXRcIiwgcGF0aDogcG9pbnRlciB9O1xyXG4gICAgYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIGdldE9yaWdpbmFsRGVzdGluYXRpb24pO1xyXG4gICAgcmV0dXJuIGdldE9yaWdpbmFsRGVzdGluYXRpb24udmFsdWU7XHJcbn1cclxuZXhwb3J0cy5nZXRWYWx1ZUJ5UG9pbnRlciA9IGdldFZhbHVlQnlQb2ludGVyO1xyXG4vKipcclxuICogQXBwbHkgYSBzaW5nbGUgSlNPTiBQYXRjaCBPcGVyYXRpb24gb24gYSBKU09OIGRvY3VtZW50LlxyXG4gKiBSZXR1cm5zIHRoZSB7bmV3RG9jdW1lbnQsIHJlc3VsdH0gb2YgdGhlIG9wZXJhdGlvbi5cclxuICogSXQgbW9kaWZpZXMgdGhlIGBkb2N1bWVudGAgYW5kIGBvcGVyYXRpb25gIG9iamVjdHMgLSBpdCBnZXRzIHRoZSB2YWx1ZXMgYnkgcmVmZXJlbmNlLlxyXG4gKiBJZiB5b3Ugd291bGQgbGlrZSB0byBhdm9pZCB0b3VjaGluZyB5b3VyIHZhbHVlcywgY2xvbmUgdGhlbTpcclxuICogYGpzb25wYXRjaC5hcHBseU9wZXJhdGlvbihkb2N1bWVudCwganNvbnBhdGNoLl9kZWVwQ2xvbmUob3BlcmF0aW9uKSlgLlxyXG4gKlxyXG4gKiBAcGFyYW0gZG9jdW1lbnQgVGhlIGRvY3VtZW50IHRvIHBhdGNoXHJcbiAqIEBwYXJhbSBvcGVyYXRpb24gVGhlIG9wZXJhdGlvbiB0byBhcHBseVxyXG4gKiBAcGFyYW0gdmFsaWRhdGVPcGVyYXRpb24gYGZhbHNlYCBpcyB3aXRob3V0IHZhbGlkYXRpb24sIGB0cnVlYCB0byB1c2UgZGVmYXVsdCBqc29ucGF0Y2gncyB2YWxpZGF0aW9uLCBvciB5b3UgY2FuIHBhc3MgYSBgdmFsaWRhdGVPcGVyYXRpb25gIGNhbGxiYWNrIHRvIGJlIHVzZWQgZm9yIHZhbGlkYXRpb24uXHJcbiAqIEBwYXJhbSBtdXRhdGVEb2N1bWVudCBXaGV0aGVyIHRvIG11dGF0ZSB0aGUgb3JpZ2luYWwgZG9jdW1lbnQgb3IgY2xvbmUgaXQgYmVmb3JlIGFwcGx5aW5nXHJcbiAqIEByZXR1cm4gYHtuZXdEb2N1bWVudCwgcmVzdWx0fWAgYWZ0ZXIgdGhlIG9wZXJhdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIG9wZXJhdGlvbiwgdmFsaWRhdGVPcGVyYXRpb24sIG11dGF0ZURvY3VtZW50KSB7XHJcbiAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24gPT09IHZvaWQgMCkgeyB2YWxpZGF0ZU9wZXJhdGlvbiA9IGZhbHNlOyB9XHJcbiAgICBpZiAobXV0YXRlRG9jdW1lbnQgPT09IHZvaWQgMCkgeyBtdXRhdGVEb2N1bWVudCA9IHRydWU7IH1cclxuICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsaWRhdGVPcGVyYXRpb24gPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB2YWxpZGF0ZU9wZXJhdGlvbihvcGVyYXRpb24sIDAsIGRvY3VtZW50LCBvcGVyYXRpb24ucGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YWxpZGF0b3Iob3BlcmF0aW9uLCAwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiBST09UIE9QRVJBVElPTlMgKi9cclxuICAgIGlmIChvcGVyYXRpb24ucGF0aCA9PT0gXCJcIikge1xyXG4gICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50IH07XHJcbiAgICAgICAgaWYgKG9wZXJhdGlvbi5vcCA9PT0gJ2FkZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBvcGVyYXRpb24udmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSAncmVwbGFjZScpIHtcclxuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBvcGVyYXRpb24udmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVyblZhbHVlLnJlbW92ZWQgPSBkb2N1bWVudDsgLy9kb2N1bWVudCB3ZSByZW1vdmVkXHJcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSAnbW92ZScgfHwgb3BlcmF0aW9uLm9wID09PSAnY29weScpIHtcclxuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBnZXRWYWx1ZUJ5UG9pbnRlcihkb2N1bWVudCwgb3BlcmF0aW9uLmZyb20pOyAvLyBnZXQgdGhlIHZhbHVlIGJ5IGpzb24tcG9pbnRlciBpbiBgZnJvbWAgZmllbGRcclxuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbi5vcCA9PT0gJ21vdmUnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZS5yZW1vdmVkID0gZG9jdW1lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09ICd0ZXN0Jykge1xyXG4gICAgICAgICAgICByZXR1cm5WYWx1ZS50ZXN0ID0gYXJlRXF1YWxzKGRvY3VtZW50LCBvcGVyYXRpb24udmFsdWUpO1xyXG4gICAgICAgICAgICBpZiAocmV0dXJuVmFsdWUudGVzdCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKFwiVGVzdCBvcGVyYXRpb24gZmFpbGVkXCIsICdURVNUX09QRVJBVElPTl9GQUlMRUQnLCAwLCBvcGVyYXRpb24sIGRvY3VtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5uZXdEb2N1bWVudCA9IGRvY3VtZW50O1xyXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gJ3JlbW92ZScpIHtcclxuICAgICAgICAgICAgcmV0dXJuVmFsdWUucmVtb3ZlZCA9IGRvY3VtZW50O1xyXG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5uZXdEb2N1bWVudCA9IG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSAnX2dldCcpIHtcclxuICAgICAgICAgICAgb3BlcmF0aW9uLnZhbHVlID0gZG9jdW1lbnQ7XHJcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ09wZXJhdGlvbiBgb3BgIHByb3BlcnR5IGlzIG5vdCBvbmUgb2Ygb3BlcmF0aW9ucyBkZWZpbmVkIGluIFJGQy02OTAyJywgJ09QRVJBVElPTl9PUF9JTlZBTElEJywgMCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9IC8qIEVORCBST09UIE9QRVJBVElPTlMgKi9cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmICghbXV0YXRlRG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQgPSBoZWxwZXJzXzEuX2RlZXBDbG9uZShkb2N1bWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwYXRoID0gb3BlcmF0aW9uLnBhdGggfHwgXCJcIjtcclxuICAgICAgICB2YXIga2V5cyA9IHBhdGguc3BsaXQoJy8nKTtcclxuICAgICAgICB2YXIgb2JqID0gZG9jdW1lbnQ7XHJcbiAgICAgICAgdmFyIHQgPSAxOyAvL3NraXAgZW1wdHkgZWxlbWVudCAtIGh0dHA6Ly9qc3BlcmYuY29tL3RvLXNoaWZ0LW9yLW5vdC10by1zaGlmdFxyXG4gICAgICAgIHZhciBsZW4gPSBrZXlzLmxlbmd0aDtcclxuICAgICAgICB2YXIgZXhpc3RpbmdQYXRoRnJhZ21lbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdmFyIGtleSA9IHZvaWQgMDtcclxuICAgICAgICB2YXIgdmFsaWRhdGVGdW5jdGlvbiA9IHZvaWQgMDtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbGlkYXRlT3BlcmF0aW9uID09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGVGdW5jdGlvbiA9IHZhbGlkYXRlT3BlcmF0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFsaWRhdGVGdW5jdGlvbiA9IHZhbGlkYXRvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAga2V5ID0ga2V5c1t0XTtcclxuICAgICAgICAgICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdQYXRoRnJhZ21lbnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmpba2V5XSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nUGF0aEZyYWdtZW50ID0ga2V5cy5zbGljZSgwLCB0KS5qb2luKCcvJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHQgPT0gbGVuIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1BhdGhGcmFnbWVudCA9IG9wZXJhdGlvbi5wYXRoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdQYXRoRnJhZ21lbnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uKG9wZXJhdGlvbiwgMCwgZG9jdW1lbnQsIGV4aXN0aW5nUGF0aEZyYWdtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdCsrO1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnLScpIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSBvYmoubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uICYmICFoZWxwZXJzXzEuaXNJbnRlZ2VyKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoXCJFeHBlY3RlZCBhbiB1bnNpZ25lZCBiYXNlLTEwIGludGVnZXIgdmFsdWUsIG1ha2luZyB0aGUgbmV3IHJlZmVyZW5jZWQgdmFsdWUgdGhlIGFycmF5IGVsZW1lbnQgd2l0aCB0aGUgemVyby1iYXNlZCBpbmRleFwiLCBcIk9QRVJBVElPTl9QQVRIX0lMTEVHQUxfQVJSQVlfSU5ERVhcIiwgMCwgb3BlcmF0aW9uLnBhdGgsIG9wZXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSAvLyBvbmx5IHBhcnNlIGtleSB3aGVuIGl0J3MgYW4gaW50ZWdlciBmb3IgYGFyci5wcm9wYCB0byB3b3JrXHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaGVscGVyc18xLmlzSW50ZWdlcihrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IH5+a2V5O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0ID49IGxlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbiAmJiBvcGVyYXRpb24ub3AgPT09IFwiYWRkXCIgJiYga2V5ID4gb2JqLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIlRoZSBzcGVjaWZpZWQgaW5kZXggTVVTVCBOT1QgYmUgZ3JlYXRlciB0aGFuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5XCIsIFwiT1BFUkFUSU9OX1ZBTFVFX09VVF9PRl9CT1VORFNcIiwgMCwgb3BlcmF0aW9uLnBhdGgsIG9wZXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IGFyck9wc1tvcGVyYXRpb24ub3BdLmNhbGwob3BlcmF0aW9uLCBvYmosIGtleSwgZG9jdW1lbnQpOyAvLyBBcHBseSBwYXRjaFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZS50ZXN0ID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCAnVEVTVF9PUEVSQVRJT05fRkFJTEVEJywgMCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChrZXkgJiYga2V5LmluZGV4T2YoJ34nKSAhPSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGhlbHBlcnNfMS51bmVzY2FwZVBhdGhDb21wb25lbnQoa2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0ID49IGxlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IG9iak9wc1tvcGVyYXRpb24ub3BdLmNhbGwob3BlcmF0aW9uLCBvYmosIGtleSwgZG9jdW1lbnQpOyAvLyBBcHBseSBwYXRjaFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZS50ZXN0ID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCAnVEVTVF9PUEVSQVRJT05fRkFJTEVEJywgMCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvYmogPSBvYmpba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5hcHBseU9wZXJhdGlvbiA9IGFwcGx5T3BlcmF0aW9uO1xyXG4vKipcclxuICogQXBwbHkgYSBmdWxsIEpTT04gUGF0Y2ggYXJyYXkgb24gYSBKU09OIGRvY3VtZW50LlxyXG4gKiBSZXR1cm5zIHRoZSB7bmV3RG9jdW1lbnQsIHJlc3VsdH0gb2YgdGhlIHBhdGNoLlxyXG4gKiBJdCBtb2RpZmllcyB0aGUgYGRvY3VtZW50YCBvYmplY3QgYW5kIGBwYXRjaGAgLSBpdCBnZXRzIHRoZSB2YWx1ZXMgYnkgcmVmZXJlbmNlLlxyXG4gKiBJZiB5b3Ugd291bGQgbGlrZSB0byBhdm9pZCB0b3VjaGluZyB5b3VyIHZhbHVlcywgY2xvbmUgdGhlbTpcclxuICogYGpzb25wYXRjaC5hcHBseVBhdGNoKGRvY3VtZW50LCBqc29ucGF0Y2guX2RlZXBDbG9uZShwYXRjaCkpYC5cclxuICpcclxuICogQHBhcmFtIGRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBwYXRjaFxyXG4gKiBAcGFyYW0gcGF0Y2ggVGhlIHBhdGNoIHRvIGFwcGx5XHJcbiAqIEBwYXJhbSB2YWxpZGF0ZU9wZXJhdGlvbiBgZmFsc2VgIGlzIHdpdGhvdXQgdmFsaWRhdGlvbiwgYHRydWVgIHRvIHVzZSBkZWZhdWx0IGpzb25wYXRjaCdzIHZhbGlkYXRpb24sIG9yIHlvdSBjYW4gcGFzcyBhIGB2YWxpZGF0ZU9wZXJhdGlvbmAgY2FsbGJhY2sgdG8gYmUgdXNlZCBmb3IgdmFsaWRhdGlvbi5cclxuICogQHJldHVybiBBbiBhcnJheSBvZiBge25ld0RvY3VtZW50LCByZXN1bHR9YCBhZnRlciB0aGUgcGF0Y2hcclxuICovXHJcbmZ1bmN0aW9uIGFwcGx5UGF0Y2goZG9jdW1lbnQsIHBhdGNoLCB2YWxpZGF0ZU9wZXJhdGlvbikge1xyXG4gICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uKSB7XHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGNoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcignUGF0Y2ggc2VxdWVuY2UgbXVzdCBiZSBhbiBhcnJheScsICdTRVFVRU5DRV9OT1RfQU5fQVJSQVknKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgcmVzdWx0cyA9IG5ldyBBcnJheShwYXRjaC5sZW5ndGgpO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aF8xID0gcGF0Y2gubGVuZ3RoOyBpIDwgbGVuZ3RoXzE7IGkrKykge1xyXG4gICAgICAgIHJlc3VsdHNbaV0gPSBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgcGF0Y2hbaV0sIHZhbGlkYXRlT3BlcmF0aW9uKTtcclxuICAgICAgICBkb2N1bWVudCA9IHJlc3VsdHNbaV0ubmV3RG9jdW1lbnQ7IC8vIGluIGNhc2Ugcm9vdCB3YXMgcmVwbGFjZWRcclxuICAgIH1cclxuICAgIHJlc3VsdHMubmV3RG9jdW1lbnQgPSBkb2N1bWVudDtcclxuICAgIHJldHVybiByZXN1bHRzO1xyXG59XHJcbmV4cG9ydHMuYXBwbHlQYXRjaCA9IGFwcGx5UGF0Y2g7XHJcbi8qKlxyXG4gKiBBcHBseSBhIHNpbmdsZSBKU09OIFBhdGNoIE9wZXJhdGlvbiBvbiBhIEpTT04gZG9jdW1lbnQuXHJcbiAqIFJldHVybnMgdGhlIHVwZGF0ZWQgZG9jdW1lbnQuXHJcbiAqIFN1aXRhYmxlIGFzIGEgcmVkdWNlci5cclxuICpcclxuICogQHBhcmFtIGRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBwYXRjaFxyXG4gKiBAcGFyYW0gb3BlcmF0aW9uIFRoZSBvcGVyYXRpb24gdG8gYXBwbHlcclxuICogQHJldHVybiBUaGUgdXBkYXRlZCBkb2N1bWVudFxyXG4gKi9cclxuZnVuY3Rpb24gYXBwbHlSZWR1Y2VyKGRvY3VtZW50LCBvcGVyYXRpb24pIHtcclxuICAgIHZhciBvcGVyYXRpb25SZXN1bHQgPSBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgb3BlcmF0aW9uKTtcclxuICAgIGlmIChvcGVyYXRpb25SZXN1bHQudGVzdCA9PT0gZmFsc2UpIHtcclxuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCAnVEVTVF9PUEVSQVRJT05fRkFJTEVEJywgMCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3BlcmF0aW9uUmVzdWx0Lm5ld0RvY3VtZW50O1xyXG59XHJcbmV4cG9ydHMuYXBwbHlSZWR1Y2VyID0gYXBwbHlSZWR1Y2VyO1xyXG4vKipcclxuICogVmFsaWRhdGVzIGEgc2luZ2xlIG9wZXJhdGlvbi4gQ2FsbGVkIGZyb20gYGpzb25wYXRjaC52YWxpZGF0ZWAuIFRocm93cyBgSnNvblBhdGNoRXJyb3JgIGluIGNhc2Ugb2YgYW4gZXJyb3IuXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcGVyYXRpb24gLSBvcGVyYXRpb24gb2JqZWN0IChwYXRjaClcclxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXggb2Ygb3BlcmF0aW9uIGluIHRoZSBzZXF1ZW5jZVxyXG4gKiBAcGFyYW0ge29iamVjdH0gW2RvY3VtZW50XSAtIG9iamVjdCB3aGVyZSB0aGUgb3BlcmF0aW9uIGlzIHN1cHBvc2VkIHRvIGJlIGFwcGxpZWRcclxuICogQHBhcmFtIHtzdHJpbmd9IFtleGlzdGluZ1BhdGhGcmFnbWVudF0gLSBjb21lcyBhbG9uZyB3aXRoIGBkb2N1bWVudGBcclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRvcihvcGVyYXRpb24sIGluZGV4LCBkb2N1bWVudCwgZXhpc3RpbmdQYXRoRnJhZ21lbnQpIHtcclxuICAgIGlmICh0eXBlb2Ygb3BlcmF0aW9uICE9PSAnb2JqZWN0JyB8fCBvcGVyYXRpb24gPT09IG51bGwgfHwgQXJyYXkuaXNBcnJheShvcGVyYXRpb24pKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ09wZXJhdGlvbiBpcyBub3QgYW4gb2JqZWN0JywgJ09QRVJBVElPTl9OT1RfQU5fT0JKRUNUJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIW9iak9wc1tvcGVyYXRpb24ub3BdKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ09wZXJhdGlvbiBgb3BgIHByb3BlcnR5IGlzIG5vdCBvbmUgb2Ygb3BlcmF0aW9ucyBkZWZpbmVkIGluIFJGQy02OTAyJywgJ09QRVJBVElPTl9PUF9JTlZBTElEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIG9wZXJhdGlvbi5wYXRoICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdPcGVyYXRpb24gYHBhdGhgIHByb3BlcnR5IGlzIG5vdCBhIHN0cmluZycsICdPUEVSQVRJT05fUEFUSF9JTlZBTElEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAob3BlcmF0aW9uLnBhdGguaW5kZXhPZignLycpICE9PSAwICYmIG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAvLyBwYXRocyB0aGF0IGFyZW4ndCBlbXB0eSBzdHJpbmcgc2hvdWxkIHN0YXJ0IHdpdGggXCIvXCJcclxuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcignT3BlcmF0aW9uIGBwYXRoYCBwcm9wZXJ0eSBtdXN0IHN0YXJ0IHdpdGggXCIvXCInLCAnT1BFUkFUSU9OX1BBVEhfSU5WQUxJRCcsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChvcGVyYXRpb24ub3AgPT09ICdtb3ZlJyB8fCBvcGVyYXRpb24ub3AgPT09ICdjb3B5JykgJiYgdHlwZW9mIG9wZXJhdGlvbi5mcm9tICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdPcGVyYXRpb24gYGZyb21gIHByb3BlcnR5IGlzIG5vdCBwcmVzZW50IChhcHBsaWNhYmxlIGluIGBtb3ZlYCBhbmQgYGNvcHlgIG9wZXJhdGlvbnMpJywgJ09QRVJBVElPTl9GUk9NX1JFUVVJUkVEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKG9wZXJhdGlvbi5vcCA9PT0gJ2FkZCcgfHwgb3BlcmF0aW9uLm9wID09PSAncmVwbGFjZScgfHwgb3BlcmF0aW9uLm9wID09PSAndGVzdCcpICYmIG9wZXJhdGlvbi52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ09wZXJhdGlvbiBgdmFsdWVgIHByb3BlcnR5IGlzIG5vdCBwcmVzZW50IChhcHBsaWNhYmxlIGluIGBhZGRgLCBgcmVwbGFjZWAgYW5kIGB0ZXN0YCBvcGVyYXRpb25zKScsICdPUEVSQVRJT05fVkFMVUVfUkVRVUlSRUQnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgob3BlcmF0aW9uLm9wID09PSAnYWRkJyB8fCBvcGVyYXRpb24ub3AgPT09ICdyZXBsYWNlJyB8fCBvcGVyYXRpb24ub3AgPT09ICd0ZXN0JykgJiYgaGVscGVyc18xLmhhc1VuZGVmaW5lZChvcGVyYXRpb24udmFsdWUpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ09wZXJhdGlvbiBgdmFsdWVgIHByb3BlcnR5IGlzIG5vdCBwcmVzZW50IChhcHBsaWNhYmxlIGluIGBhZGRgLCBgcmVwbGFjZWAgYW5kIGB0ZXN0YCBvcGVyYXRpb25zKScsICdPUEVSQVRJT05fVkFMVUVfQ0FOTk9UX0NPTlRBSU5fVU5ERUZJTkVEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZG9jdW1lbnQpIHtcclxuICAgICAgICBpZiAob3BlcmF0aW9uLm9wID09IFwiYWRkXCIpIHtcclxuICAgICAgICAgICAgdmFyIHBhdGhMZW4gPSBvcGVyYXRpb24ucGF0aC5zcGxpdChcIi9cIikubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdQYXRoTGVuID0gZXhpc3RpbmdQYXRoRnJhZ21lbnQuc3BsaXQoXCIvXCIpLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKHBhdGhMZW4gIT09IGV4aXN0aW5nUGF0aExlbiArIDEgJiYgcGF0aExlbiAhPT0gZXhpc3RpbmdQYXRoTGVuKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcignQ2Fubm90IHBlcmZvcm0gYW4gYGFkZGAgb3BlcmF0aW9uIGF0IHRoZSBkZXNpcmVkIHBhdGgnLCAnT1BFUkFUSU9OX1BBVEhfQ0FOTk9UX0FERCcsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09ICdyZXBsYWNlJyB8fCBvcGVyYXRpb24ub3AgPT09ICdyZW1vdmUnIHx8IG9wZXJhdGlvbi5vcCA9PT0gJ19nZXQnKSB7XHJcbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24ucGF0aCAhPT0gZXhpc3RpbmdQYXRoRnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdDYW5ub3QgcGVyZm9ybSB0aGUgb3BlcmF0aW9uIGF0IGEgcGF0aCB0aGF0IGRvZXMgbm90IGV4aXN0JywgJ09QRVJBVElPTl9QQVRIX1VOUkVTT0xWQUJMRScsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09ICdtb3ZlJyB8fCBvcGVyYXRpb24ub3AgPT09ICdjb3B5Jykge1xyXG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdWYWx1ZSA9IHsgb3A6IFwiX2dldFwiLCBwYXRoOiBvcGVyYXRpb24uZnJvbSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xyXG4gICAgICAgICAgICB2YXIgZXJyb3IgPSB2YWxpZGF0ZShbZXhpc3RpbmdWYWx1ZV0sIGRvY3VtZW50KTtcclxuICAgICAgICAgICAgaWYgKGVycm9yICYmIGVycm9yLm5hbWUgPT09ICdPUEVSQVRJT05fUEFUSF9VTlJFU09MVkFCTEUnKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcignQ2Fubm90IHBlcmZvcm0gdGhlIG9wZXJhdGlvbiBmcm9tIGEgcGF0aCB0aGF0IGRvZXMgbm90IGV4aXN0JywgJ09QRVJBVElPTl9GUk9NX1VOUkVTT0xWQUJMRScsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnRzLnZhbGlkYXRvciA9IHZhbGlkYXRvcjtcclxuLyoqXHJcbiAqIFZhbGlkYXRlcyBhIHNlcXVlbmNlIG9mIG9wZXJhdGlvbnMuIElmIGBkb2N1bWVudGAgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLCB0aGUgc2VxdWVuY2UgaXMgYWRkaXRpb25hbGx5IHZhbGlkYXRlZCBhZ2FpbnN0IHRoZSBvYmplY3QgZG9jdW1lbnQuXHJcbiAqIElmIGVycm9yIGlzIGVuY291bnRlcmVkLCByZXR1cm5zIGEgSnNvblBhdGNoRXJyb3Igb2JqZWN0XHJcbiAqIEBwYXJhbSBzZXF1ZW5jZVxyXG4gKiBAcGFyYW0gZG9jdW1lbnRcclxuICogQHJldHVybnMge0pzb25QYXRjaEVycm9yfHVuZGVmaW5lZH1cclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlKHNlcXVlbmNlLCBkb2N1bWVudCwgZXh0ZXJuYWxWYWxpZGF0b3IpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNlcXVlbmNlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcignUGF0Y2ggc2VxdWVuY2UgbXVzdCBiZSBhbiBhcnJheScsICdTRVFVRU5DRV9OT1RfQU5fQVJSQVknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRvY3VtZW50KSB7XHJcbiAgICAgICAgICAgIC8vY2xvbmUgZG9jdW1lbnQgYW5kIHNlcXVlbmNlIHNvIHRoYXQgd2UgY2FuIHNhZmVseSB0cnkgYXBwbHlpbmcgb3BlcmF0aW9uc1xyXG4gICAgICAgICAgICBhcHBseVBhdGNoKGhlbHBlcnNfMS5fZGVlcENsb25lKGRvY3VtZW50KSwgaGVscGVyc18xLl9kZWVwQ2xvbmUoc2VxdWVuY2UpLCBleHRlcm5hbFZhbGlkYXRvciB8fCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGV4dGVybmFsVmFsaWRhdG9yID0gZXh0ZXJuYWxWYWxpZGF0b3IgfHwgdmFsaWRhdG9yO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlcXVlbmNlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBleHRlcm5hbFZhbGlkYXRvcihzZXF1ZW5jZVtpXSwgaSwgZG9jdW1lbnQsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMudmFsaWRhdGUgPSB2YWxpZGF0ZTtcclxuIiwidmFyIGVxdWFsc09wdGlvbnMgPSB7IHN0cmljdDogdHJ1ZSB9O1xyXG52YXIgX2VxdWFscyA9IHJlcXVpcmUoJ2RlZXAtZXF1YWwnKTtcclxudmFyIGFyZUVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICByZXR1cm4gX2VxdWFscyhhLCBiLCBlcXVhbHNPcHRpb25zKTtcclxufTtcclxudmFyIGhlbHBlcnNfMSA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xyXG52YXIgY29yZV8xID0gcmVxdWlyZSgnLi9jb3JlJyk7XHJcbi8qIGV4cG9ydCBhbGwgY29yZSBmdW5jdGlvbnMgKi9cclxudmFyIGNvcmVfMiA9IHJlcXVpcmUoJy4vY29yZScpO1xyXG5leHBvcnRzLmFwcGx5T3BlcmF0aW9uID0gY29yZV8yLmFwcGx5T3BlcmF0aW9uO1xyXG5leHBvcnRzLmFwcGx5UGF0Y2ggPSBjb3JlXzIuYXBwbHlQYXRjaDtcclxuZXhwb3J0cy5hcHBseVJlZHVjZXIgPSBjb3JlXzIuYXBwbHlSZWR1Y2VyO1xyXG5leHBvcnRzLmdldFZhbHVlQnlQb2ludGVyID0gY29yZV8yLmdldFZhbHVlQnlQb2ludGVyO1xyXG5leHBvcnRzLnZhbGlkYXRlID0gY29yZV8yLnZhbGlkYXRlO1xyXG5leHBvcnRzLnZhbGlkYXRvciA9IGNvcmVfMi52YWxpZGF0b3I7XHJcbi8qIGV4cG9ydCBzb21lIGhlbHBlcnMgKi9cclxudmFyIGhlbHBlcnNfMiA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xyXG5leHBvcnRzLkpzb25QYXRjaEVycm9yID0gaGVscGVyc18yLlBhdGNoRXJyb3I7XHJcbmV4cG9ydHMuZGVlcENsb25lID0gaGVscGVyc18yLl9kZWVwQ2xvbmU7XHJcbmV4cG9ydHMuZXNjYXBlUGF0aENvbXBvbmVudCA9IGhlbHBlcnNfMi5lc2NhcGVQYXRoQ29tcG9uZW50O1xyXG5leHBvcnRzLnVuZXNjYXBlUGF0aENvbXBvbmVudCA9IGhlbHBlcnNfMi51bmVzY2FwZVBhdGhDb21wb25lbnQ7XHJcbnZhciBiZWZvcmVEaWN0ID0gW107XHJcbnZhciBNaXJyb3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTWlycm9yKG9iaikge1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5vYmogPSBvYmo7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTWlycm9yO1xyXG59KCkpO1xyXG52YXIgT2JzZXJ2ZXJJbmZvID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE9ic2VydmVySW5mbyhjYWxsYmFjaywgb2JzZXJ2ZXIpIHtcclxuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE9ic2VydmVySW5mbztcclxufSgpKTtcclxuZnVuY3Rpb24gZ2V0TWlycm9yKG9iaikge1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGJlZm9yZURpY3QubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoYmVmb3JlRGljdFtpXS5vYmogPT09IG9iaikge1xyXG4gICAgICAgICAgICByZXR1cm4gYmVmb3JlRGljdFtpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0T2JzZXJ2ZXJGcm9tTWlycm9yKG1pcnJvciwgY2FsbGJhY2spIHtcclxuICAgIGZvciAodmFyIGogPSAwLCBsZW5ndGggPSBtaXJyb3Iub2JzZXJ2ZXJzLmxlbmd0aDsgaiA8IGxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgaWYgKG1pcnJvci5vYnNlcnZlcnNbal0uY2FsbGJhY2sgPT09IGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtaXJyb3Iub2JzZXJ2ZXJzW2pdLm9ic2VydmVyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZW1vdmVPYnNlcnZlckZyb21NaXJyb3IobWlycm9yLCBvYnNlcnZlcikge1xyXG4gICAgZm9yICh2YXIgaiA9IDAsIGxlbmd0aCA9IG1pcnJvci5vYnNlcnZlcnMubGVuZ3RoOyBqIDwgbGVuZ3RoOyBqKyspIHtcclxuICAgICAgICBpZiAobWlycm9yLm9ic2VydmVyc1tqXS5vYnNlcnZlciA9PT0gb2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgbWlycm9yLm9ic2VydmVycy5zcGxpY2UoaiwgMSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIERldGFjaCBhbiBvYnNlcnZlciBmcm9tIGFuIG9iamVjdFxyXG4gKi9cclxuZnVuY3Rpb24gdW5vYnNlcnZlKHJvb3QsIG9ic2VydmVyKSB7XHJcbiAgICBvYnNlcnZlci51bm9ic2VydmUoKTtcclxufVxyXG5leHBvcnRzLnVub2JzZXJ2ZSA9IHVub2JzZXJ2ZTtcclxuLyoqXHJcbiAqIE9ic2VydmVzIGNoYW5nZXMgbWFkZSB0byBhbiBvYmplY3QsIHdoaWNoIGNhbiB0aGVuIGJlIHJldHJpZXZlZCB1c2luZyBnZW5lcmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gb2JzZXJ2ZShvYmosIGNhbGxiYWNrKSB7XHJcbiAgICB2YXIgcGF0Y2hlcyA9IFtdO1xyXG4gICAgdmFyIHJvb3QgPSBvYmo7XHJcbiAgICB2YXIgb2JzZXJ2ZXI7XHJcbiAgICB2YXIgbWlycm9yID0gZ2V0TWlycm9yKG9iaik7XHJcbiAgICBpZiAoIW1pcnJvcikge1xyXG4gICAgICAgIG1pcnJvciA9IG5ldyBNaXJyb3Iob2JqKTtcclxuICAgICAgICBiZWZvcmVEaWN0LnB1c2gobWlycm9yKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG9ic2VydmVyID0gZ2V0T2JzZXJ2ZXJGcm9tTWlycm9yKG1pcnJvciwgY2FsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgaWYgKG9ic2VydmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG9ic2VydmVyO1xyXG4gICAgfVxyXG4gICAgb2JzZXJ2ZXIgPSB7fTtcclxuICAgIG1pcnJvci52YWx1ZSA9IGhlbHBlcnNfMS5fZGVlcENsb25lKG9iaik7XHJcbiAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICBvYnNlcnZlci5jYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgICAgIG9ic2VydmVyLm5leHQgPSBudWxsO1xyXG4gICAgICAgIHZhciBkaXJ0eUNoZWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBnZW5lcmF0ZShvYnNlcnZlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgZmFzdENoZWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQob2JzZXJ2ZXIubmV4dCk7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQgPSBzZXRUaW1lb3V0KGRpcnR5Q2hlY2spO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBmYXN0Q2hlY2spO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZmFzdENoZWNrKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmYXN0Q2hlY2spO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmYXN0Q2hlY2spO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZhc3RDaGVjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ubW91c2V1cCcsIGZhc3RDaGVjayk7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ua2V5dXAnLCBmYXN0Q2hlY2spO1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmF0dGFjaEV2ZW50KCdvbm1vdXNlZG93bicsIGZhc3RDaGVjayk7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ua2V5ZG93bicsIGZhc3RDaGVjayk7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXR0YWNoRXZlbnQoJ29uY2hhbmdlJywgZmFzdENoZWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9ic2VydmVyLnBhdGNoZXMgPSBwYXRjaGVzO1xyXG4gICAgb2JzZXJ2ZXIub2JqZWN0ID0gb2JqO1xyXG4gICAgb2JzZXJ2ZXIudW5vYnNlcnZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGdlbmVyYXRlKG9ic2VydmVyKTtcclxuICAgICAgICBjbGVhclRpbWVvdXQob2JzZXJ2ZXIubmV4dCk7XHJcbiAgICAgICAgcmVtb3ZlT2JzZXJ2ZXJGcm9tTWlycm9yKG1pcnJvciwgb2JzZXJ2ZXIpO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBpZiAod2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZmFzdENoZWNrKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIGZhc3RDaGVjayk7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZmFzdENoZWNrKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZmFzdENoZWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kZXRhY2hFdmVudCgnb25tb3VzZXVwJywgZmFzdENoZWNrKTtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kZXRhY2hFdmVudCgnb25rZXl1cCcsIGZhc3RDaGVjayk7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZGV0YWNoRXZlbnQoJ29ubW91c2Vkb3duJywgZmFzdENoZWNrKTtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kZXRhY2hFdmVudCgnb25rZXlkb3duJywgZmFzdENoZWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBtaXJyb3Iub2JzZXJ2ZXJzLnB1c2gobmV3IE9ic2VydmVySW5mbyhjYWxsYmFjaywgb2JzZXJ2ZXIpKTtcclxuICAgIHJldHVybiBvYnNlcnZlcjtcclxufVxyXG5leHBvcnRzLm9ic2VydmUgPSBvYnNlcnZlO1xyXG4vKipcclxuICogR2VuZXJhdGUgYW4gYXJyYXkgb2YgcGF0Y2hlcyBmcm9tIGFuIG9ic2VydmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5lcmF0ZShvYnNlcnZlcikge1xyXG4gICAgdmFyIG1pcnJvcjtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBiZWZvcmVEaWN0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGJlZm9yZURpY3RbaV0ub2JqID09PSBvYnNlcnZlci5vYmplY3QpIHtcclxuICAgICAgICAgICAgbWlycm9yID0gYmVmb3JlRGljdFtpXTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2dlbmVyYXRlKG1pcnJvci52YWx1ZSwgb2JzZXJ2ZXIub2JqZWN0LCBvYnNlcnZlci5wYXRjaGVzLCBcIlwiKTtcclxuICAgIGlmIChvYnNlcnZlci5wYXRjaGVzLmxlbmd0aCkge1xyXG4gICAgICAgIGNvcmVfMS5hcHBseVBhdGNoKG1pcnJvci52YWx1ZSwgb2JzZXJ2ZXIucGF0Y2hlcyk7XHJcbiAgICB9XHJcbiAgICB2YXIgdGVtcCA9IG9ic2VydmVyLnBhdGNoZXM7XHJcbiAgICBpZiAodGVtcC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgb2JzZXJ2ZXIucGF0Y2hlcyA9IFtdO1xyXG4gICAgICAgIGlmIChvYnNlcnZlci5jYWxsYmFjaykge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5jYWxsYmFjayh0ZW1wKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGVtcDtcclxufVxyXG5leHBvcnRzLmdlbmVyYXRlID0gZ2VuZXJhdGU7XHJcbi8vIERpcnR5IGNoZWNrIGlmIG9iaiBpcyBkaWZmZXJlbnQgZnJvbSBtaXJyb3IsIGdlbmVyYXRlIHBhdGNoZXMgYW5kIHVwZGF0ZSBtaXJyb3JcclxuZnVuY3Rpb24gX2dlbmVyYXRlKG1pcnJvciwgb2JqLCBwYXRjaGVzLCBwYXRoKSB7XHJcbiAgICBpZiAob2JqID09PSBtaXJyb3IpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIG9iai50b0pTT04gPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIG9iaiA9IG9iai50b0pTT04oKTtcclxuICAgIH1cclxuICAgIHZhciBuZXdLZXlzID0gaGVscGVyc18xLl9vYmplY3RLZXlzKG9iaik7XHJcbiAgICB2YXIgb2xkS2V5cyA9IGhlbHBlcnNfMS5fb2JqZWN0S2V5cyhtaXJyb3IpO1xyXG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcclxuICAgIHZhciBkZWxldGVkID0gZmFsc2U7XHJcbiAgICAvL2lmIGV2ZXIgXCJtb3ZlXCIgb3BlcmF0aW9uIGlzIGltcGxlbWVudGVkIGhlcmUsIG1ha2Ugc3VyZSB0aGlzIHRlc3QgcnVucyBPSzogXCJzaG91bGQgbm90IGdlbmVyYXRlIHRoZSBzYW1lIHBhdGNoIHR3aWNlIChtb3ZlKVwiXHJcbiAgICBmb3IgKHZhciB0ID0gb2xkS2V5cy5sZW5ndGggLSAxOyB0ID49IDA7IHQtLSkge1xyXG4gICAgICAgIHZhciBrZXkgPSBvbGRLZXlzW3RdO1xyXG4gICAgICAgIHZhciBvbGRWYWwgPSBtaXJyb3Jba2V5XTtcclxuICAgICAgICBpZiAoaGVscGVyc18xLmhhc093blByb3BlcnR5KG9iaiwga2V5KSAmJiAhKG9ialtrZXldID09PSB1bmRlZmluZWQgJiYgb2xkVmFsICE9PSB1bmRlZmluZWQgJiYgQXJyYXkuaXNBcnJheShvYmopID09PSBmYWxzZSkpIHtcclxuICAgICAgICAgICAgdmFyIG5ld1ZhbCA9IG9ialtrZXldO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9sZFZhbCA9PSBcIm9iamVjdFwiICYmIG9sZFZhbCAhPSBudWxsICYmIHR5cGVvZiBuZXdWYWwgPT0gXCJvYmplY3RcIiAmJiBuZXdWYWwgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgX2dlbmVyYXRlKG9sZFZhbCwgbmV3VmFsLCBwYXRjaGVzLCBwYXRoICsgXCIvXCIgKyBoZWxwZXJzXzEuZXNjYXBlUGF0aENvbXBvbmVudChrZXkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChvbGRWYWwgIT09IG5ld1ZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoZXMucHVzaCh7IG9wOiBcInJlcGxhY2VcIiwgcGF0aDogcGF0aCArIFwiL1wiICsgaGVscGVyc18xLmVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSwgdmFsdWU6IGhlbHBlcnNfMS5fZGVlcENsb25lKG5ld1ZhbCkgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBhdGNoZXMucHVzaCh7IG9wOiBcInJlbW92ZVwiLCBwYXRoOiBwYXRoICsgXCIvXCIgKyBoZWxwZXJzXzEuZXNjYXBlUGF0aENvbXBvbmVudChrZXkpIH0pO1xyXG4gICAgICAgICAgICBkZWxldGVkID0gdHJ1ZTsgLy8gcHJvcGVydHkgaGFzIGJlZW4gZGVsZXRlZFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghZGVsZXRlZCAmJiBuZXdLZXlzLmxlbmd0aCA9PSBvbGRLZXlzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGZvciAodmFyIHQgPSAwOyB0IDwgbmV3S2V5cy5sZW5ndGg7IHQrKykge1xyXG4gICAgICAgIHZhciBrZXkgPSBuZXdLZXlzW3RdO1xyXG4gICAgICAgIGlmICghaGVscGVyc18xLmhhc093blByb3BlcnR5KG1pcnJvciwga2V5KSAmJiBvYmpba2V5XSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHBhdGNoZXMucHVzaCh7IG9wOiBcImFkZFwiLCBwYXRoOiBwYXRoICsgXCIvXCIgKyBoZWxwZXJzXzEuZXNjYXBlUGF0aENvbXBvbmVudChrZXkpLCB2YWx1ZTogaGVscGVyc18xLl9kZWVwQ2xvbmUob2JqW2tleV0pIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlIGFuIGFycmF5IG9mIHBhdGNoZXMgZnJvbSB0aGUgZGlmZmVyZW5jZXMgaW4gdHdvIG9iamVjdHNcclxuICovXHJcbmZ1bmN0aW9uIGNvbXBhcmUodHJlZTEsIHRyZWUyKSB7XHJcbiAgICB2YXIgcGF0Y2hlcyA9IFtdO1xyXG4gICAgX2dlbmVyYXRlKHRyZWUxLCB0cmVlMiwgcGF0Y2hlcywgJycpO1xyXG4gICAgcmV0dXJuIHBhdGNoZXM7XHJcbn1cclxuZXhwb3J0cy5jb21wYXJlID0gY29tcGFyZTtcclxuIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxuLyohXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9TdGFyY291bnRlci1KYWNrL0pTT04tUGF0Y2hcclxuICogKGMpIDIwMTcgSm9hY2hpbSBXZXN0ZXJcclxuICogTUlUIGxpY2Vuc2VcclxuICovXHJcbnZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIGtleSkge1xyXG4gICAgcmV0dXJuIF9oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcclxufVxyXG5leHBvcnRzLmhhc093blByb3BlcnR5ID0gaGFzT3duUHJvcGVydHk7XHJcbmZ1bmN0aW9uIF9vYmplY3RLZXlzKG9iaikge1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xyXG4gICAgICAgIHZhciBrZXlzID0gbmV3IEFycmF5KG9iai5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwga2V5cy5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICBrZXlzW2tdID0gXCJcIiArIGs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBrZXlzO1xyXG4gICAgfVxyXG4gICAgaWYgKE9iamVjdC5rZXlzKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XHJcbiAgICB9XHJcbiAgICB2YXIga2V5cyA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSBpbiBvYmopIHtcclxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkob2JqLCBpKSkge1xyXG4gICAgICAgICAgICBrZXlzLnB1c2goaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGtleXM7XHJcbn1cclxuZXhwb3J0cy5fb2JqZWN0S2V5cyA9IF9vYmplY3RLZXlzO1xyXG47XHJcbi8qKlxyXG4qIERlZXBseSBjbG9uZSB0aGUgb2JqZWN0LlxyXG4qIGh0dHBzOi8vanNwZXJmLmNvbS9kZWVwLWNvcHktdnMtanNvbi1zdHJpbmdpZnktanNvbi1wYXJzZS8yNSAocmVjdXJzaXZlRGVlcENvcHkpXHJcbiogQHBhcmFtICB7YW55fSBvYmogdmFsdWUgdG8gY2xvbmVcclxuKiBAcmV0dXJuIHthbnl9IGNsb25lZCBvYmpcclxuKi9cclxuZnVuY3Rpb24gX2RlZXBDbG9uZShvYmopIHtcclxuICAgIHN3aXRjaCAodHlwZW9mIG9iaikge1xyXG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcclxuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7IC8vRmFzdGVyIHRoYW4gRVM1IGNsb25lIC0gaHR0cDovL2pzcGVyZi5jb20vZGVlcC1jbG9uaW5nLW9mLW9iamVjdHMvNVxyXG4gICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vdGhpcyBpcyBob3cgSlNPTi5zdHJpbmdpZnkgYmVoYXZlcyBmb3IgYXJyYXkgaXRlbXNcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gb2JqOyAvL25vIG5lZWQgdG8gY2xvbmUgcHJpbWl0aXZlc1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuX2RlZXBDbG9uZSA9IF9kZWVwQ2xvbmU7XHJcbi8vM3ggZmFzdGVyIHRoYW4gY2FjaGVkIC9eXFxkKyQvLnRlc3Qoc3RyKVxyXG5mdW5jdGlvbiBpc0ludGVnZXIoc3RyKSB7XHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICB2YXIgbGVuID0gc3RyLmxlbmd0aDtcclxuICAgIHZhciBjaGFyQ29kZTtcclxuICAgIHdoaWxlIChpIDwgbGVuKSB7XHJcbiAgICAgICAgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBpZiAoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpIHtcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZXhwb3J0cy5pc0ludGVnZXIgPSBpc0ludGVnZXI7XHJcbi8qKlxyXG4qIEVzY2FwZXMgYSBqc29uIHBvaW50ZXIgcGF0aFxyXG4qIEBwYXJhbSBwYXRoIFRoZSByYXcgcG9pbnRlclxyXG4qIEByZXR1cm4gdGhlIEVzY2FwZWQgcGF0aFxyXG4qL1xyXG5mdW5jdGlvbiBlc2NhcGVQYXRoQ29tcG9uZW50KHBhdGgpIHtcclxuICAgIGlmIChwYXRoLmluZGV4T2YoJy8nKSA9PT0gLTEgJiYgcGF0aC5pbmRleE9mKCd+JykgPT09IC0xKVxyXG4gICAgICAgIHJldHVybiBwYXRoO1xyXG4gICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvfi9nLCAnfjAnKS5yZXBsYWNlKC9cXC8vZywgJ34xJyk7XHJcbn1cclxuZXhwb3J0cy5lc2NhcGVQYXRoQ29tcG9uZW50ID0gZXNjYXBlUGF0aENvbXBvbmVudDtcclxuLyoqXHJcbiAqIFVuZXNjYXBlcyBhIGpzb24gcG9pbnRlciBwYXRoXHJcbiAqIEBwYXJhbSBwYXRoIFRoZSBlc2NhcGVkIHBvaW50ZXJcclxuICogQHJldHVybiBUaGUgdW5lc2NhcGVkIHBhdGhcclxuICovXHJcbmZ1bmN0aW9uIHVuZXNjYXBlUGF0aENvbXBvbmVudChwYXRoKSB7XHJcbiAgICByZXR1cm4gcGF0aC5yZXBsYWNlKC9+MS9nLCAnLycpLnJlcGxhY2UoL34wL2csICd+Jyk7XHJcbn1cclxuZXhwb3J0cy51bmVzY2FwZVBhdGhDb21wb25lbnQgPSB1bmVzY2FwZVBhdGhDb21wb25lbnQ7XHJcbmZ1bmN0aW9uIF9nZXRQYXRoUmVjdXJzaXZlKHJvb3QsIG9iaikge1xyXG4gICAgdmFyIGZvdW5kO1xyXG4gICAgZm9yICh2YXIga2V5IGluIHJvb3QpIHtcclxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkocm9vdCwga2V5KSkge1xyXG4gICAgICAgICAgICBpZiAocm9vdFtrZXldID09PSBvYmopIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlc2NhcGVQYXRoQ29tcG9uZW50KGtleSkgKyAnLyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJvb3Rba2V5XSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgIGZvdW5kID0gX2dldFBhdGhSZWN1cnNpdmUocm9vdFtrZXldLCBvYmopO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kICE9ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSArICcvJyArIGZvdW5kO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuICcnO1xyXG59XHJcbmV4cG9ydHMuX2dldFBhdGhSZWN1cnNpdmUgPSBfZ2V0UGF0aFJlY3Vyc2l2ZTtcclxuZnVuY3Rpb24gZ2V0UGF0aChyb290LCBvYmopIHtcclxuICAgIGlmIChyb290ID09PSBvYmopIHtcclxuICAgICAgICByZXR1cm4gJy8nO1xyXG4gICAgfVxyXG4gICAgdmFyIHBhdGggPSBfZ2V0UGF0aFJlY3Vyc2l2ZShyb290LCBvYmopO1xyXG4gICAgaWYgKHBhdGggPT09ICcnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0IG5vdCBmb3VuZCBpbiByb290XCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICcvJyArIHBhdGg7XHJcbn1cclxuZXhwb3J0cy5nZXRQYXRoID0gZ2V0UGF0aDtcclxuLyoqXHJcbiogUmVjdXJzaXZlbHkgY2hlY2tzIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhbnkgdW5kZWZpbmVkIHZhbHVlcyBpbnNpZGUuXHJcbiovXHJcbmZ1bmN0aW9uIGhhc1VuZGVmaW5lZChvYmopIHtcclxuICAgIGlmIChvYmogPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKG9iaikge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc1VuZGVmaW5lZChvYmpbaV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICB2YXIgb2JqS2V5cyA9IF9vYmplY3RLZXlzKG9iaik7XHJcbiAgICAgICAgICAgIHZhciBvYmpLZXlzTGVuZ3RoID0gb2JqS2V5cy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqS2V5c0xlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzVW5kZWZpbmVkKG9ialtvYmpLZXlzW2ldXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5leHBvcnRzLmhhc1VuZGVmaW5lZCA9IGhhc1VuZGVmaW5lZDtcclxudmFyIFBhdGNoRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFBhdGNoRXJyb3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBQYXRjaEVycm9yKG1lc3NhZ2UsIG5hbWUsIGluZGV4LCBvcGVyYXRpb24sIHRyZWUpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKTtcclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIHRoaXMub3BlcmF0aW9uID0gb3BlcmF0aW9uO1xyXG4gICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUGF0Y2hFcnJvcjtcclxufShFcnJvcikpO1xyXG5leHBvcnRzLlBhdGNoRXJyb3IgPSBQYXRjaEVycm9yO1xyXG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIiwiY29uc3QgRW5kcG9pbnRDb25maWcgPSByZXF1aXJlKCcuL2VuZHBvaW50LWNvbmZpZy5jbGFzcy5qcycpO1xuY29uc3QgRW5kcG9pbnQgPSByZXF1aXJlKCcuL2VuZHBvaW50LmNsYXNzLmpzJyk7XG5jb25zdCBDYWNoZSA9IHJlcXVpcmUoJy4vY2FjaGUuY2xhc3MnKTtcbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi91dGlscy5jbGFzcycpLmNsb25lO1xuXG4vKipcbiAqIERlZmluZXMgdGhlIGJhc2UgY29uZmlndXJhdGlvbiBmb3IgYW4gQVBJXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgQVBJQ29uZmlnIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jb25maWcgPSB7IGhlYWRlcnMgOiB7fSwgdXJsIDogJycgfTtcbiAgICB0aGlzLmVuZHBvaW50cyA9IHt9O1xuICAgIHRoaXMuY2FjaGUgPSBuZXcgQ2FjaGUoKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyAvIFNldHMgYmFzZSBhcGkgdXJsXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gdXJsIC0gQmFzZSB1cmwgdGhhdCB0aGlzIGVuZHBvaW50IHRhbGtzIHRvXG4gICAqIEByZXR1cm5zIHsodGhpc3xzdHJpbmcpfVxuICAgKi9cbiAgYmFzZVVybCh1cmwpIHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiB1cmwpIHtcbiAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHVybCkge1xuICAgICAgICB0aGlzLmNvbmZpZy51cmwgPSB1cmw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLnVybDtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBlbmRwb2ludFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZW5kcG9pbnROYW1lIC0gVGhlIG5hbWUgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZ2V0IHRoaXMgZW5kcG9pbnRcbiAgICogQHJldHVybnMge0BsaW5rIEVuZHBvaW50fSBBbiBpbnN0YW5jZSBvZiBFbmRwb2ludFxuICAgKi9cbiAgZW5kcG9pbnQoZW5kcG9pbnROYW1lID0gJ19fZGVmYXVsdF9fJykge1xuICAgIGxldCBjb25maWcgPSBuZXcgRW5kcG9pbnRDb25maWcoKS5hcGkodGhpcyk7XG4gICAgdGhpc1sgZW5kcG9pbnROYW1lIF0gPSBuZXcgRW5kcG9pbnQoY29uZmlnKTtcbiAgICByZXR1cm4gdGhpc1sgZW5kcG9pbnROYW1lIF07XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgaGVhZGVycyB0aGF0IGFsbCBjYWxscyB3aWxsIHVzZS4gSGVscGZ1bCBmb3IgYXV0aGVudGljYXRpb25cbiAgICogQHBhcmFtIHtvYmplY3Q9fSBoZWFkZXJzIC0gS2V5IC8gdmFsdWUgcGFpcnMgb2YgaGVhZGVyc1xuICAgKiBAcmV0dXJucyB7dGhpcyB8IG9iamVjdH1cbiAgICovXG4gIGNvbW1vbkhlYWRlcnMoaGVhZGVycykge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGhlYWRlcnMpIHtcbiAgICAgIHRoaXMuY29uZmlnLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjbG9uZSh0aGlzLmNvbmZpZy5oZWFkZXJzKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBUElDb25maWc7IiwiLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgQ2FjaGUge1xuICAvKipcbiAgICogQ3JlYXRlIGEgY2FjaGUgb2JqZWN0XG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm9iamVjdHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICB0dGwgOiA2MDAwMCxcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaGVzIGFuIG9iamVjdCBmcm9tIHRoZSBjYWNoZSB1c2luZyB0aGUgb2JqZWN0J3MgbmFtZSAodHlwaWNhbGx5IHRoZSB1cmwpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFxuICAgKiBAcmV0dXJucyB7KG9iamVjdHxBcnJheXx1bmRlZmluZWQpfSBUaGUgZm91bmQgb2JqZWN0IG9yIGFycmF5IGlmIGV4aXN0cywgb3RoZXJ3aXNlIHVuZGVmaW5lZFxuICAgKi9cbiAgZ2V0KG5hbWUpIHtcbiAgICBsZXQgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgb2JqID0gdGhpcy5vYmplY3RzLmdldChuYW1lKTtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBvYmogJiYgbm93IC0gb2JqWzBdIDwgdGhpcy5jb25maWcudHRsKSB7XG4gICAgICBsZXQgY2FjaGVkT2JqZWN0ID0gb2JqWzFdO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNhY2hlZE9iamVjdCwnX19mcm9tQ2FjaGUnLCB7dmFsdWUgOiB0cnVlfSk7XG4gICAgICByZXR1cm4gY2FjaGVkT2JqZWN0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9iamVjdHMuZGVsZXRlKG5hbWUpOyAvL2luIGNhc2UgdGhlIG9iamVjdCBleGlzdHMgYnV0IGhhcyBleHBpcmVkXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU3RvcmVzIGFueSBvYmplY3Qgb3IgcHJpbWl0aXZlIGludG8gdGhlIGNhY2hlIHVzaW5nIGl0J3MgbmFtZVxuICAgKiBOT1RFOiBQcmltaXRpdmVzIFdJTEwgYmUgY29udmVydGVkIHRvIG9iamVjdHMgcHJpb3IgdG8gY2FjaGluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBcbiAgICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcnxib29sZWFufG9iamVjdCl9IHZhbHVlIFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gc3VjY2Vzc1xuICAgKi9cbiAgcHV0KG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG5hbWUgYXR0cmlidXRlJyk7XG4gICAgfVxuICAgIC8vY29udmVydCBwcmltaXRpdmUgc3RyaW5ncyB0byBzdHJpbmcgb2JqZWN0cyBzbyB3ZSBjYW4gYWRkIF9fZnJvbUNhY2hlZFxuICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IG5ldyBTdHJpbmcodmFsdWUpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICB9XG4gICAgaWYgKCdudW1iZXInID09PSB0eXBlb2YgdmFsdWUpIHtcbiAgICAgIHZhbHVlID0gbmV3IE51bWJlcih2YWx1ZSk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIH1cbiAgICBpZiAoJ2Jvb2xlYW4nID09PSB0eXBlb2YgdmFsdWUpIHtcbiAgICAgIHZhbHVlID0gbmV3IEJvb2xlYW4odmFsdWUpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmUgICAgICBcbiAgICB9XG4gICAgdGhpcy5vYmplY3RzLnNldChuYW1lLCBbRGF0ZS5ub3coKSwgdmFsdWVdKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBvYmplY3QgZnJvbSB0aGUgY2FjaGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgXG4gICAqL1xuICBpbnZhbGlkYXRlKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5vYmplY3RzLmRlbGV0ZShuYW1lKTtcbiAgfVxuICAvKipcbiAgICogQ2hhbmdlcyB0aGUgZGVmYXVsdCB0aW1lIHRvIGxpdmUgb2Ygb2JqZWN0cyBpbiB0aGUgY2FjaGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG5ld1RUTCBcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHN1Y2Nlc3NcbiAgICovXG4gIHNldFRUTChuZXdUVEwpIHtcbiAgICBpZiAoJ251bWJlcicgIT09IHR5cGVvZiBuZXdUVEwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBUVEwgdmFsdWUnKTtcbiAgICB9XG4gICAgdGhpcy5jb25maWcudHRsID0gbmV3VFRMO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FjaGU7IiwiY29uc3QgTW9kZWwgPSByZXF1aXJlKCcuL21vZGVsLmNsYXNzJyk7XG5jb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4vdXRpbHMuY2xhc3MnKS5jbG9uZTtcbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIEVuZHBvaW50Q29uZmlnIHtcbiAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICB0aGlzLmNvbmZpZyA9IHsgYXBpIDoge319O1xuXG4gICAgbGV0IGRlZmF1bHRzID0ge1xuICAgICAgJ3VybCcgOiAnLycsXG4gICAgICAncmVzcG9uc2VUeXBlJyA6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgJ2luc3RhbnRpYXRvcicgOiBNb2RlbFxuICAgIH07XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLmNvbmZpZywgZGVmYXVsdHMsIGNsb25lKGNvbmZpZykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgZXhwZWN0ZWQgbWVkaWEgcmV0dXJuIHR5cGUuIFVsdGltYXRlbHksIGl0IGlzIHVwIHRvIHRoZSB0cmFuc3BvcnRcbiAgICogdG8gdXNlIHRoaXMgc2V0dGluZyB0byBjb3JyZWN0bHkgdGFsayB0byB0aGUgYXBpXG4gICAqIE5vdGUgLSBUaGlzIGlzIGN1cnJlbnRseSB1bnVzZWRcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBuZXdUeXBlIC0gVGhlIG5ldyBtZWRpYSB0eXBlIHRoYXQgdGhpcyBlbmRwb2ludCBjb21tdW5pY2F0ZXMgd2l0aFxuICAgKi9cbiAgbWVkaWFUeXBlKG5ld1R5cGUpIHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBuZXdUeXBlKSB7XG4gICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBuZXdUeXBlKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLnJlc3BvbnNlVHlwZSA9IG5ld1R5cGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIC8gc2V0cyB0aGUgQVBJIGNvbmZpZ3VyYXRpb24gb2JqZWN0LiBUaGlzIGlzIG5lZWRlZCBzbyBlYWNoXG4gICAqIGVuZHBvaW50IGNhbiBzaGFyZSBjb21tb24gc2V0dGluZ3NcbiAgICogQHBhcmFtIHtBUElDb25maWd9IGNvbmZpZyAtIFRoZSBwYXJlbnQgYXBpIGNvbmZpZ3VyYXRpb24gXG4gICAqIEByZXR1cm5zIHsodGhpcyB8IG9iamVjdCl9XG4gICAqL1xuICBhcGkoY29uZmlnKSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgY29uZmlnKSB7XG4gICAgICBpZiAoJ29iamVjdCcgPT09IHR5cGVvZiBjb25maWcgJiYgY29uZmlnICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmFwaSA9IGNsb25lKGNvbmZpZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmFwaTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBiYXNlIHVybCBmcm9tIHRoZSB1bmRlcmx5aW5nIGFwaSBjb25maWd1cmF0aW9uIFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBDdXJyZW50IHJvb3QgdXJsXG4gICAqL1xuICBiYXNlVXJsKCkge1xuICAgIGlmICghdGhpcy5jb25maWcuYXBpIHx8ICF0aGlzLmNvbmZpZy5hcGkuYmFzZVVybCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb25maWcuYXBpLmJhc2VVcmwoKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyAvIHNldHMgdGhlIGVuZHBvaW50J3MgcmVsYXRpdmUgdXJsXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbmV3VXJsIC0gVXJsIHRvIHVzZSBmb3IgdGhpcyBlbmRwb2ludFxuICAgKiBAcmV0dXJucyB7KHRoaXMgfCBzdHJpbmcpfSBUaGlzIGluc3RhbmNlIG9yIHRoZSBjdXJyZW50IHVybFxuICAgKi9cbiAgdXJsKG5ld1VybCkge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG5ld1VybCkge1xuICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgbmV3VXJsKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLnVybCA9IG5ld1VybDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb25maWcudXJsO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIC8gc2V0cyB0aGUgaW5zdGFudGlhdG9yIGZ1bmN0aW9uIHRvIHVzZSB3aGVuIGNyZWF0aW5nIGEgbmV3IG1vZGVsLiBcbiAgICogQHBhcmFtIHsoZnVuY3Rpb258Y2xhc3MpPX0gaW5zdGFudGlhdG9yIC0gdGhlIGZ1bmN0aW9uIG9yIGNsYXNzIHRvIHVzZSBmb3IgaW5zdGFudGlhdGlvblxuICAgKiBAcmV0dXJucyB7KHRoaXN8ZnVuY3Rpb24pfSBUaGlzIGluc3RhbmNlIG9yIHRoZSBjdXJyZW50IGluc2FudGlhdGlvbiBmdW5jdGlvbiBcbiAgICovXG4gIG1vZGVsKG5ld0ZuKSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbmV3Rm4pIHtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgbmV3Rm4pIHtcbiAgICAgICAgdGhpcy5jb25maWcuaW5zdGFudGlhdG9yID0gbmV3Rm47XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmluc3RhbnRpYXRvcjtcbiAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gRW5kcG9pbnRDb25maWc7IiwiY29uc3QgVVJMQnVpbGRlciA9IHJlcXVpcmUoJy4vdXJsLWJ1aWxkZXIuY2xhc3MnKTtcbmNvbnN0IFJlcXVlc3QgPSByZXF1aXJlKCcuL3JlcXVlc3QuY2xhc3MnKTtcbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi91dGlscy5jbGFzcycpLmNsb25lO1xuY29uc3Qgbm9vcCA9IHJlcXVpcmUoJy4vdXRpbHMuY2xhc3MnKS5ub29wO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gZW5kcG9pbnQgaW5zdGFuY2VcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBFbmRwb2ludCB7XG4gIGNvbnN0cnVjdG9yKGVuZHBvaW50Q29uZmlnID0ge30pIHtcbiAgICBpZiAoIWVuZHBvaW50Q29uZmlnIHx8ICdmdW5jdGlvbicgIT09IHR5cGVvZiBlbmRwb2ludENvbmZpZy5tb2RlbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGVuZHBvaW50IGNvbmZpZ3VyYXRpb24uJyk7XG4gICAgfVxuICAgIHRoaXMuZW5kcG9pbnRDb25maWcgPSBjbG9uZShlbmRwb2ludENvbmZpZyk7XG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICBhbGxvd0Zyb21DYWNoZSA6IHRydWUsXG4gICAgICBtZXRob2QgOiAnZ2V0JyxcbiAgICAgIHRhcmdldCA6ICcnLFxuICAgICAgcXVlcnkgOiB7fVxuICAgIH07XG4gICAgdGhpcy5jYWNoZSA9IHRoaXMuZW5kcG9pbnRDb25maWcuYXBpKCkuY2FjaGU7XG4gIH1cbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlcyBhIG5ldyBtb2RlbCBpbnN0YW5jZSBhbmQgcmV0dXJucyBpdFxuICAgKiBAcGFyYW0ge29iamVjdD19IGRhdGEgLSBJbml0aWFsaXphdGlvbiBkYXRhIGZvciB0aGUgbmV3IG1vZGVsIGluc3RhbmNlXG4gICAqIEByZXR1cm5zIHtAbGluayBNb2RlbH0gTmV3IGluc3RhbmNlIG9mIE1vZGVsXG4gICAqL1xuICBjcmVhdGVOZXcoZGF0YSA9IHt9KSB7XG4gICAgbGV0IHJvb3QgPSBuZXcgVVJMQnVpbGRlcihbXG4gICAgICB0aGlzLmVuZHBvaW50Q29uZmlnLmJhc2VVcmwoKSxcbiAgICAgIHRoaXMuZW5kcG9pbnRDb25maWcudXJsKClcbiAgICBdKTtcbiAgICBkYXRhWydAcm9vdCddID0gcm9vdDtcbiAgICBsZXQgaW5zdGFudGlhdG9yID0gdGhpcy5lbmRwb2ludENvbmZpZy5tb2RlbCgpO1xuICAgIGxldCBpbnN0YW5jZSA9IG5ldyBpbnN0YW50aWF0b3IoZGF0YSk7XG4gICAgaW5zdGFuY2UuY29uZmlnKHRoaXMuZW5kcG9pbnRDb25maWcpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuICAvKipcbiAgICogR2V0cyAvIHNldHMgaW5zdGFudGlhdG9yIHRvIHVzZSB3aGVuIGNyZWF0aW5nIGEgbmV3IG1vZGVsIGluc3RhbmNlLiBJbnN0YW50aWF0b3IgKnNob3VsZCogaW5oZXJpdFxuICAgKiBmcm9tIHtAbGluayBNb2RlbH1cbiAgICogQHBhcmFtIHsoZnVuY3Rpb258Y2xhc3MpPX0gaW5zdGFudGlhdG9yIC0gRnVuY3Rpb24gb3IgY2xhc3MgdG8gdXNlIHdoZW4gaW5zdGFudGlhdGluZyBtb2RlbFxuICAgKiBAcmV0dXJucyB7KHRoaXN8ZnVuY3Rpb24pfSBDdXJyZW50IGluc3RhbnRpYXRvciBmdW5jdGlvbiBvciB0aGlzIGluc3RhbmNlXG4gICAqL1xuICBtb2RlbChpbnN0YW50aWF0b3IpIHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBpbnN0YW50aWF0b3IpIHtcbiAgICAgIHRoaXMuZW5kcG9pbnRDb25maWcubW9kZWwoaW5zdGFudGlhdG9yKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lbmRwb2ludENvbmZpZy5tb2RlbCgpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIC8gc2V0cyB0aGUgZW5kcG9pbnQncyByZWxhdGl2ZSB1cmxcbiAgICogQHBhcmFtIHtzdHJpbmc9fSB1cmwgLSBUaGUgbmV3IHVybCB2YWx1ZVxuICAgKiBAcmV0dXJucyB7KHRoaXN8c3RyaW5nKX0gVGhpcyBpbnN0YW5jZSBvciB0aGUgY3VycmVudCB1cmxcbiAgICovXG4gIHVybChuZXdVcmwpIHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBuZXdVcmwpIHtcbiAgICAgIHRoaXMuZW5kcG9pbnRDb25maWcudXJsKG5ld1VybCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZW5kcG9pbnRDb25maWcudXJsKCk7XG4gIH1cbiAgLyoqXG4gICAqIEJ1aWxkcyBhIHF1ZXJ5IHRvIGZpbmQgYW4gb2JqZWN0IHdpdGggdGhlIHNwZWNpZmllZCBpZGVudGlmaWVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIHRoZSB1bmlxdWUgbW9kZWwgaWRlbnRpZmllclxuICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICovXG4gIGZpbmRCeUlkKGlkKSB7XG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtb2RlbCBpZGVudGlmaWVyJyk7XG4gICAgfVxuICAgIHRoaXMuY29uZmlnLnRhcmdldCA9IG5ldyBVUkxCdWlsZGVyKFtcbiAgICAgIHRoaXMuZW5kcG9pbnRDb25maWcuYmFzZVVybCgpLFxuICAgICAgdGhpcy5lbmRwb2ludENvbmZpZy51cmwoKSxcbiAgICAgIGlkXG4gICAgXSk7XG4gICAgdGhpcy5jb25maWcubWV0aG9kID0gJ2dldCc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBxdWVyeSB0byBmaW5kIG9iamVjdHMgdGhhdCBtYXRjaCB0aGUgb3B0aW9uYWwgcXVlcnlcbiAgICogQHBhcmFtIHtvYmplY3Q9fSBxdWVyeVxuICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICovXG4gIGZpbmQocXVlcnkpIHtcbiAgICB0aGlzLmNvbmZpZy50YXJnZXQgPSBuZXcgVVJMQnVpbGRlcihbXG4gICAgICB0aGlzLmVuZHBvaW50Q29uZmlnLmJhc2VVcmwoKSxcbiAgICAgIHRoaXMuZW5kcG9pbnRDb25maWcudXJsKClcbiAgICBdKTtcbiAgICB0aGlzLmNvbmZpZy5tZXRob2QgPSAnZ2V0JztcbiAgICB0aGlzLmNvbmZpZy5xdWVyeS5zZWFyY2ggPSBKU09OLnN0cmluZ2lmeShxdWVyeSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICAqIEF0IHRoZSBtb21lbnQsIHRoaXMgYmVoYXZlcyBleGFjdGx5IHRoZSBzYW1lIGFzIC5maW5kLCBidXQgdXNlcyB0aGVcbiAgICAqIFNFQVJDSCB2ZXJiIGluc3RlYWRcbiAgICAqIEBwYXJhbSB7b2JqZWN0fSBxdWVyeVxuICAgICogQHJldHVybnMge3RoaXN9XG4gICAgKi9cbiAgc2VhcmNoKHF1ZXJ5KSB7XG4gICAgdGhpcy5jb25maWcudGFyZ2V0ID0gbmV3IFVSTEJ1aWxkZXIoW1xuICAgICAgdGhpcy5lbmRwb2ludENvbmZpZy5iYXNlVXJsKCksXG4gICAgICB0aGlzLmVuZHBvaW50Q29uZmlnLnVybCgpXG4gICAgXSk7XG4gICAgdGhpcy5jb25maWcubWV0aG9kID0gJ3NlYXJjaCc7XG4gICAgdGhpcy5jb25maWcucXVlcnkuc2VhcmNoID0gSlNPTi5zdHJpbmdpZnkocXVlcnkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBxdWVyeSB0byBmaW5kIGEgdW5pcXVlIG1vZGVsIHdpdGggdGhlIHNwZWNpZmllZCBpZFxuICAgKiBhbmQgcmVwbGFjZXMgaXQncyBkYXRhIHdpdGggdGhlIHNwZWNpZmllZCBib2R5IG9iamVjdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSB0aGUgdW5pcXVlIG1vZGVsIGlkZW50aWZpZXJcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHJldHVybnMge3RoaXN9XG4gICAqL1xuICBmaW5kQnlJZEFuZFVwZGF0ZShpZCwgYm9keSkge1xuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbW9kZWwgaWRlbnRpZmllcicpO1xuICAgIH1cbiAgICBpZiAoJ29iamVjdCcgIT09IHR5cGVvZiBib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYm9keSBvYmplY3QnKTtcbiAgICB9XG4gICAgdGhpcy5jb25maWcudGFyZ2V0ID0gbmV3IFVSTEJ1aWxkZXIoW1xuICAgICAgdGhpcy5lbmRwb2ludENvbmZpZy5iYXNlVXJsKCksXG4gICAgICB0aGlzLmVuZHBvaW50Q29uZmlnLnVybCgpLFxuICAgICAgaWRcbiAgICBdKTtcbiAgICB0aGlzLmNvbmZpZy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmNvbmZpZy5tZXRob2QgPSAncHV0JztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcXVlcnkgdGhhdCBmaW5kcyBhIG1vZGVsIHdpdGggdGhlIHNwZWNpZmllZCBpZCBhbmRcbiAgICogcmVtb3ZlcyBpdCBmcm9tIHRoZSBkYXRhYmFzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSB0aGUgdW5pcXVlIG1vZGVsIGlkZW50aWZpZXJcbiAgICogQHJldHVybnMge3RoaXN9XG4gICAqL1xuICBmaW5kQnlJZEFuZFJlbW92ZShpZCkge1xuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbW9kZWwgaWRlbnRpZmllcicpO1xuICAgIH1cbiAgICB0aGlzLmNvbmZpZy50YXJnZXQgPSBuZXcgVVJMQnVpbGRlcihbXG4gICAgICB0aGlzLmVuZHBvaW50Q29uZmlnLmJhc2VVcmwoKSxcbiAgICAgIHRoaXMuZW5kcG9pbnRDb25maWcudXJsKCksXG4gICAgICBpZFxuICAgIF0pO1xuICAgIHRoaXMuY29uZmlnLm1ldGhvZCA9ICdkZWxldGUnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgdGhlIHF1ZXJ5IHJlcXVlc3Qgc2hvdWxkIGFsbG93IG9iamVjdHMgZnJvbSB0aGUgY2FjaGVcbiAgICogb3IgcmVxdWlyZSBvYmplY3RzIGJlIGZyZXNoIGZyb20gdGhlIGFwaVxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBhbGxvdyAtIFNwZWNpZnkgaWYgdXNpbmcgdGhlIGNhY2hlIGlzIGFsbG93ZWRcbiAgICogQHJldHVybnMgeyh0aGlzIHwgYm9vbGVhbil9IFRoaXMgaW5zdGFuY2Ugb3IgdGhlIGN1cnJlbnQgYWxsb3cgdmFsdWVcbiAgICovXG4gIGFsbG93RnJvbUNhY2hlKGFsbG93KSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgYWxsb3cpIHtcbiAgICAgIGlmICgnYm9vbGVhbicgPT09IHR5cGVvZiBhbGxvdykge1xuICAgICAgICB0aGlzLmNvbmZpZy5hbGxvd0Zyb21DYWNoZSA9IGFsbG93O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbmZpZy5hbGxvd0Zyb21DYWNoZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW5zIHRoZSBxdWVyeSB0aGF0IGhhcyBiZWVuIGNyZWF0ZWQgdXNpbmcgdGhlIGZpbmQvZmluZEJ5Li4gY2FsbHNcbiAgICogQHBhcmFtIHtmdW5jdGlvbj19IGNiIC0gRnVuY3Rpb24gdG8gY2FsbCBvbiBjb21wbGV0aW9uIChzdWNjZXNzIG9yIGZhaWx1cmUpXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgZXhlYyhjYiA9IG5vb3ApIHtcbiAgICBsZXQgYWxsb3dGcm9tQ2FjaGUgPSB0aGlzLmFsbG93RnJvbUNhY2hlKCk7XG4gICAgbGV0IG1vZGVsQ29uc3RydWN0b3IgPSB0aGlzLmVuZHBvaW50Q29uZmlnLm1vZGVsKCk7XG4gICAgbGV0IGVuZHBvaW50Q29uZmlnID0gdGhpcy5lbmRwb2ludENvbmZpZztcblxuICAgIGxldCBoZWFkZXJzID0ge307XG4gICAgdHJ5IHtcbiAgICAgIGhlYWRlcnMgPSB0aGlzLmVuZHBvaW50Q29uZmlnLmFwaSgpLmNvbW1vbkhlYWRlcnMoKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ1VuYWJsZSB0byBnZXQgY29tbW9uIGhlYWRlcnMuIFNvbWV0aGluZyB3ZW50XFwndCB3cm9uZyAodW5sZXNzIHlvdSBhcmUgdW5pdCB0ZXN0aW5nKS4gJyk7XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24oaGVhZGVycywgdGhpcy5jb25maWcuaGVhZGVycyk7XG5cbiAgICBsZXQgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KClcbiAgICAgIC5tZXRob2QodGhpcy5jb25maWcubWV0aG9kKVxuICAgICAgLmJvZHkodGhpcy5jb25maWcuYm9keSB8fCB7fSlcbiAgICAgIC5xdWVyeSh0aGlzLmNvbmZpZy5xdWVyeSB8fCB7fSlcbiAgICAgIC5oZWFkZXJzKGhlYWRlcnMgfHwge30pXG4gICAgICAudXJsKHRoaXMuY29uZmlnLnRhcmdldC50b1N0cmluZygpKTtcblxuICAgIGxldCBQcm9taXNlID0gcmVxdWlyZSgnLi9zZXR0aW5ncycpLmdldFByb21pc2UoKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAodGhpcy5oYXNDYWNoZSgpKSB7XG4gICAgICAgIGxldCBjYWNoZWRPYmplY3QgPSBjYWNoZS5nZXQocmVxdWVzdC51cmwoKSk7XG4gICAgICAgIGlmIChjYWNoZWRPYmplY3QgJiYgYWxsb3dGcm9tQ2FjaGUpIHtcbiAgICAgICAgICBjYihudWxsLCBjYWNoZWRPYmplY3QpO1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKGNhY2hlZE9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vZG8gYWN0dWFsICdnZXQnXG4gICAgICByZXF1ZXN0LmV4ZWMoKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgbGV0IGRhdGEgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICBsZXQgbW9kZWw7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICBtb2RlbCA9IGRhdGEubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBsZXQgZW50cnkgPSBuZXcgbW9kZWxDb25zdHJ1Y3RvcihpdGVtKTtcbiAgICAgICAgICAgIGVudHJ5LmNvbmZpZyhlbmRwb2ludENvbmZpZyk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZW50cnksICdfX3JlcXVlc3QnLCB7IHZhbHVlIDogY2xvbmUocmVxdWVzdCksIGVudW1lcmFibGUgOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb2RlbCA9IG5ldyBtb2RlbENvbnN0cnVjdG9yKGRhdGEpO1xuICAgICAgICAgIG1vZGVsLmNvbmZpZyhlbmRwb2ludENvbmZpZyk7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZGVsLCAnX19yZXF1ZXN0JywgeyB2YWx1ZSA6IGNsb25lKHJlcXVlc3QpLCBlbnVtZXJhYmxlIDogZmFsc2UgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5oYXNDYWNoZSgpKSB7XG4gICAgICAgICAgY2FjaGUucHV0KHJlcXVlc3QudXJsKCksIG1vZGVsKTtcbiAgICAgICAgfVxuICAgICAgICBjYihudWxsLCBtb2RlbCk7XG4gICAgICAgIHJldHVybiByZXNvbHZlKG1vZGVsKTtcbiAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGlmICh0aGlzLmhhc0NhY2hlKCkpIHtcbiAgICAgICAgICBjYWNoZS5pbnZhbGlkYXRlKHJlcXVlc3QudXJsKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNiKGVycik7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBRdWVyeSBoZWxwZXIgdG8gc2tpcCByZWNvcmRzIHJldHVybmVkIGZyb20gdGhlIGFwaSAoaWYgc3VwcG9ydGVkKS4gQ29tYmluZWRcbiAgICogd2l0aCB0aGUgLmxpbWl0IG1ldGhvZCwgdGhpcyBmdW5jdGlvbiBpcyBncmVhdCBmb3IgcGFnaW5hdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gc2tpcEFtb3VudFxuICAgKiBAcmV0dXJucyB0aGlzXG4gICAqL1xuICBza2lwKHNraXBBbW91bnQgPSAwKSB7XG4gICAgaWYgKCdudW1iZXInID09PSB0eXBlb2Ygc2tpcEFtb3VudCkge1xuICAgICAgdGhpcy5jb25maWcucXVlcnkuc2tpcCA9IHNraXBBbW91bnQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gLyoqXG4gICogUXVlcnkgaGVscGVyIHRvIGxpbWl0IHRoZSBudW1iZXIgb2YgcmVzdWx0cyByZXR1cm5lZCAocHJvdmlkZWQgdGhlIGFwaVxuICAqIHN1cHBvcnRzIGl0KVxuICAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdEFtb3VudFxuICAqIEByZXR1cm5zIHRoaXNcbiAgKi9cbiAgbGltaXQobGltaXRBbW91bnQgPSAwKSB7XG4gICAgaWYgKCdudW1iZXInID09PSB0eXBlb2YgbGltaXRBbW91bnQpIHtcbiAgICAgIHRoaXMuY29uZmlnLnF1ZXJ5LmxpbWl0ID0gbGltaXRBbW91bnQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGEgbGlzdCBvZiBmaWVsZHMgdG8gcmV0dXJuIGZyb20gdGhlIGFwaSAoaWYgc3VwcG9ydGVkKS5cbiAgICogQHBhcmFtIHsoc3RyaW5nfHN0cmluZ1tdKX0gZmllbGRzIC0gYSBsaXN0IG9mIGZpZWxkcyB0byByZXR1cm4gZnJvbSB0aGUgYXBpXG4gICAqIEByZXR1cm5zIHRoaXNcbiAgICovXG4gIHNlbGVjdChmaWVsZHMgPSAnJykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZpZWxkcykpIHtcbiAgICAgIGZpZWxkcyA9IGZpZWxkcy5qb2luKCcgJyk7XG4gICAgfVxuICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIGZpZWxkcykge1xuICAgICAgdGhpcy5jb25maWcucXVlcnkuZmllbGRzID0gZmllbGRzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgdG8gc2VlIGlmIHRoZSBjYWNoZSBvYmplY3QgaGFzIGJlZW4gc2V0IGFuZCBpcyB2YWxpZFxuICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBoYXNDYWNoZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jYWNoZSAmJiAnZnVuY3Rpb24nID09PSB0eXBlb2YgdGhpcy5jYWNoZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVuZHBvaW50O1xuIiwiLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgSFRUUE1vY2sge1xuXHRjb25zdHJ1Y3Rvcih2ZXJib3NlID0gZmFsc2UpIHtcblx0XHR0aGlzLmxpc3RlbmVycyA9IHt9O1xuXHRcdHRoaXMudmVyYm9zZSA9IHZlcmJvc2U7XG5cdH1cblx0LyoqXG5cdCAqIE1vY2sgcmVwcmVzZW50YXRpb24gb2YgdGhlIFhNTEh0dHBSZXF1ZXN0IG9wZW4gbWV0aG9kXG5cdCAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9YTUxIdHRwUmVxdWVzdC9vcGVufVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kIFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFxuXHQgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuXHQgKi9cblx0b3BlbihtZXRob2QsIHVybCkge1xuXHRcdHRoaXMubG9nKGBPcGVuaW5nICR7dXJsfSB1c2luZyAke21ldGhvZH1gKTtcblx0fVxuXHQvKipcblx0ICogTW9jayByZXByZXNlbnRhdGlvbiBvZiB0aGUgWE1MSHR0cFJlcXVlc3Qgc2VuZCBtZXRob2Rcblx0ICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1hNTEh0dHBSZXF1ZXN0L3NlbmR9XG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBib2R5IFxuXHQgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuXHQgKi9cblx0c2VuZChib2R5KSB7XG5cdFx0dGhpcy5sb2coYFNlbmRpbmcgd2l0aCAke2JvZHl9YCk7XG5cdFx0aWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiB0aGlzLmxpc3RlbmVycy5sb2FkKSB7XG5cdFx0XHRsZXQgbW9ja1Jlc3BvbnNlID0ge1xuXHRcdFx0XHRyZXNwb25zZSA6IHsnbW9ja19yZXNwb25zZScgOiB0cnVlLCAnZGF0YScgOiBbJ29iajEnXX0sXG5cdFx0XHRcdHJlc3BvbnNlVGV4dCA6IFwieydtb2NrX3Jlc3BvbnNlJyA6IHRydWV9XCIsXG5cdFx0XHRcdHN0YXR1cyA6IDIwMCxcblx0XHRcdFx0c3RhdHVzVGV4dCA6ICcyMDAnLFxuXHRcdFx0XHRyZXNwb25zZVVSTCA6ICcvbW9jay1jYWxsJ1xuXHRcdFx0fTtcblx0XHRcdE9iamVjdC5hc3NpZ24odGhpcywgbW9ja1Jlc3BvbnNlKTtcblx0XHRcdHRoaXMubGlzdGVuZXJzLmxvYWQoKTtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCAqIE1vY2sgcmVwcmVzZW50YXRpb24gb2YgdGhlIFhNTEh0dHBSZXF1ZXN0IGdldEFsbFJlc3BvbnNlSGVhZGVycyBtZXRob2Rcblx0ICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1hNTEh0dHBSZXF1ZXN0L2dldEFsbFJlc3BvbnNlSGVhZGVyc31cblx0ICogQHJldHVybnMge3N0cmluZ30gVGhlIG1vY2sgaGVhZGVyc1xuXHQgKi9cblx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkge1xuXHRcdHJldHVybiBcIk1vY2stSGVhZGVyczogdHJ1ZVwiO1xuXHR9XG5cdC8qKlxuXHQgKiBSZXByZXNlbnRhdGlvbiBvZiBKYXZhc2NyaXB0J3MgYWRkRXZlbnRMaXN0ZW5lciBkZXNpZ25lZCB0byBob29rIGludG8gdGhpc1xuXHQgKiBtb2NrIFhNTEh0dHBSZXF1ZXN0IG9iamVjdFxuXHQgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lcn1cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIGZvclxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBldmVudCBpcyB0cmlnZ2VyZWRcblx0ICovXG5cdGFkZEV2ZW50TGlzdGVuZXIobmFtZSwgY2FsbGJhY2spIHtcblx0XHR0aGlzLmxvZyhgJHtuYW1lfSBsaXN0ZW5lciByZWdpc3RlcmVkYCk7XG5cdFx0dGhpcy5saXN0ZW5lcnNbbmFtZV0gPSBjYWxsYmFjaztcblx0fVxuXHQvKipcblx0ICogSnVzdCBhIHN0dWIgc28gd2UgaGF2ZSBhIHVuaWZvcm0gaW50ZXJmYWNlIGJldHdlZW4gdGhpcyBhbmQgdGhlIHJlYWwgdGhpbmdcblx0ICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L3NldFJlcXVlc3RIZWFkZXJ9XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBoZWFkZXIgXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBcblx0ICovXG5cdHNldFJlcXVlc3RIZWFkZXIoaGVhZGVyLCB2YWx1ZSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdC8qKlxuXHQgKiBIZWxwZXIgZnVuY3Rpb24gZm9yIGxvZ2dpbmcgc3RhdHVzIG91dHB1dCBiYXNlZCBvbiB0aGlzIG9iamVjdCdzIFxuXHQgKiB2ZXJib3NpdHkgc2V0dGluZ3MgKHRydWUvZmFsc2UpXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFxuXHQgKi9cblx0bG9nKG1lc3NhZ2UpIHtcblx0XHRpZiAodGhpcy52ZXJib3NlID09PSB0cnVlKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhtZXNzYWdlKTtcblx0XHR9XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIVFRQTW9jaztcbiIsImNvbnN0IGpzb25wYXRjaCA9IHJlcXVpcmUoJ2Zhc3QtanNvbi1wYXRjaCcpO1xuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuL3V0aWxzLmNsYXNzJykuY2xvbmU7XG5jb25zdCBub29wID0gcmVxdWlyZSgnLi91dGlscy5jbGFzcycpLm5vb3A7XG5jb25zdCBSZXF1ZXN0ID0gcmVxdWlyZSgnLi9yZXF1ZXN0LmNsYXNzJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIE1vZGVsIHtcbiAgY29uc3RydWN0b3IoZGF0YSA9IHt9KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdfX2NvbmZpZycsIHtlbnVtZXJhYmxlIDogZmFsc2UsIHdyaXRhYmxlIDogdHJ1ZX0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX19yZXNwb25zZScsIHtlbnVtZXJhYmxlIDogZmFsc2UsIHdyaXRhYmxlIDogdHJ1ZX0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX19vcmlnaW5hbCcsIHt2YWx1ZSA6IGpzb25wYXRjaC5kZWVwQ2xvbmUoZGF0YSksIHdyaXRhYmxlIDogdHJ1ZX0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX19yZXZpc2lvbicsIHt2YWx1ZSA6IERhdGUubm93KCksIHdyaXRhYmxlIDogdHJ1ZX0pO1xuXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjbG9uZShkYXRhKSk7XG4gIH1cbiAgLyoqXG4gICAqIFBlcnNpc3RzIHRoaXMgbW9kZWwgYmFjayB0byB0aGUgYXBpXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb249fSBjYiAtIENhbGxiYWNrIHRvIGludm9rZSBvbiBjb21wbGV0aW9uIChmYWlsdXJlIG9yIHN1Y2Nlc3MpXG4gICAqIEByZXR1cm5zIHtSZXF1ZXN0fVxuICAgKi9cbiAgc2F2ZShjYiA9IG5vb3ApIHtcbiAgICBsZXQgaGVhZGVycyA9IHt9O1xuICAgIHRyeSB7XG4gICAgICBoZWFkZXJzID0gdGhpcy5fX2NvbmZpZy5hcGkoKS5jb21tb25IZWFkZXJzKCk7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICAvL2lnbm9yZVxuICAgIH1cblxuICAgIGxldCBtZXRob2QgPSB0aGlzLmlkID8gJ3B1dCcgOiAncG9zdCc7XG4gICAgbGV0IGluc3RhbmNlID0gdGhpcztcblxuICAgIGxldCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoKVxuICAgICAgLnVybCh0aGlzLm1ha2VIcmVmKCkpXG4gICAgICAubWV0aG9kKG1ldGhvZClcbiAgICAgIC5oZWFkZXJzKGhlYWRlcnMpXG4gICAgICAuYm9keSh0aGlzKVxuICAgICAgLmV4ZWMoKVxuICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oaW5zdGFuY2UsIGNsb25lKHJlc3BvbnNlLmRhdGEpKTtcbiAgICAgICAgaW5zdGFuY2UuX19yZXZpc2lvbiA9IERhdGUubm93KCk7XG4gICAgICAgIGluc3RhbmNlLl9fcmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgaW5zdGFuY2UubWFrZUNsZWFuKCk7XG4gICAgICAgIGNiKCk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGNiKGVycik7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIGxpc3Qgb2YgY2hhbmdlcyB0aGF0IGhhdmUgb2NjdXJlZCBzaW5jZSB0aGUgbGFzdCBnZXQvc2F2ZVxuICAgKiBAcmV0dXJucyB7UmVxdWVzdH1cbiAgICovXG4gIGNoYW5nZXMoKSB7XG4gICAgbGV0IGhlYWRlcnMgPSB0aGlzLl9fY29uZmlnLmFwaSgpLmNvbW1vbkhlYWRlcnMoKTtcbiAgICBsZXQgdGFyZ2V0VXJsID0gdGhpc1snQGNoYW5nZXMnXTtcbiAgICBsZXQgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KClcbiAgICAgIC51cmwodGFyZ2V0VXJsKVxuICAgICAgLnF1ZXJ5KHtzZWFyY2ggOiB7c2luY2UgOiB0aGlzLl9fcmV2aXNpb259fSlcbiAgICAgIC5tZXRob2QoJ2dldCcpXG4gICAgICAuaGVhZGVycyhoZWFkZXJzKVxuICAgICAgLmV4ZWMoKTtcbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydHMgbGlzdGVuaW5nIGZvciBjaGFuZ2VzIGFuZCBjYWxscyBvbkNoYW5nZSB3aGVuZXZlciB0aGV5IGFyZSBkZXRlY3RlZFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbkNoYW5nZSAtIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBjaGFuZ2VzIGRldGVjdGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZWZyZXNoUmF0ZSAtIHRoZSBkdXJhdGlvbiAoaW4gbWlsbGlzZWNvbmRzKSBiZXR3ZWVuIGNoZWNrc1xuICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICovXG4gIHN1YnNjcmliZShvbkNoYW5nZSwgdHRsID0gMzAwMCkge1xuICAgIHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRoaXMuY2hhbmdlcygpLnRoZW4oY2hhbmdlTGlzdCA9PiB7XG4gICAgICAgIGlmIChjaGFuZ2VMaXN0ICYmIGNoYW5nZUxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5fX3JldmlzaW9uID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICBvbkNoYW5nZShjaGFuZ2VMaXN0LCBEYXRlLm5vdygpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSx0dGwpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUHV0cyBvbmx5IHRoZSBjaGFuZ2VzIChpbiBwYXRjaCBub3RhdGlvbikgYmFjayB0byB0aGUgYXBpLiBUaGVcbiAgICogc2VydmVyLXNpZGUgZW5kcG9pbnQgbXVzdCBzdXBwb3J0IFBBVENIXG4gICAqIEByZXR1cm5zIHtSZXF1ZXN0fVxuICAgKi9cbiAgdXBkYXRlKCkge1xuICAgIC8vdXNlIHBhdGNoXG4gICAgbGV0IGhlYWRlcnMgPSB0aGlzLl9fY29uZmlnLmFwaSgpLmNvbW1vbkhlYWRlcnMoKTtcblxuICAgIGxldCBwYXRjaGVzID0gdGhpcy5nZXREaWZmcygpO1xuICAgIGxldCB0YXJnZXRVcmwgPSB0aGlzLm1ha2VIcmVmKCk7XG4gICAgbGV0IGluc3RhbmNlID0gdGhpcztcbiAgICBsZXQgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KClcbiAgICAgIC51cmwodGFyZ2V0VXJsKVxuICAgICAgLm1ldGhvZCgncGF0Y2gnKVxuICAgICAgLmhlYWRlcnMoaGVhZGVycylcbiAgICAgIC5ib2R5KHBhdGNoZXMpXG4gICAgICAuZXhlYygpXG4gICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihpbnN0YW5jZSwgY2xvbmUocmVzcG9uc2UuZGF0YSkpO1xuICAgICAgICBpbnN0YW5jZS5fX3JldmlzaW9uID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaW5zdGFuY2UuX19yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICBpbnN0YW5jZS5tYWtlQ2xlYW4oKTtcbiAgICAgIH0pO1xuICAgIHJldHVybiByZXF1ZXN0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHVuZGVybHlpbmcgQVBJIGNvbmZpZ1xuICAgKiBAcGFyYW0ge0VuZHBvaW50Q29uZmlnfSBlbmRwb2ludENvbmZpZ1xuICAgKi9cbiAgY29uZmlnKGVuZHBvaW50Q29uZmlnID0ge30pIHtcbiAgICB0aGlzLl9fY29uZmlnID0gZW5kcG9pbnRDb25maWc7XG4gIH1cblxuICBtYWtlSHJlZigpIHtcbiAgICBsZXQgY29ycmVjdEhyZWY7XG4gICAgaWYgKCdvYmplY3QnID09PSB0eXBlb2YgdGhpcy5fX2NvbmZpZykge1xuICAgICAgY29ycmVjdEhyZWYgPSB0aGlzLl9fY29uZmlnLmJhc2VVcmwoKSArICcvJyArIHRoaXMuX19jb25maWcudXJsKCkgKyAnLyc7XG4gICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB0aGlzLmlkICkge1xuICAgICAgICBjb3JyZWN0SHJlZiArPSB0aGlzLmlkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3JyZWN0SHJlZiA9ICcvX191bml0X3Rlc3RfXyc7XG4gICAgfVxuICAgIHJldHVybiBjb3JyZWN0SHJlZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBkaWZmcyBjb21wYXJpbmcgdGhpcyB2ZXJzaW9uIHRvIHRoZSBsYXN0XG4gICAqIHN5bmNlZCB2ZXJzaW9uIGZyb20gdGhlIHNlcnZlclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7b2JqZWN0W119IEFycmF5IG9mIGNoYW5nZXNcbiAgICovXG4gIGdldERpZmZzKCkge1xuICAgIHJldHVybiBqc29ucGF0Y2guY29tcGFyZSh0aGlzLl9fb3JpZ2luYWwsIHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGlzIG1vZGVsXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaXNEaXJ0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXREaWZmcygpLmxlbmd0aCA+IDA7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyBvdXQgdGhlIGNoYW5nZSBoaXN0b3J5IGFuZCBzeW5jcyB0aGUgdW5kZXJseWluZyBvcmlnaW5hbCB2ZXJzaW9uXG4gICAqIHRvIHRoZSBjdXJyZW50IHZlcnNpb25cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIG1ha2VDbGVhbigpIHtcbiAgICB0aGlzLl9fb3JpZ2luYWwgPSBqc29ucGF0Y2guZGVlcENsb25lKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhpcyBtb2RhbCBmcm9tIHRoZSBhcGlcbiAgICogQHBhcmFtIHtmdW5jdGlvbj19IGNiIC0gRnVuY3Rpb24gdG8gY2FsbCBvbiBjb21wbGV0ZXRpb24gKHN1Y2Nlc3Mgb3IgZmFpbHVyZSlcbiAgICogQHJldHVybnMge1JlcXVlc3R9XG4gICAqL1xuICByZW1vdmUoY2IgPSBub29wKSB7XG4gICAgbGV0IGhlYWRlcnMgPSB7fTtcbiAgICB0cnkge1xuICAgICAgaGVhZGVycyA9IHRoaXMuX19jb25maWcuYXBpKCkuY29tbW9uSGVhZGVycygpO1xuICAgIH0gY2F0Y2goZSkge31cblxuICAgIGxldCB0YXJnZXRVcmwgPSB0aGlzLm1ha2VIcmVmKCk7XG4gICAgbGV0IGluc3RhbmNlID0gdGhpcztcblxuICAgIGxldCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoKVxuICAgICAgLnVybCh0YXJnZXRVcmwpXG4gICAgICAubWV0aG9kKCdkZWxldGUnKVxuICAgICAgLmhlYWRlcnMoaGVhZGVycylcbiAgICAgIC5leGVjKClcbiAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICBpbnN0YW5jZS5fX3Jlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIHJldHVybiBjYigpO1xuICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfSk7XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZGVsO1xuIiwiY29uc3QgVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQuY2xhc3MuanMnKTtcbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi91dGlscy5jbGFzcycpLmNsb25lO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3Q9fSBjb25maWdcbiAqL1xuY2xhc3MgUmVxdWVzdCB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIHVybDogJy8nLFxuICAgICAgaGVhZGVyczoge30sXG4gICAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgICByZXNwb25zZVR5cGUgOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICBwYXJhbXMgOiB7fVxuICAgIH07XG4gICAgdGhpcy5jb25maWcgPSB7fTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuY29uZmlnLCBkZWZhdWx0cywgY29uZmlnKTtcbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZXMgdGhlIGN1cnJlbnQgcmVxdWVzdCB1c2luZyB0aGUgdW5kZXJseWluZyB0cmFuc3BvcnQgbWVjaGFuaXNtIChpZSBodHRwKVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGV4ZWMoKSB7XG4gICAgbGV0IG9yaWdpbmFsUmVxdWVzdCA9IHRoaXM7XG4gICAgbGV0IFByb21pc2UgPSByZXF1aXJlKCcuL3NldHRpbmdzJykuZ2V0UHJvbWlzZSgpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBvcmlnaW5hbFJlcXVlc3QudHJhbnNwb3J0ID0gbmV3IFRyYW5zcG9ydChvcmlnaW5hbFJlcXVlc3QpO1xuXG4gICAgICBvcmlnaW5hbFJlcXVlc3QudHJhbnNwb3J0XG4gICAgICAuZXhlYygpXG4gICAgICAudGhlbihmdW5jdGlvbiBzdWNjZXNzQ2FsbGJhY2socmVzcG9uc2UpIHtcbiAgICAgICAgcmVzcG9uc2UuZGF0YSA9IGNsb25lKHJlc3BvbnNlLnJlc3BvbnNlKTtcbiAgICAgICAgLy8gb3JpZ2luYWxSZXF1ZXN0LnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIHJlc3BvbnNlLnJlcXVlc3QgPSBvcmlnaW5hbFJlcXVlc3Q7XG4gICAgICAgIHJldHVybiByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgIH0sIGZ1bmN0aW9uIGVycm9yQ2FsbGJhY2socmVzcG9uc2UpIHtcbiAgICAgICAgLy8gb3JpZ2luYWxSZXF1ZXN0LnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIHJlc3BvbnNlLnJlcXVlc3QgPSBvcmlnaW5hbFJlcXVlc3Q7ICAgICAgICBcbiAgICAgICAgcmV0dXJuIHJlamVjdChyZXNwb25zZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0cyAvIHNldHMgdGhlIHF1ZXJ5IG9iamVjdCB0byB1c2VcbiAgICogQHBhcmFtIHtvYmplY3Q9fSBuZXdRdWVyeSBcbiAgICogQHJldHVybnMgeyh0aGlzIHwgb2JqZWN0KX1cbiAgICovXG4gIHF1ZXJ5KG5ld1F1ZXJ5KSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbmV3UXVlcnkpIHtcbiAgICAgIGlmICgnb2JqZWN0JyA9PT0gdHlwZW9mIG5ld1F1ZXJ5ICYmIG5ld1F1ZXJ5ICE9PSBudWxsKSB7XG4gICAgICAgIG5ld1F1ZXJ5ID0gY2xvbmUobmV3UXVlcnkpO1xuICAgICAgfVxuICAgICAgdGhpcy5jb25maWcucGFyYW1zID0gbmV3UXVlcnk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnBhcmFtcztcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBHZXRzIC8gc2V0cyB0aGUgaHR0cCB2ZXJiIChtZXRob2QpIHRvIHVzZSAoaWUgZ2V0LHB1dCxwb3N0LCBldGMpXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbmV3TWV0aG9kIFxuICAgKiBAcmV0dXJucyB7KHRoaXMgfCBzdHJpbmcpfVxuICAgKi9cbiAgbWV0aG9kKG5ld01ldGhvZCkge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG5ld01ldGhvZCkge1xuICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgbmV3TWV0aG9kKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLm1ldGhvZCA9IG5ld01ldGhvZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25maWcubWV0aG9kO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldHMgLyBzZXRzIHRoZSB0YXJnZXQgdXJsIHRvIG1ha2UgdGhlIHJlcXVlc3QgdG9cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBuZXdVcmwgXG4gICAqIEByZXR1cm5zIHsodGhpcyB8IHN0cmluZyl9XG4gICAqL1xuICB1cmwobmV3VXJsKSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbmV3VXJsKSB7XG4gICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBuZXdVcmwpIHtcbiAgICAgICAgdGhpcy5jb25maWcudXJsID0gbmV3VXJsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbmZpZy51cmw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgLyBzZXRzIGhlYWRlcnMgKGtleSAvIHZhbHVlIHBhaXJzICkgdG8gdXNlIGZvciB0aGUgcmVxdWVzdFxuICAgKiBAcGFyYW0ge29iamVjdD19IG5ld0hlYWRlck9iaiBcbiAgICogQHJldHVybnMgeyh0aGlzIHwgb2JqZWN0KX1cbiAgICovXG4gIGhlYWRlcnMobmV3SGVhZGVyT2JqKSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbmV3SGVhZGVyT2JqKSB7XG4gICAgICBpZiAoJ29iamVjdCcgPT09IHR5cGVvZiBuZXdIZWFkZXJPYmogJiYgbmV3SGVhZGVyT2JqICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmhlYWRlcnMgPSBjbG9uZShuZXdIZWFkZXJPYmopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5oZWFkZXJzO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIC8gc2V0cyB0aGUgcmVxdWVzdCBib2R5XG4gICAqIEBwYXJhbSB7b2JqZWN0PX0gbmV3Qm9keSBcbiAgICogQHJldHVybnMgeyh0aGlzIHwgb2JqZWN0IHwgdW5kZWZpbmVkKX1cbiAgICovXG4gIGJvZHkobmV3Qm9keSkge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG5ld0JvZHkpIHtcbiAgICAgIGlmICgnb2JqZWN0JyA9PT0gdHlwZW9mIG5ld0JvZHkgJiYgbmV3Qm9keSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5kYXRhID0gY2xvbmUobmV3Qm9keSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmRhdGE7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXRzIG9yIHNldHMgdGhlIHJlc3BvbnNlIHR5cGUgZm9yIHRoZSByZXF1ZXN0XG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbmV3VHlwZSBcbiAgICogQHJldHVybnMgeyh0aGlzIHwgc3RyaW5nKX1cbiAgICovXG4gIG1lZGlhVHlwZShuZXdUeXBlKSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbmV3VHlwZSkge1xuICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgbmV3VHlwZSkge1xuICAgICAgICB0aGlzLmNvbmZpZy5yZXNwb25zZVR5cGUgPSBuZXdUeXBlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbmZpZy5yZXNwb25zZVR5cGU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyByZXF1ZXN0J3MgY29uZmlndXJhdGlvbnNcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZSggSlNPTi5zdHJpbmdpZnkodGhpcy5jb25maWcpICk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZXF1ZXN0O1xuIiwiLyoqXG4gKiBSZWZlcmVuY2UgcG9pbnQgZm9yIGFsbCBvZiB0aGUgc2RrIG1vZHVsZXMgdG8gZmluZCBjb21tb25cbiAqIHNldHRpbmdzLCBzdWNoIGFzIHdoYXQgcHJvbWlzZSB0byB1c2VcbiAqIEBzaW5nbGV0b25cbiAqIEBuYW1lc3BhY2UgT2ZmaWNlQm90U0RLLlNldHRpbmdzXG4gKi9cbmxldCBzZXR0aW5ncyA9IHtcbiAgX3AgOiBQcm9taXNlLFxuICBzZXRQcm9taXNlTGliIDogZnVuY3Rpb24ocCkge1xuICAgIHRoaXMuX3AgPSBwO1xuICB9LFxuICBnZXRQcm9taXNlIDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3A7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dGluZ3M7IiwiY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuL3V0aWxzLmNsYXNzJykuY2xvbmU7XG5jb25zdCBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIFRyYW5zcG9ydCB7XG5cdGNvbnN0cnVjdG9yKHJlcXVlc3QpIHtcblx0XHRpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiB3aW5kb3cgJiYgd2luZG93LlhNTEh0dHBSZXF1ZXN0KSB7XG5cdFx0XHR0aGlzLkhUVFBSZXF1ZXN0ID0gd2luZG93LlhNTEh0dHBSZXF1ZXN0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLkhUVFBSZXF1ZXN0ID0gcmVxdWlyZSgnLi9odHRwLW1vY2suY2xhc3MuanMnKTsgLy91c2VkIGZvciBOb2RlIGJhc2VkIHRlc3RzXG5cdFx0fVxuXHRcdHRoaXMuc2V0UmVxdWVzdChyZXF1ZXN0KTtcblx0fVxuXHQvKipcblx0ICogU3RvcmVzIHRoZSByZXF1ZXN0IG9iamVjdCBmb3IgdXNlIGxhdGVyIChpZSB3aGVuIC5leGVjKCkgZ2V0cyBjYWxsZWQpLiBIZWxwZnVsbCBcblx0ICogaWYgYnVpbGRpbmcgdGhlIHRyYW5zcG9ydCByZXF1ZXN0IHVwIGluc3RlYWQgb2YgcGFzc2luZyBldmVyeXRoaW5nIGludG8gY29uc3RydWN0b3IuXG5cdCAqIEBwYXJhbSB7UmVxdWVzdH0gcmVxdWVzdCBcblx0ICogQHJldHVybnMge3RoaXN9XG5cdCAqL1xuXHRzZXRSZXF1ZXN0KHJlcXVlc3QpIHtcblx0XHR0aGlzLnJlcXVlc3QgPSBjbG9uZShyZXF1ZXN0KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0ICogTWFrZXMgdGhlIGFjdHVhbCBhcGkgY2FsbCB1c2luZyB0aGUgUmVxdWVzdCBvYmplY3QgdGhhdCB3YXMgcGFzc2VkIGludG8gdGhlIGNvbnN0cnVjdG9yIFxuXHQgKiBvciBhZGRlZCB1c2luZyB0aGUgc2V0UmVxdWVzdCBtZXRob2QuXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlfVxuXHQgKi9cblx0ZXhlYygpIHtcblx0XHRsZXQgUHJvbWlzZSA9IHJlcXVpcmUoJy4vc2V0dGluZ3MnKS5nZXRQcm9taXNlKCk7XHRcdFxuXHRcdGxldCBpbnN0YW5jZSA9IHRoaXM7XG5cdFx0XG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRcdFxuXHRcdFx0bGV0IGh0dHBJbnN0YW5jZSA9IG5ldyBpbnN0YW5jZS5IVFRQUmVxdWVzdCgpO1xuXHRcdFx0bGV0IHVybCA9IGluc3RhbmNlLnJlcXVlc3QudXJsKCkgO1xuXG5cdFx0XHRsZXQgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkoaW5zdGFuY2UucmVxdWVzdC5xdWVyeSgpKTtcblx0XHRcdGlmIChxdWVyeSAmJiBxdWVyeS5sZW5ndGgpIHtcblx0XHRcdFx0dXJsID0gdXJsICsgJz8nICsgcXVlcnk7XG5cdFx0XHR9XG5cdFx0XHRsZXQgYm9keSA9IGluc3RhbmNlLnJlcXVlc3QuYm9keSgpO1xuXHRcdFx0aWYgKCdvYmplY3QnID09PSB0eXBlb2YgYm9keSkge1xuXHRcdFx0XHRib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGh0dHBJbnN0YW5jZS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCB0cmFuc2ZlckNvbXBsZXRlKTtcblx0XHRcdGh0dHBJbnN0YW5jZS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgdHJhbnNmZXJGYWlsZWQpO1xuXHRcdFx0aHR0cEluc3RhbmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCB0cmFuc2ZlckFib3J0ZWQpO1xuXHRcdFx0aHR0cEluc3RhbmNlLm9wZW4oIGluc3RhbmNlLnJlcXVlc3QubWV0aG9kKCkudG9VcHBlckNhc2UoKSwgdXJsICk7XG5cdFx0XHRodHRwSW5zdGFuY2UucmVzcG9uc2VUeXBlID0gJ2pzb24nO1xuXHRcdFx0XG5cdFx0XHRsZXQgaGVhZGVycyA9IGluc3RhbmNlLnJlcXVlc3QuaGVhZGVycygpO1xuXHRcdFx0aHR0cEluc3RhbmNlLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgaW5zdGFuY2UucmVxdWVzdC5tZWRpYVR5cGUoKSk7XHRcblx0XHRcdFxuXHRcdFx0Zm9yICggbGV0IGhlYWRlck5hbWUgaW4gaGVhZGVycyApIHtcblx0XHRcdFx0aHR0cEluc3RhbmNlLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyTmFtZSwgaGVhZGVyc1toZWFkZXJOYW1lXSk7XG5cdFx0XHR9XG5cdFx0XHRodHRwSW5zdGFuY2Uuc2VuZCggYm9keSApO1xuXG5cdFx0XHQvKipcblx0XHRcdFx0KiBIYW5kbGVyOkFib3J0ZWRcblx0XHRcdFx0Ki9cblx0XHRcdGZ1bmN0aW9uIHRyYW5zZmVyQWJvcnRlZCgpIHtcblx0XHRcdFx0bGV0IGZhaWxlZCA9IG5ldyBFcnJvcignVHJhbnNmZXIgY2FuY2VsbGVkLicpO1xuXHRcdFx0XHRyZWplY3QoZmFpbGVkKTtcblx0XHRcdH1cblx0XHRcdC8qKlxuXHRcdFx0XHQqIEhhbmRsZXI6RmFpbGVkXG5cdFx0XHRcdCovXG5cdFx0XHRmdW5jdGlvbiB0cmFuc2ZlckZhaWxlZChlKSB7XG5cdFx0XHRcdHJlamVjdChodHRwSW5zdGFuY2UpO1xuXHRcdFx0fVxuXHRcdFx0LyoqXG5cdFx0XHRcdCogSGFuZGxlcjpGaW5pc2hlZFxuXHRcdFx0XHQqL1xuXHRcdFx0ZnVuY3Rpb24gdHJhbnNmZXJDb21wbGV0ZSgpIHtcdFxuXHRcdFx0XHRpZiAoaHR0cEluc3RhbmNlLnN0YXR1cyA8IDQwMCkge1xuXHRcdFx0XHRcdHJlc29sdmUoaHR0cEluc3RhbmNlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZWplY3QoaHR0cEluc3RhbmNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNwb3J0O1xuIiwiLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nW119IGFyZ3MgXG4gKi9cbmNsYXNzIFVSTEJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcihhcmdzID0gW10pIHtcbiAgICBpZiAoIWFyZ3MgfHwgJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGFyZ3Muam9pbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVUkwgQnVpbGRlciByZXF1aXJlcyBwYXJhbSAxIHRvIGJlIGFuIGFycmF5LicpO1xuICAgIH1cbiAgICB0aGlzLnRhcmdldCA9IGFyZ3MuZmlsdGVyKGl0ZW0gPT4ge1xuICAgICAgcmV0dXJuIGl0ZW0gIT09ICcvJztcbiAgICB9KS5qb2luKCcvJykgfHwgXCIvXCI7XG4gIH1cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHVybFxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFyZ2V0IHx8ICcnO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVVJMQnVpbGRlcjsiLCJ2YXIgY2xvbmVfbGliID0gcmVxdWlyZSgnY2xvbmUnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgVXRpbHMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvZXMgbm90aGluZ1xuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICovXG4gICAgc3RhdGljIG5vb3AoKSB7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZGVlcCBjb3B5IG9mIHRoZSBwYXNzZWQgaW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9iaiAtIE9iamVjdCB0byBjb3B5XG4gICAgICogQHJldHVybnMge29iamVjdH0gQ29waWVkIG9iamVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBjbG9uZShvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgLy8gcmV0dXJuIGNsb25lX2xpYihvYmopO1xuICAgICAgICAvLyByZXR1cm4gcHJpdmF0ZUNsb25lKG9iaik7XG4gICAgfVxufVxuLyoqXG4gKiBBbGxvd3Mgb3VyIHN0YXRpYyBtZXRob2QgdG8gY2FsbCB0aGlzIHJlY3Vyc2l2ZWx5XG4gKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybnMge29iamVjdH0gQ29waWVkIG9iamVjdCBcbiAqL1xuZnVuY3Rpb24gcHJpdmF0ZUNsb25lKG9iaikge1xuICAgaWYob2JqID09PSBudWxsIHx8IHR5cGVvZihvYmopICE9ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgfVxuICAgdmFyIHRlbXAgPSBuZXcgb2JqLmNvbnN0cnVjdG9yKCk7XG4gICBmb3IodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIHRlbXBba2V5XSA9IHByaXZhdGVDbG9uZShvYmpba2V5XSk7XG4gICB9XG4gICByZXR1cm4gdGVtcDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBVdGlsczsiXX0="}