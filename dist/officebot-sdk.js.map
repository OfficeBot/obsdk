{"version":3,"sources":["dist/node_modules/browser-pack/_prelude.js","dist/index.js","dist/node_modules/base64-js/index.js","dist/node_modules/buffer/index.js","dist/node_modules/clone/clone.js","dist/node_modules/deep-equal/index.js","dist/node_modules/deep-equal/lib/is_arguments.js","dist/node_modules/deep-equal/lib/keys.js","dist/node_modules/fast-json-patch/lib/core.js","dist/node_modules/fast-json-patch/lib/duplex.js","dist/node_modules/fast-json-patch/lib/helpers.js","dist/node_modules/ieee754/index.js","dist/node_modules/querystring-es3/decode.js","dist/node_modules/querystring-es3/encode.js","dist/node_modules/querystring-es3/index.js","dist/src/api-config.class.js","dist/src/cache.class.js","dist/src/endpoint-config.class.js","dist/src/endpoint.class.js","dist/src/http-mock.class.js","dist/src/model.class.js","dist/src/request.class.js","dist/src/settings.js","dist/src/transport.class.js","dist/src/url-builder.class.js","dist/src/utils.class.js"],"names":[],"mappings":"AAAA;;;ACAA;;;;AAIA,IAAI,MAAO,UAAS,OAAT,EAAkB;;AAE3B,MAAI,WAAW,QAAQ,mBAAR,CAAf;AACA,WAAS,aAAT,CAAuB,OAAvB;;AAEA,MAAI,UAAU;AACZ,SAAkB,QAAQ,wBAAR,CADN;AAEZ,WAAkB,QAAQ,mBAAR,CAFN;AAGZ,oBAAkB,QAAQ,6BAAR,CAHN;AAIZ,cAAkB,QAAQ,sBAAR,CAJN;AAKZ,cAAkB,QAAQ,uBAAR,CALN;AAMZ,WAAkB,QAAQ,mBAAR,CANN;AAOZ,aAAkB,QAAQ,qBAAR,CAPN;AAQZ,cAAkB,QARN;AASZ,cAAkB,QAAQ,uBAAR,CATN;AAUZ,gBAAkB,QAAQ,yBAAR,CAVN;AAWZ,WAAkB,QAAQ,mBAAR;AAXN,GAAd;;AAcA,SAAO,OAAP;AAED,CArBS,CAqBP,OArBO,CAAV;;AAuBA,OAAO,OAAP,GAAiB,GAAjB;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC3PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrFA;AACA;AACA;AACA;AACA;;;;;;;;ACJA,IAAM,iBAAiB,QAAQ,4BAAR,CAAvB;AACA,IAAM,WAAW,QAAQ,qBAAR,CAAjB;AACA,IAAM,QAAQ,QAAQ,eAAR,CAAd;AACA,IAAM,QAAQ,QAAQ,eAAR,EAAyB,KAAvC;;AAEA;;;;;IAIM,S;AACJ,uBAAc;AAAA;;AACZ,SAAK,MAAL,GAAc,EAAE,SAAU,EAAZ,EAAgB,KAAM,EAAtB,EAAd;AACA,SAAK,SAAL,GAAiB,EAAjB;AACA,SAAK,KAAL,GAAa,IAAI,KAAJ,EAAb;AACD;AACD;;;;;;;;;4BAKQ,G,EAAK;AACX,UAAI,gBAAgB,OAAO,GAA3B,EAAgC;AAC9B,YAAI,aAAa,OAAO,GAAxB,EAA6B;AAC3B,eAAK,MAAL,CAAY,GAAZ,GAAkB,GAAlB;AACD;AACD,eAAO,IAAP;AACD;AACD,aAAO,KAAK,MAAL,CAAY,GAAnB;AACD;AACD;;;;;;;;+BAKuC;AAAA,UAA9B,YAA8B,uEAAf,aAAe;;AACrC,UAAI,SAAS,IAAI,cAAJ,GAAqB,GAArB,CAAyB,IAAzB,CAAb;AACA,WAAM,YAAN,IAAuB,IAAI,QAAJ,CAAa,MAAb,CAAvB;AACA,aAAO,KAAM,YAAN,CAAP;AACD;AACD;;;;;;;;kCAKc,O,EAAS;AACrB,UAAI,gBAAgB,OAAO,OAA3B,EAAoC;AAClC,aAAK,MAAL,CAAY,OAAZ,GAAsB,OAAtB;AACA,eAAO,IAAP;AACD,OAHD,MAGO;AACL,eAAO,MAAM,KAAK,MAAL,CAAY,OAAlB,CAAP;AACD;AACF;;;;;;AAGH,OAAO,OAAP,GAAiB,SAAjB;;;;;;;;;ACtDA;;;IAGM,K;AACJ;;;AAGA,mBAAc;AAAA;;AACZ,SAAK,OAAL,GAAe,IAAI,GAAJ,EAAf;AACA,SAAK,MAAL,GAAc;AACZ,WAAM;AADM,KAAd;AAGD;AACD;;;;;;;;;wBAKI,I,EAAM;AACR,UAAI,MAAM,KAAK,GAAL,EAAV;AACA,UAAI,MAAM,KAAK,OAAL,CAAa,GAAb,CAAiB,IAAjB,CAAV;AACA,UAAI,gBAAgB,OAAO,GAAvB,IAA8B,MAAM,IAAI,CAAJ,CAAN,GAAe,KAAK,MAAL,CAAY,GAA7D,EAAkE;AAChE,YAAI,eAAe,IAAI,CAAJ,CAAnB;AACA,eAAO,cAAP,CAAsB,YAAtB,EAAmC,aAAnC,EAAkD,EAAC,OAAQ,IAAT,EAAlD;AACA,eAAO,YAAP;AACD,OAJD,MAIO;AACL,aAAK,OAAL,CAAa,MAAb,CAAoB,IAApB,EADK,CACsB;AAC3B,eAAO,SAAP;AACD;AACF;AACD;;;;;;;;;;wBAOI,I,EAAM,K,EAAO;AACf,UAAI,aAAa,OAAO,IAAxB,EAA8B;AAC5B,cAAM,IAAI,KAAJ,CAAU,wBAAV,CAAN;AACD;AACD;AACA,UAAI,aAAa,OAAO,KAAxB,EAA+B;AAC7B,gBAAQ,IAAI,MAAJ,CAAW,KAAX,CAAR,CAD6B,CACF;AAC5B;AACD,UAAI,aAAa,OAAO,KAAxB,EAA+B;AAC7B,gBAAQ,IAAI,MAAJ,CAAW,KAAX,CAAR,CAD6B,CACF;AAC5B;AACD,UAAI,cAAc,OAAO,KAAzB,EAAgC;AAC9B,gBAAQ,IAAI,OAAJ,CAAY,KAAZ,CAAR,CAD8B,CACF;AAC7B;AACD,WAAK,OAAL,CAAa,GAAb,CAAiB,IAAjB,EAAuB,CAAC,KAAK,GAAL,EAAD,EAAa,KAAb,CAAvB;AACA,aAAO,IAAP;AACD;AACD;;;;;;;+BAIW,I,EAAM;AACf,aAAO,KAAK,OAAL,CAAa,MAAb,CAAoB,IAApB,CAAP;AACD;AACD;;;;;;;;2BAKO,M,EAAQ;AACb,UAAI,aAAa,OAAO,MAAxB,EAAgC;AAC9B,cAAM,IAAI,KAAJ,CAAU,mBAAV,CAAN;AACD;AACD,WAAK,MAAL,CAAY,GAAZ,GAAkB,MAAlB;AACA,aAAO,IAAP;AACD;;;;;;AAIH,OAAO,OAAP,GAAiB,KAAjB;;;;;;;;;;;AC5EA,IAAM,QAAQ,QAAQ,eAAR,CAAd;AACA,IAAM,QAAQ,QAAQ,eAAR,EAAyB,KAAvC;AACA;;;;IAGM,c;AACJ,4BAAyB;AAAA,QAAb,MAAa,uEAAJ,EAAI;;AAAA;;AACvB,SAAK,MAAL,GAAc,EAAE,KAAM,EAAR,EAAd;;AAEA,QAAI,WAAW;AACb,aAAQ,GADK;AAEb,sBAAiB,kBAFJ;AAGb,sBAAiB;AAHJ,KAAf;AAKA,WAAO,MAAP,CAAc,KAAK,MAAnB,EAA2B,QAA3B,EAAqC,MAAM,MAAN,CAArC;AACD;;AAED;;;;;;;;;;8BAMU,O,EAAS;AACjB,UAAI,gBAAgB,OAAO,OAA3B,EAAoC;AAClC,YAAI,aAAa,OAAO,OAAxB,EAAiC;AAC/B,eAAK,MAAL,CAAY,YAAZ,GAA2B,OAA3B;AACD;AACD,eAAO,IAAP;AACD;AACD,aAAO,KAAK,MAAL,CAAY,YAAnB;AACD;;AAED;;;;;;;;;wBAMI,M,EAAQ;AACV,UAAI,gBAAgB,OAAO,MAA3B,EAAmC;AACjC,YAAI,qBAAoB,MAApB,yCAAoB,MAApB,MAA8B,WAAW,IAA7C,EAAmD;AACjD,eAAK,MAAL,CAAY,GAAZ,GAAkB,MAAM,MAAN,CAAlB;AACD;AACD,eAAO,IAAP;AACD;AACD,aAAO,KAAK,MAAL,CAAY,GAAnB;AACD;;AAED;;;;;;;8BAIU;AACR,UAAI,CAAC,KAAK,MAAL,CAAY,GAAb,IAAoB,CAAC,KAAK,MAAL,CAAY,GAAZ,CAAgB,OAAzC,EAAkD;AAChD,eAAO,EAAP;AACD;AACD,aAAO,KAAK,MAAL,CAAY,GAAZ,CAAgB,OAAhB,EAAP;AACD;AACD;;;;;;;;wBAKI,M,EAAQ;AACV,UAAI,gBAAgB,OAAO,MAA3B,EAAmC;AACjC,YAAI,aAAa,OAAO,MAAxB,EAAgC;AAC9B,eAAK,MAAL,CAAY,GAAZ,GAAkB,MAAlB;AACD;AACD,eAAO,IAAP;AACD;AACD,aAAO,KAAK,MAAL,CAAY,GAAnB;AACD;AACD;;;;;;;;0BAKM,K,EAAO;AACX,UAAI,gBAAgB,OAAO,KAA3B,EAAkC;AAChC,YAAI,eAAe,OAAO,KAA1B,EAAiC;AAC/B,eAAK,MAAL,CAAY,YAAZ,GAA2B,KAA3B;AACD;AACD,eAAO,IAAP;AACD;AACD,aAAO,KAAK,MAAL,CAAY,YAAnB;AACD;;;;;;AAIH,OAAO,OAAP,GAAiB,cAAjB;;;;;;;;;;;AC1FA,IAAM,aAAa,QAAQ,qBAAR,CAAnB;AACA,IAAM,UAAU,QAAQ,iBAAR,CAAhB;AACA,IAAM,QAAQ,QAAQ,eAAR,EAAyB,KAAvC;AACA,IAAM,OAAO,QAAQ,eAAR,EAAyB,IAAtC;;AAEA;;;;;IAIM,Q;AACJ,sBAAiC;AAAA,QAArB,cAAqB,uEAAJ,EAAI;;AAAA;;AAC/B,QAAI,CAAC,cAAD,IAAmB,eAAe,OAAO,eAAe,KAA5D,EAAmE;AACjE,YAAM,IAAI,KAAJ,CAAU,iCAAV,CAAN;AACD;AACD,SAAK,cAAL,GAAsB,MAAM,cAAN,CAAtB;AACA,SAAK,MAAL,GAAc;AACZ,sBAAiB,IADL;AAEZ,cAAS,KAFG;AAGZ,cAAS,EAHG;AAIZ,aAAQ;AAJI,KAAd;AAMA,SAAK,KAAL,GAAa,KAAK,cAAL,CAAoB,GAApB,GAA0B,KAAvC;AACD;AACD;;;;;;;;;gCAKqB;AAAA,UAAX,IAAW,uEAAJ,EAAI;;AACnB,UAAI,OAAO,IAAI,UAAJ,CAAe,CACxB,KAAK,cAAL,CAAoB,OAApB,EADwB,EAExB,KAAK,cAAL,CAAoB,GAApB,EAFwB,CAAf,CAAX;AAIA,WAAK,OAAL,IAAgB,IAAhB;AACA,UAAI,eAAe,KAAK,cAAL,CAAoB,KAApB,EAAnB;AACA,UAAI,WAAW,IAAI,YAAJ,CAAiB,IAAjB,CAAf;AACA,eAAS,MAAT,CAAgB,KAAK,cAArB;AACA,aAAO,QAAP;AACD;AACD;;;;;;;;;0BAMM,Y,EAAc;AAClB,UAAI,gBAAgB,OAAO,YAA3B,EAAyC;AACvC,aAAK,cAAL,CAAoB,KAApB,CAA0B,YAA1B;AACA,eAAO,IAAP;AACD;AACD,aAAO,KAAK,cAAL,CAAoB,KAApB,EAAP;AACD;AACD;;;;;;;;wBAKI,M,EAAQ;AACV,UAAI,gBAAgB,OAAO,MAA3B,EAAmC;AACjC,aAAK,cAAL,CAAoB,GAApB,CAAwB,MAAxB;AACA,eAAO,IAAP;AACD;AACD,aAAO,KAAK,cAAL,CAAoB,GAApB,EAAP;AACD;AACD;;;;;;;;6BAKS,E,EAAI;AACX,UAAI,aAAa,OAAO,EAAxB,EAA4B;AAC1B,cAAM,IAAI,KAAJ,CAAU,0BAAV,CAAN;AACD;AACD,WAAK,MAAL,CAAY,MAAZ,GAAqB,IAAI,UAAJ,CAAe,CAClC,KAAK,cAAL,CAAoB,OAApB,EADkC,EAElC,KAAK,cAAL,CAAoB,GAApB,EAFkC,EAGlC,EAHkC,CAAf,CAArB;AAKA,WAAK,MAAL,CAAY,MAAZ,GAAqB,KAArB;AACA,aAAO,IAAP;AACD;AACD;;;;;;;;yBAKK,K,EAAO;AACV,WAAK,MAAL,CAAY,MAAZ,GAAqB,IAAI,UAAJ,CAAe,CAClC,KAAK,cAAL,CAAoB,OAApB,EADkC,EAElC,KAAK,cAAL,CAAoB,GAApB,EAFkC,CAAf,CAArB;AAIA,WAAK,MAAL,CAAY,MAAZ,GAAqB,KAArB;AACA,WAAK,MAAL,CAAY,KAAZ,CAAkB,MAAlB,GAA2B,KAAK,SAAL,CAAe,KAAf,CAA3B;AACA,aAAO,IAAP;AACD;;AAED;;;;;;;;;2BAMO,K,EAAO;AACZ,WAAK,MAAL,CAAY,MAAZ,GAAqB,IAAI,UAAJ,CAAe,CAClC,KAAK,cAAL,CAAoB,OAApB,EADkC,EAElC,KAAK,cAAL,CAAoB,GAApB,EAFkC,CAAf,CAArB;AAIA,WAAK,MAAL,CAAY,MAAZ,GAAqB,QAArB;AACA,WAAK,MAAL,CAAY,KAAZ,CAAkB,MAAlB,GAA2B,KAAK,SAAL,CAAe,KAAf,CAA3B;AACA,aAAO,IAAP;AACD;;AAED;;;;;;;;;;sCAOkB,E,EAAI,I,EAAM;AAC1B,UAAI,aAAa,OAAO,EAAxB,EAA4B;AAC1B,cAAM,IAAI,KAAJ,CAAU,0BAAV,CAAN;AACD;AACD,UAAI,qBAAoB,IAApB,yCAAoB,IAApB,EAAJ,EAA8B;AAC5B,cAAM,IAAI,KAAJ,CAAU,qBAAV,CAAN;AACD;AACD,WAAK,MAAL,CAAY,MAAZ,GAAqB,IAAI,UAAJ,CAAe,CAClC,KAAK,cAAL,CAAoB,OAApB,EADkC,EAElC,KAAK,cAAL,CAAoB,GAApB,EAFkC,EAGlC,EAHkC,CAAf,CAArB;AAKA,WAAK,MAAL,CAAY,IAAZ,GAAmB,IAAnB;AACA,WAAK,MAAL,CAAY,MAAZ,GAAqB,KAArB;AACA,aAAO,IAAP;AACD;;AAED;;;;;;;;;sCAMkB,E,EAAI;AACpB,UAAI,aAAa,OAAO,EAAxB,EAA4B;AAC1B,cAAM,IAAI,KAAJ,CAAU,0BAAV,CAAN;AACD;AACD,WAAK,MAAL,CAAY,MAAZ,GAAqB,IAAI,UAAJ,CAAe,CAClC,KAAK,cAAL,CAAoB,OAApB,EADkC,EAElC,KAAK,cAAL,CAAoB,GAApB,EAFkC,EAGlC,EAHkC,CAAf,CAArB;AAKA,WAAK,MAAL,CAAY,MAAZ,GAAqB,QAArB;AACA,aAAO,IAAP;AACD;;AAED;;;;;;;;;mCAMe,K,EAAO;AACpB,UAAI,gBAAgB,OAAO,KAA3B,EAAkC;AAChC,YAAI,cAAc,OAAO,KAAzB,EAAgC;AAC9B,eAAK,MAAL,CAAY,cAAZ,GAA6B,KAA7B;AACD;AACD,eAAO,IAAP;AACD;AACD,aAAO,KAAK,MAAL,CAAY,cAAnB;AACD;;AAED;;;;;;;;2BAKgB;AAAA;;AAAA,UAAX,EAAW,uEAAN,IAAM;;AACd,UAAI,iBAAiB,KAAK,cAAL,EAArB;AACA,UAAI,mBAAmB,KAAK,cAAL,CAAoB,KAApB,EAAvB;AACA,UAAI,iBAAiB,KAAK,cAA1B;;AAEA,UAAI,UAAU,EAAd;AACA,UAAI;AACF,kBAAU,KAAK,cAAL,CAAoB,GAApB,GAA0B,aAA1B,EAAV;AACD,OAFD,CAEE,OAAM,CAAN,EAAS;AACT;AACD;AACD,aAAO,MAAP,CAAc,OAAd,EAAuB,KAAK,MAAL,CAAY,OAAnC;;AAEA,UAAI,UAAU,IAAI,OAAJ,GACX,MADW,CACJ,KAAK,MAAL,CAAY,MADR,EAEX,IAFW,CAEN,KAAK,MAAL,CAAY,IAAZ,IAAoB,EAFd,EAGX,KAHW,CAGL,KAAK,MAAL,CAAY,KAAZ,IAAqB,EAHhB,EAIX,OAJW,CAIH,WAAW,EAJR,EAKX,GALW,CAKP,KAAK,MAAL,CAAY,MAAZ,CAAmB,QAAnB,EALO,CAAd;;AAOA,UAAI,UAAU,QAAQ,YAAR,EAAsB,UAAtB,EAAd;;AAEA,aAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAqB;AACtC,YAAI,MAAK,QAAL,EAAJ,EAAqB;AACnB,cAAI,eAAe,MAAM,GAAN,CAAU,QAAQ,GAAR,EAAV,CAAnB;AACA,cAAI,gBAAgB,cAApB,EAAoC;AAClC,eAAG,IAAH,EAAS,YAAT;AACA,mBAAO,QAAQ,YAAR,CAAP;AACD;AACF;AACD;AACA,gBAAQ,IAAR,GAAe,IAAf,CAAoB,oBAAY;AAC9B,cAAI,OAAO,SAAS,IAApB;AACA,cAAI,cAAJ;;AAEA,cAAI,MAAM,OAAN,CAAc,IAAd,CAAJ,EAAyB;AACvB,oBAAQ,KAAK,GAAL,CAAS,UAAC,IAAD,EAAU;AACzB,kBAAI,QAAQ,IAAI,gBAAJ,CAAqB,IAArB,CAAZ;AACA,oBAAM,MAAN,CAAa,cAAb;AACA,qBAAO,cAAP,CAAsB,KAAtB,EAA6B,WAA7B,EAA0C,EAAE,OAAQ,MAAM,OAAN,CAAV,EAA0B,YAAa,KAAvC,EAA1C;AACA,qBAAO,KAAP;AACD,aALO,CAAR;AAMD,WAPD,MAOO;AACL,oBAAQ,IAAI,gBAAJ,CAAqB,IAArB,CAAR;AACA,kBAAM,MAAN,CAAa,cAAb;AACA,mBAAO,cAAP,CAAsB,KAAtB,EAA6B,WAA7B,EAA0C,EAAE,OAAQ,MAAM,OAAN,CAAV,EAA0B,YAAa,KAAvC,EAA1C;AACD;;AAED,cAAI,MAAK,QAAL,EAAJ,EAAqB;AACnB,kBAAM,GAAN,CAAU,QAAQ,GAAR,EAAV,EAAyB,KAAzB;AACD;AACD,aAAG,IAAH,EAAS,KAAT;AACA,iBAAO,QAAQ,KAAR,CAAP;AACD,SAtBD,EAsBG,KAtBH,CAsBS,eAAO;AACd,cAAI,MAAK,QAAL,EAAJ,EAAqB;AACnB,kBAAM,UAAN,CAAiB,QAAQ,GAAR,EAAjB;AACD;AACD,aAAG,GAAH;AACA,iBAAO,OAAO,GAAP,CAAP;AACD,SA5BD;AA6BD,OAtCM,CAAP;AAuCD;AACD;;;;;;;;;2BAMqB;AAAA,UAAhB,UAAgB,uEAAH,CAAG;;AACnB,UAAI,aAAa,OAAO,UAAxB,EAAoC;AAClC,aAAK,MAAL,CAAY,KAAZ,CAAkB,IAAlB,GAAyB,UAAzB;AACD;AACD,aAAO,IAAP;AACD;AACF;;;;;;;;;4BAMwB;AAAA,UAAjB,WAAiB,uEAAH,CAAG;;AACrB,UAAI,aAAa,OAAO,WAAxB,EAAqC;AACnC,aAAK,MAAL,CAAY,KAAZ,CAAkB,KAAlB,GAA0B,WAA1B;AACD;AACD,aAAO,IAAP;AACD;AACD;;;;;;;;6BAKoB;AAAA,UAAb,MAAa,uEAAJ,EAAI;;AAClB,UAAI,MAAM,OAAN,CAAc,MAAd,CAAJ,EAA2B;AACzB,iBAAS,OAAO,IAAP,CAAY,GAAZ,CAAT;AACD;AACD,UAAI,aAAa,OAAO,MAAxB,EAAgC;AAC9B,aAAK,MAAL,CAAY,KAAZ,CAAkB,MAAlB,GAA2B,MAA3B;AACD;AACD,aAAO,IAAP;AACD;;AAED;;;;;;;;+BAKW;AACT,aAAO,KAAK,KAAL,IAAc,eAAe,OAAO,KAAK,KAAhD;AACD;;;;;;AAGH,OAAO,OAAP,GAAiB,QAAjB;;;;;;;;;AC/RA;;;IAGM,Q;AACL,qBAA6B;AAAA,MAAjB,OAAiB,uEAAP,KAAO;;AAAA;;AAC5B,OAAK,SAAL,GAAiB,EAAjB;AACA,OAAK,OAAL,GAAe,OAAf;AACA;AACD;;;;;;;;;;;uBAOK,M,EAAQ,G,EAAK;AACjB,QAAK,GAAL,cAAoB,GAApB,eAAiC,MAAjC;AACA;AACD;;;;;;;;;uBAMK,I,EAAM;AACV,QAAK,GAAL,mBAAyB,IAAzB;AACA,OAAI,eAAe,OAAO,KAAK,SAAL,CAAe,IAAzC,EAA+C;AAC9C,QAAI,eAAe;AAClB,eAAW,EAAC,iBAAkB,IAAnB,EAAyB,QAAS,CAAC,MAAD,CAAlC,EADO;AAElB,mBAAe,0BAFG;AAGlB,aAAS,GAHS;AAIlB,iBAAa,KAJK;AAKlB,kBAAc;AALI,KAAnB;AAOA,WAAO,MAAP,CAAc,IAAd,EAAoB,YAApB;AACA,SAAK,SAAL,CAAe,IAAf;AACA;AACD;AACD;;;;;;;;0CAKwB;AACvB,UAAO,oBAAP;AACA;AACD;;;;;;;;;;mCAOiB,I,EAAM,Q,EAAU;AAChC,QAAK,GAAL,CAAY,IAAZ;AACA,QAAK,SAAL,CAAe,IAAf,IAAuB,QAAvB;AACA;AACD;;;;;;;;;mCAMiB,M,EAAQ,K,EAAO;AAC/B,UAAO,IAAP;AACA;AACD;;;;;;;;sBAKI,O,EAAS;AACZ,OAAI,KAAK,OAAL,KAAiB,IAArB,EAA2B;AAC1B,YAAQ,GAAR,CAAY,OAAZ;AACA;AACD;;;;;;AAGF,OAAO,OAAP,GAAiB,QAAjB;;;;;;;;;;;AC9EA,IAAM,YAAY,QAAQ,iBAAR,CAAlB;AACA,IAAM,QAAQ,QAAQ,eAAR,EAAyB,KAAvC;AACA,IAAM,OAAO,QAAQ,eAAR,EAAyB,IAAtC;AACA,IAAM,UAAU,QAAQ,iBAAR,CAAhB;;AAEA;;;;IAGM,K;AACJ,mBAAuB;AAAA,QAAX,IAAW,uEAAJ,EAAI;;AAAA;;AACrB,WAAO,cAAP,CAAsB,IAAtB,EAA4B,UAA5B,EAAwC,EAAC,YAAa,KAAd,EAAqB,UAAW,IAAhC,EAAxC;AACA,WAAO,cAAP,CAAsB,IAAtB,EAA4B,YAA5B,EAA0C,EAAC,YAAa,KAAd,EAAqB,UAAW,IAAhC,EAA1C;AACA,WAAO,cAAP,CAAsB,IAAtB,EAA4B,YAA5B,EAA0C,EAAC,OAAQ,IAAT,EAAe,UAAW,IAA1B,EAA1C;AACA,WAAO,cAAP,CAAsB,IAAtB,EAA4B,YAA5B,EAA0C,EAAC,OAAQ,KAAK,GAAL,EAAT,EAAqB,UAAW,IAAhC,EAA1C;;AAEA,WAAO,MAAP,CAAc,IAAd,EAAoB,MAAM,IAAN,CAApB;AACD;AACD;;;;;;;;;2BAKgB;AAAA,UAAX,EAAW,uEAAN,IAAM;;AACd,UAAI,UAAU,EAAd;AACA,UAAI;AACF,kBAAU,KAAK,QAAL,CAAc,GAAd,GAAoB,aAApB,EAAV;AACD,OAFD,CAEE,OAAM,CAAN,EAAS;AACT;AACD;;AAED,UAAI,SAAS,KAAK,EAAL,GAAU,KAAV,GAAkB,MAA/B;AACA,UAAI,WAAW,IAAf;;AAEA,UAAI,UAAU,IAAI,OAAJ,GACX,GADW,CACP,KAAK,QAAL,EADO,EAEX,MAFW,CAEJ,MAFI,EAGX,OAHW,CAGH,OAHG,EAIX,IAJW,CAIN,IAJM,EAKX,IALW,GAMX,IANW,CAMN,UAAC,QAAD,EAAc;AAClB,eAAO,MAAP,CAAc,QAAd,EAAwB,MAAM,SAAS,IAAf,CAAxB;AACA,iBAAS,UAAT,GAAsB,KAAK,GAAL,EAAtB;AACA,iBAAS,UAAT,GAAsB,QAAtB;AACA,iBAAS,SAAT;AACA;AACA,eAAO,QAAP;AACD,OAbW,EAaT,KAbS,CAaH,eAAO;AACd,WAAG,GAAH;AACA,cAAM,GAAN;AACD,OAhBW,CAAd;;AAkBA,aAAO,OAAP;AACD;;AAED;;;;;;;8BAIU;AACR,UAAI,UAAU,KAAK,QAAL,CAAc,GAAd,GAAoB,aAApB,EAAd;AACA,UAAI,YAAY,KAAK,UAAL,CAAhB;AACA,UAAI,UAAU,IAAI,OAAJ,GACX,GADW,CACP,SADO,EAEX,KAFW,CAEL,EAAC,QAAS,EAAC,OAAQ,KAAK,UAAd,EAAV,EAFK,EAGX,MAHW,CAGJ,KAHI,EAIX,OAJW,CAIH,OAJG,EAKX,IALW,EAAd;AAMA,aAAO,OAAP;AACD;;AAED;;;;;;;;;8BAMU,Q,EAAsB;AAAA;;AAAA,UAAZ,GAAY,uEAAN,IAAM;;AAC9B,kBAAY,YAAM;AAChB,cAAK,OAAL,GAAe,IAAf,CAAoB,sBAAc;AAChC,cAAI,cAAc,WAAW,MAA7B,EAAqC;AACnC,kBAAK,UAAL,GAAkB,KAAK,GAAL,EAAlB;AACA,qBAAS,UAAT,EAAqB,KAAK,GAAL,EAArB;AACD;AACF,SALD;AAMD,OAPD,EAOE,GAPF;;AASA,aAAO,IAAP;AACD;;AAED;;;;;;;;6BAKS;AACP;AACA,UAAI,UAAU,KAAK,QAAL,CAAc,GAAd,GAAoB,aAApB,EAAd;;AAEA,UAAI,UAAU,KAAK,QAAL,EAAd;AACA,UAAI,YAAY,KAAK,QAAL,EAAhB;AACA,UAAI,WAAW,IAAf;AACA,UAAI,UAAU,IAAI,OAAJ,GACX,GADW,CACP,SADO,EAEX,MAFW,CAEJ,OAFI,EAGX,OAHW,CAGH,OAHG,EAIX,IAJW,CAIN,OAJM,EAKX,IALW,GAMX,IANW,CAMN,UAAC,QAAD,EAAc;AAClB,eAAO,MAAP,CAAc,QAAd,EAAwB,MAAM,SAAS,IAAf,CAAxB;AACA,iBAAS,UAAT,GAAsB,KAAK,GAAL,EAAtB;AACA,iBAAS,UAAT,GAAsB,QAAtB;AACA,iBAAS,SAAT;AACD,OAXW,CAAd;AAYA,aAAO,OAAP;AACD;;AAED;;;;;;;6BAI4B;AAAA,UAArB,cAAqB,uEAAJ,EAAI;;AAC1B,WAAK,QAAL,GAAgB,cAAhB;AACD;;;+BAEU;AACT,UAAI,oBAAJ;AACA,UAAI,qBAAoB,KAAK,QAAzB,CAAJ,EAAuC;AACrC,sBAAc,KAAK,QAAL,CAAc,OAAd,KAA0B,GAA1B,GAAgC,KAAK,QAAL,CAAc,GAAd,EAAhC,GAAsD,GAApE;AACA,YAAI,aAAa,OAAO,KAAK,EAA7B,EAAkC;AAChC,yBAAe,KAAK,EAApB;AACD;AACF,OALD,MAKO;AACL,sBAAc,gBAAd;AACD;AACD,aAAO,WAAP;AACD;;AAED;;;;;;;;;+BAMW;AACT,aAAO,UAAU,OAAV,CAAkB,KAAK,UAAvB,EAAmC,IAAnC,CAAP;AACD;AACD;;;;;;;8BAIU;AACR,aAAO,KAAK,QAAL,GAAgB,MAAhB,GAAyB,CAAhC;AACD;AACD;;;;;;;;gCAKY;AACV,WAAK,UAAL,GAAkB,MAAM,IAAN,CAAlB;AACD;;AAED;;;;;;;;6BAKkB;AAAA,UAAX,EAAW,uEAAN,IAAM;;AAChB,UAAI,UAAU,EAAd;AACA,UAAI;AACF,kBAAU,KAAK,QAAL,CAAc,GAAd,GAAoB,aAApB,EAAV;AACD,OAFD,CAEE,OAAM,CAAN,EAAS,CAAE;;AAEb,UAAI,YAAY,KAAK,QAAL,EAAhB;AACA,UAAI,WAAW,IAAf;;AAEA,UAAI,UAAU,IAAI,OAAJ,GACX,GADW,CACP,SADO,EAEX,MAFW,CAEJ,QAFI,EAGX,OAHW,CAGH,OAHG,EAIX,IAJW,GAKX,IALW,CAKN,UAAC,QAAD,EAAc;AAClB,iBAAS,UAAT,GAAsB,QAAtB;AACA,eAAO,IAAP;AACD,OARW,EAQT,KARS,CAQH,eAAO;AACd,WAAG,GAAH;AACA,cAAM,GAAN;AACD,OAXW,CAAd;AAYA,aAAO,OAAP;AACD;;;;;;AAIH,OAAO,OAAP,GAAiB,KAAjB;;;;;;;;;;;ACjMA,IAAM,YAAY,QAAQ,sBAAR,CAAlB;AACA,IAAM,QAAQ,QAAQ,eAAR,EAAyB,KAAvC;;AAEA;;;;;IAIM,O;AACJ,qBAAyB;AAAA,QAAb,MAAa,uEAAJ,EAAI;;AAAA;;AACvB,QAAI,WAAW;AACb,cAAQ,KADK;AAEb,WAAK,GAFQ;AAGb,eAAS,EAHI;AAIb,YAAM,SAJO;AAKb,oBAAe,kBALF;AAMb,cAAS;AANI,KAAf;AAQA,SAAK,MAAL,GAAc,EAAd;AACA,WAAO,MAAP,CAAc,KAAK,MAAnB,EAA2B,QAA3B,EAAqC,MAArC;AACD;AACD;;;;;;;;2BAIO;AACL,UAAI,kBAAkB,IAAtB;AACA,UAAI,UAAU,QAAQ,YAAR,EAAsB,UAAtB,EAAd;AACA,aAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAqB;AACtC,wBAAgB,SAAhB,GAA4B,IAAI,SAAJ,CAAc,eAAd,CAA5B;;AAEA,wBAAgB,SAAhB,CACC,IADD,GAEC,IAFD,CAEM,SAAS,eAAT,CAAyB,QAAzB,EAAmC;AACvC,mBAAS,IAAT,GAAgB,MAAM,SAAS,QAAf,CAAhB;AACA;AACA,mBAAS,OAAT,GAAmB,eAAnB;AACA,iBAAO,QAAQ,QAAR,CAAP;AACD,SAPD,EAOG,SAAS,aAAT,CAAuB,QAAvB,EAAiC;AAClC;AACA,mBAAS,OAAT,GAAmB,eAAnB;AACA,iBAAO,OAAO,QAAP,CAAP;AACD,SAXD;AAYD,OAfM,CAAP;AAgBD;AACD;;;;;;;;0BAKM,Q,EAAU;AACd,UAAI,gBAAgB,OAAO,QAA3B,EAAqC;AACnC,YAAI,qBAAoB,QAApB,yCAAoB,QAApB,MAAgC,aAAa,IAAjD,EAAuD;AACrD,qBAAW,MAAM,QAAN,CAAX;AACD;AACD,aAAK,MAAL,CAAY,MAAZ,GAAqB,QAArB;AACA,eAAO,IAAP;AACD,OAND,MAMO;AACL,eAAO,KAAK,MAAL,CAAY,MAAnB;AACD;AACF;;AAED;;;;;;;;2BAKO,S,EAAW;AAChB,UAAI,gBAAgB,OAAO,SAA3B,EAAsC;AACpC,YAAI,aAAa,OAAO,SAAxB,EAAmC;AACjC,eAAK,MAAL,CAAY,MAAZ,GAAqB,SAArB;AACD;AACD,eAAO,IAAP;AACD,OALD,MAKO;AACL,eAAO,KAAK,MAAL,CAAY,MAAnB;AACD;AACF;;AAED;;;;;;;;wBAKI,M,EAAQ;AACV,UAAI,gBAAgB,OAAO,MAA3B,EAAmC;AACjC,YAAI,aAAa,OAAO,MAAxB,EAAgC;AAC9B,eAAK,MAAL,CAAY,GAAZ,GAAkB,MAAlB;AACD;AACD,eAAO,IAAP;AACD,OALD,MAKO;AACL,eAAO,KAAK,MAAL,CAAY,GAAnB;AACD;AACF;;AAED;;;;;;;;4BAKQ,Y,EAAc;AACpB,UAAI,gBAAgB,OAAO,YAA3B,EAAyC;AACvC,YAAI,qBAAoB,YAApB,yCAAoB,YAApB,MAAoC,iBAAiB,IAAzD,EAA+D;AAC7D,eAAK,MAAL,CAAY,OAAZ,GAAsB,MAAM,YAAN,CAAtB;AACD;AACD,eAAO,IAAP;AACD,OALD,MAKO;AACL,eAAO,KAAK,MAAL,CAAY,OAAnB;AACD;AACF;;AAED;;;;;;;;yBAKK,O,EAAS;AACZ,UAAI,gBAAgB,OAAO,OAA3B,EAAoC;AAClC,YAAI,qBAAoB,OAApB,yCAAoB,OAApB,MAA+B,YAAY,IAA/C,EAAqD;AACnD,eAAK,MAAL,CAAY,IAAZ,GAAmB,MAAM,OAAN,CAAnB;AACD;AACD,eAAO,IAAP;AACD,OALD,MAKO;AACL,eAAO,KAAK,MAAL,CAAY,IAAnB;AACD;AACF;AACD;;;;;;;;8BAKU,O,EAAS;AACjB,UAAI,gBAAgB,OAAO,OAA3B,EAAoC;AAClC,YAAI,aAAa,OAAO,OAAxB,EAAiC;AAC/B,eAAK,MAAL,CAAY,YAAZ,GAA2B,OAA3B;AACD;AACD,eAAO,IAAP;AACD;AACD,aAAO,KAAK,MAAL,CAAY,YAAnB;AACD;;AAED;;;;;;;6BAIS;AACP,aAAO,KAAK,KAAL,CAAY,KAAK,SAAL,CAAe,KAAK,MAApB,CAAZ,CAAP;AACD;;;;;;AAGH,OAAO,OAAP,GAAiB,OAAjB;;;;;ACpJA;;;;;;AAMA,IAAI,WAAW;AACb,MAAK,OADQ;AAEb,iBAAgB,uBAAS,CAAT,EAAY;AAC1B,SAAK,EAAL,GAAU,CAAV;AACD,GAJY;AAKb,cAAa,sBAAW;AACtB,WAAO,KAAK,EAAZ;AACD;AAPY,CAAf;;AAUA,OAAO,OAAP,GAAiB,QAAjB;;;;;;;;;;;AChBA,IAAM,QAAQ,QAAQ,eAAR,EAAyB,KAAvC;AACA,IAAM,cAAc,QAAQ,aAAR,CAApB;;AAEA;;;;IAGM,S;AACL,oBAAY,OAAZ,EAAqB;AAAA;;AACpB,MAAI,gBAAgB,OAAO,MAAvB,IAAiC,OAAO,cAA5C,EAA4D;AAC3D,QAAK,WAAL,GAAmB,OAAO,cAA1B;AACA,GAFD,MAEO;AACN,QAAK,WAAL,GAAmB,QAAQ,sBAAR,CAAnB,CADM,CAC8C;AACpD;AACD,OAAK,UAAL,CAAgB,OAAhB;AACA;AACD;;;;;;;;;;6BAMW,O,EAAS;AACnB,QAAK,OAAL,GAAe,MAAM,OAAN,CAAf;AACA,UAAO,IAAP;AACA;AACD;;;;;;;;yBAKO;AACN,OAAI,UAAU,QAAQ,YAAR,EAAsB,UAAtB,EAAd;AACA,OAAI,WAAW,IAAf;;AAEA,UAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAqB;;AAEvC,QAAI,eAAe,IAAI,SAAS,WAAb,EAAnB;AACA,QAAI,MAAM,SAAS,OAAT,CAAiB,GAAjB,EAAV;;AAEA,QAAI,QAAQ,YAAY,SAAZ,CAAsB,SAAS,OAAT,CAAiB,KAAjB,EAAtB,CAAZ;AACA,QAAI,SAAS,MAAM,MAAnB,EAA2B;AAC1B,WAAM,MAAM,GAAN,GAAY,KAAlB;AACA;AACD,QAAI,OAAO,SAAS,OAAT,CAAiB,IAAjB,EAAX;AACA,QAAI,qBAAoB,IAApB,yCAAoB,IAApB,EAAJ,EAA8B;AAC7B,YAAO,KAAK,SAAL,CAAe,IAAf,CAAP;AACA;;AAED,iBAAa,gBAAb,CAA8B,MAA9B,EAAsC,gBAAtC;AACA,iBAAa,gBAAb,CAA8B,OAA9B,EAAuC,cAAvC;AACA,iBAAa,gBAAb,CAA8B,OAA9B,EAAuC,eAAvC;AACA,iBAAa,IAAb,CAAmB,SAAS,OAAT,CAAiB,MAAjB,GAA0B,WAA1B,EAAnB,EAA4D,GAA5D;AACA,iBAAa,YAAb,GAA4B,MAA5B;;AAEA,QAAI,UAAU,SAAS,OAAT,CAAiB,OAAjB,EAAd;AACA,iBAAa,gBAAb,CAA8B,cAA9B,EAA8C,SAAS,OAAT,CAAiB,SAAjB,EAA9C;;AAEA,SAAM,IAAI,UAAV,IAAwB,OAAxB,EAAkC;AACjC,kBAAa,gBAAb,CAA8B,UAA9B,EAA0C,QAAQ,UAAR,CAA1C;AACA;AACD,iBAAa,IAAb,CAAmB,IAAnB;;AAEA;;;AAGA,aAAS,eAAT,GAA2B;AAC1B,SAAI,SAAS,IAAI,KAAJ,CAAU,qBAAV,CAAb;AACA,YAAO,MAAP;AACA;AACD;;;AAGA,aAAS,cAAT,CAAwB,CAAxB,EAA2B;AAC1B,YAAO,YAAP;AACA;AACD;;;AAGA,aAAS,gBAAT,GAA4B;AAC3B,SAAI,aAAa,MAAb,GAAsB,GAA1B,EAA+B;AAC9B,cAAQ,YAAR;AACA,MAFD,MAEO;AACN,aAAO,YAAP;AACA;AACD;AACD,IAnDM,CAAP;AAoDA;;;;;;AAGF,OAAO,OAAP,GAAiB,SAAjB;;;;;;;;;ACzFA;;;;IAIM,U;AACJ,wBAAuB;AAAA,QAAX,IAAW,uEAAJ,EAAI;;AAAA;;AACrB,QAAI,CAAC,IAAD,IAAS,eAAe,OAAO,KAAK,IAAxC,EAA8C;AAC5C,YAAM,IAAI,KAAJ,CAAU,8CAAV,CAAN;AACD;AACD,SAAK,MAAL,GAAc,KAAK,MAAL,CAAY,gBAAQ;AAChC,aAAO,SAAS,GAAhB;AACD,KAFa,EAEX,IAFW,CAEN,GAFM,KAEE,GAFhB;AAGD;AACD;;;;;;;+BAGW;AACT,aAAO,KAAK,MAAL,IAAe,EAAtB;AACD;;;;;;AAGH,OAAO,OAAP,GAAiB,UAAjB;;;;;;;;;;;ACrBA,IAAI,YAAY,QAAQ,OAAR,CAAhB;;AAEA;;;;IAGM,K;AACF,mBAAc;AAAA;AAEb;AACD;;;;;;;;2BAIc,CAEb;;AAED;;;;;;;;0BAKa,G,EAAK;AACd,aAAO,GAAP;AACA;AACA;AACH;;;;;AAEL;;;;;;;;AAMA,SAAS,YAAT,CAAsB,GAAtB,EAA2B;AACxB,MAAG,QAAQ,IAAR,IAAgB,QAAO,GAAP,yCAAO,GAAP,MAAe,QAAlC,EAA4C;AACzC,WAAO,GAAP;AACF;AACD,MAAI,OAAO,IAAI,IAAI,WAAR,EAAX;AACA,OAAI,IAAI,GAAR,IAAe,GAAf,EAAoB;AACjB,SAAK,GAAL,IAAY,aAAa,IAAI,GAAJ,CAAb,CAAZ;AACF;AACD,SAAO,IAAP;AACF;;AAED,OAAO,OAAP,GAAiB,KAAjB","file":"officebot-sdk.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/**\n * This creates a simple package that can be exported\n * @namespace OfficeBotSDK.Index\n */\nlet SDK = (function(Promise) {\n\n  let Settings = require('./src/settings.js');\n  Settings.setPromiseLib(Promise);\n\n  let exports = {\n    API             : require('./src/api-config.class'),\n    Cache           : require('./src/cache.class'),\n    EndpointConfig  : require('./src/endpoint-config.class'),\n    Endpoint        : require('./src/endpoint.class'),\n    HTTPMock        : require('./src/http-mock.class'),\n    Model           : require('./src/model.class'),\n    Request         : require('./src/request.class'),\n    Settings        : Settings,\n    Tranport        : require('./src/transport.class'),\n    URLBuilder      : require('./src/url-builder.class'),\n    Utils           : require('./src/utils.class')\n  };\n\n  return exports;\n\n})(Promise);\n\nmodule.exports = SDK;","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return (b64.length * 3 / 4) - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr((len * 3 / 4) - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0; i < l; i += 4) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('Invalid typed array length')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\n// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\nif (typeof Symbol !== 'undefined' && Symbol.species &&\n    Buffer[Symbol.species] === Buffer) {\n  Object.defineProperty(Buffer, Symbol.species, {\n    value: null,\n    configurable: true,\n    enumerable: false,\n    writable: false\n  })\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (isArrayBuffer(value)) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  return fromObject(value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nBuffer.prototype.__proto__ = Uint8Array.prototype\nBuffer.__proto__ = Uint8Array\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj) {\n    if (isArrayBufferView(obj) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n        return createBuffer(0)\n      }\n      return fromArrayLike(obj)\n    }\n\n    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n      return fromArrayLike(obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (isArrayBufferView(string) || isArrayBuffer(string)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  newBuf.__proto__ = Buffer.prototype\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : new Buffer(val, encoding)\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check\n// but they should be treated as valid. See: https://github.com/feross/buffer/issues/166\nfunction isArrayBuffer (obj) {\n  return obj instanceof ArrayBuffer ||\n    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&\n      typeof obj.byteLength === 'number')\n}\n\n// Node 0.10 supports `ArrayBuffer` but lacks `ArrayBuffer.isView`\nfunction isArrayBufferView (obj) {\n  return (typeof ArrayBuffer.isView === 'function') && ArrayBuffer.isView(obj)\n}\n\nfunction numberIsNaN (obj) {\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n","var clone = (function() {\n'use strict';\n\nfunction _instanceof(obj, type) {\n  return type != null && obj instanceof type;\n}\n\nvar nativeMap;\ntry {\n  nativeMap = Map;\n} catch(_) {\n  // maybe a reference error because no `Map`. Give it a dummy value that no\n  // value will ever be an instanceof.\n  nativeMap = function() {};\n}\n\nvar nativeSet;\ntry {\n  nativeSet = Set;\n} catch(_) {\n  nativeSet = function() {};\n}\n\nvar nativePromise;\ntry {\n  nativePromise = Promise;\n} catch(_) {\n  nativePromise = function() {};\n}\n\n/**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n * @param `includeNonEnumerable` - set to true if the non-enumerable properties\n *    should be cloned as well. Non-enumerable properties on the prototype\n *    chain will be ignored. (optional - false by default)\n*/\nfunction clone(parent, circular, depth, prototype, includeNonEnumerable) {\n  if (typeof circular === 'object') {\n    depth = circular.depth;\n    prototype = circular.prototype;\n    includeNonEnumerable = circular.includeNonEnumerable;\n    circular = circular.circular;\n  }\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n\n  var useBuffer = typeof Buffer != 'undefined';\n\n  if (typeof circular == 'undefined')\n    circular = true;\n\n  if (typeof depth == 'undefined')\n    depth = Infinity;\n\n  // recurse this function so we don't reset allParents and allChildren\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null)\n      return null;\n\n    if (depth === 0)\n      return parent;\n\n    var child;\n    var proto;\n    if (typeof parent != 'object') {\n      return parent;\n    }\n\n    if (_instanceof(parent, nativeMap)) {\n      child = new nativeMap();\n    } else if (_instanceof(parent, nativeSet)) {\n      child = new nativeSet();\n    } else if (_instanceof(parent, nativePromise)) {\n      child = new nativePromise(function (resolve, reject) {\n        parent.then(function(value) {\n          resolve(_clone(value, depth - 1));\n        }, function(err) {\n          reject(_clone(err, depth - 1));\n        });\n      });\n    } else if (clone.__isArray(parent)) {\n      child = [];\n    } else if (clone.__isRegExp(parent)) {\n      child = new RegExp(parent.source, __getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (clone.__isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      child = new Buffer(parent.length);\n      parent.copy(child);\n      return child;\n    } else if (_instanceof(parent, Error)) {\n      child = Object.create(parent);\n    } else {\n      if (typeof prototype == 'undefined') {\n        proto = Object.getPrototypeOf(parent);\n        child = Object.create(proto);\n      }\n      else {\n        child = Object.create(prototype);\n        proto = prototype;\n      }\n    }\n\n    if (circular) {\n      var index = allParents.indexOf(parent);\n\n      if (index != -1) {\n        return allChildren[index];\n      }\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n\n    if (_instanceof(parent, nativeMap)) {\n      parent.forEach(function(value, key) {\n        var keyChild = _clone(key, depth - 1);\n        var valueChild = _clone(value, depth - 1);\n        child.set(keyChild, valueChild);\n      });\n    }\n    if (_instanceof(parent, nativeSet)) {\n      parent.forEach(function(value) {\n        var entryChild = _clone(value, depth - 1);\n        child.add(entryChild);\n      });\n    }\n\n    for (var i in parent) {\n      var attrs;\n      if (proto) {\n        attrs = Object.getOwnPropertyDescriptor(proto, i);\n      }\n\n      if (attrs && attrs.set == null) {\n        continue;\n      }\n      child[i] = _clone(parent[i], depth - 1);\n    }\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(parent);\n      for (var i = 0; i < symbols.length; i++) {\n        // Don't need to worry about cloning a symbol because it is a primitive,\n        // like a number or string.\n        var symbol = symbols[i];\n        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);\n        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {\n          continue;\n        }\n        child[symbol] = _clone(parent[symbol], depth - 1);\n        if (!descriptor.enumerable) {\n          Object.defineProperty(child, symbol, {\n            enumerable: false\n          });\n        }\n      }\n    }\n\n    if (includeNonEnumerable) {\n      var allPropertyNames = Object.getOwnPropertyNames(parent);\n      for (var i = 0; i < allPropertyNames.length; i++) {\n        var propertyName = allPropertyNames[i];\n        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);\n        if (descriptor && descriptor.enumerable) {\n          continue;\n        }\n        child[propertyName] = _clone(parent[propertyName], depth - 1);\n        Object.defineProperty(child, propertyName, {\n          enumerable: false\n        });\n      }\n    }\n\n    return child;\n  }\n\n  return _clone(parent, depth);\n}\n\n/**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */\nclone.clonePrototype = function clonePrototype(parent) {\n  if (parent === null)\n    return null;\n\n  var c = function () {};\n  c.prototype = parent;\n  return new c();\n};\n\n// private utility functions\n\nfunction __objToStr(o) {\n  return Object.prototype.toString.call(o);\n}\nclone.__objToStr = __objToStr;\n\nfunction __isDate(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Date]';\n}\nclone.__isDate = __isDate;\n\nfunction __isArray(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Array]';\n}\nclone.__isArray = __isArray;\n\nfunction __isRegExp(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';\n}\nclone.__isRegExp = __isRegExp;\n\nfunction __getRegExpFlags(re) {\n  var flags = '';\n  if (re.global) flags += 'g';\n  if (re.ignoreCase) flags += 'i';\n  if (re.multiline) flags += 'm';\n  return flags;\n}\nclone.__getRegExpFlags = __getRegExpFlags;\n\nreturn clone;\n})();\n\nif (typeof module === 'object' && module.exports) {\n  module.exports = clone;\n}\n","var pSlice = Array.prototype.slice;\nvar objectKeys = require('./lib/keys.js');\nvar isArguments = require('./lib/is_arguments.js');\n\nvar deepEqual = module.exports = function (actual, expected, opts) {\n  if (!opts) opts = {};\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {\n    return opts.strict ? actual === expected : actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected, opts);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isBuffer (x) {\n  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;\n  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {\n    return false;\n  }\n  if (x.length > 0 && typeof x[0] !== 'number') return false;\n  return true;\n}\n\nfunction objEquiv(a, b, opts) {\n  var i, key;\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return deepEqual(a, b, opts);\n  }\n  if (isBuffer(a)) {\n    if (!isBuffer(b)) {\n      return false;\n    }\n    if (a.length !== b.length) return false;\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n  try {\n    var ka = objectKeys(a),\n        kb = objectKeys(b);\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key], opts)) return false;\n  }\n  return typeof a === typeof b;\n}\n","var supportsArgumentsClass = (function(){\n  return Object.prototype.toString.call(arguments)\n})() == '[object Arguments]';\n\nexports = module.exports = supportsArgumentsClass ? supported : unsupported;\n\nexports.supported = supported;\nfunction supported(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n};\n\nexports.unsupported = unsupported;\nfunction unsupported(object){\n  return object &&\n    typeof object == 'object' &&\n    typeof object.length == 'number' &&\n    Object.prototype.hasOwnProperty.call(object, 'callee') &&\n    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||\n    false;\n};\n","exports = module.exports = typeof Object.keys === 'function'\n  ? Object.keys : shim;\n\nexports.shim = shim;\nfunction shim (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n","var equalsOptions = { strict: true };\r\nvar _equals = require('deep-equal');\r\nvar areEquals = function (a, b) {\r\n    return _equals(a, b, equalsOptions);\r\n};\r\nvar helpers_1 = require('./helpers');\r\nexports.JsonPatchError = helpers_1.PatchError;\r\nexports.deepClone = helpers_1._deepClone;\r\n/* We use a Javascript hash to store each\r\n function. Each hash entry (property) uses\r\n the operation identifiers specified in rfc6902.\r\n In this way, we can map each patch operation\r\n to its dedicated function in efficient way.\r\n */\r\n/* The operations applicable to an object */\r\nvar objOps = {\r\n    add: function (obj, key, document) {\r\n        obj[key] = this.value;\r\n        return { newDocument: document };\r\n    },\r\n    remove: function (obj, key, document) {\r\n        var removed = obj[key];\r\n        delete obj[key];\r\n        return { newDocument: document, removed: removed };\r\n    },\r\n    replace: function (obj, key, document) {\r\n        var removed = obj[key];\r\n        obj[key] = this.value;\r\n        return { newDocument: document, removed: removed };\r\n    },\r\n    move: function (obj, key, document) {\r\n        /* in case move target overwrites an existing value,\r\n        return the removed value, this can be taxing performance-wise,\r\n        and is potentially unneeded */\r\n        var removed = getValueByPointer(document, this.path);\r\n        if (removed) {\r\n            removed = helpers_1._deepClone(removed);\r\n        }\r\n        var originalValue = applyOperation(document, { op: \"remove\", path: this.from }).removed;\r\n        applyOperation(document, { op: \"add\", path: this.path, value: originalValue });\r\n        return { newDocument: document, removed: removed };\r\n    },\r\n    copy: function (obj, key, document) {\r\n        var valueToCopy = getValueByPointer(document, this.from);\r\n        // enforce copy by value so further operations don't affect source (see issue #177)\r\n        applyOperation(document, { op: \"add\", path: this.path, value: helpers_1._deepClone(valueToCopy) });\r\n        return { newDocument: document };\r\n    },\r\n    test: function (obj, key, document) {\r\n        return { newDocument: document, test: areEquals(obj[key], this.value) };\r\n    },\r\n    _get: function (obj, key, document) {\r\n        this.value = obj[key];\r\n        return { newDocument: document };\r\n    }\r\n};\r\n/* The operations applicable to an array. Many are the same as for the object */\r\nvar arrOps = {\r\n    add: function (arr, i, document) {\r\n        if (helpers_1.isInteger(i)) {\r\n            arr.splice(i, 0, this.value);\r\n        }\r\n        else {\r\n            arr[i] = this.value;\r\n        }\r\n        // this may be needed when using '-' in an array\r\n        return { newDocument: document, index: i };\r\n    },\r\n    remove: function (arr, i, document) {\r\n        var removedList = arr.splice(i, 1);\r\n        return { newDocument: document, removed: removedList[0] };\r\n    },\r\n    replace: function (arr, i, document) {\r\n        var removed = arr[i];\r\n        arr[i] = this.value;\r\n        return { newDocument: document, removed: removed };\r\n    },\r\n    move: objOps.move,\r\n    copy: objOps.copy,\r\n    test: objOps.test,\r\n    _get: objOps._get\r\n};\r\n/**\r\n * Retrieves a value from a JSON document by a JSON pointer.\r\n * Returns the value.\r\n *\r\n * @param document The document to get the value from\r\n * @param pointer an escaped JSON pointer\r\n * @return The retrieved value\r\n */\r\nfunction getValueByPointer(document, pointer) {\r\n    if (pointer == '') {\r\n        return document;\r\n    }\r\n    var getOriginalDestination = { op: \"_get\", path: pointer };\r\n    applyOperation(document, getOriginalDestination);\r\n    return getOriginalDestination.value;\r\n}\r\nexports.getValueByPointer = getValueByPointer;\r\n/**\r\n * Apply a single JSON Patch Operation on a JSON document.\r\n * Returns the {newDocument, result} of the operation.\r\n * It modifies the `document` and `operation` objects - it gets the values by reference.\r\n * If you would like to avoid touching your values, clone them:\r\n * `jsonpatch.applyOperation(document, jsonpatch._deepClone(operation))`.\r\n *\r\n * @param document The document to patch\r\n * @param operation The operation to apply\r\n * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.\r\n * @param mutateDocument Whether to mutate the original document or clone it before applying\r\n * @return `{newDocument, result}` after the operation\r\n */\r\nfunction applyOperation(document, operation, validateOperation, mutateDocument) {\r\n    if (validateOperation === void 0) { validateOperation = false; }\r\n    if (mutateDocument === void 0) { mutateDocument = true; }\r\n    if (validateOperation) {\r\n        if (typeof validateOperation == 'function') {\r\n            validateOperation(operation, 0, document, operation.path);\r\n        }\r\n        else {\r\n            validator(operation, 0);\r\n        }\r\n    }\r\n    /* ROOT OPERATIONS */\r\n    if (operation.path === \"\") {\r\n        var returnValue = { newDocument: document };\r\n        if (operation.op === 'add') {\r\n            returnValue.newDocument = operation.value;\r\n            return returnValue;\r\n        }\r\n        else if (operation.op === 'replace') {\r\n            returnValue.newDocument = operation.value;\r\n            returnValue.removed = document; //document we removed\r\n            return returnValue;\r\n        }\r\n        else if (operation.op === 'move' || operation.op === 'copy') {\r\n            returnValue.newDocument = getValueByPointer(document, operation.from); // get the value by json-pointer in `from` field\r\n            if (operation.op === 'move') {\r\n                returnValue.removed = document;\r\n            }\r\n            return returnValue;\r\n        }\r\n        else if (operation.op === 'test') {\r\n            returnValue.test = areEquals(document, operation.value);\r\n            if (returnValue.test === false) {\r\n                throw new exports.JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', 0, operation, document);\r\n            }\r\n            returnValue.newDocument = document;\r\n            return returnValue;\r\n        }\r\n        else if (operation.op === 'remove') {\r\n            returnValue.removed = document;\r\n            returnValue.newDocument = null;\r\n            return returnValue;\r\n        }\r\n        else if (operation.op === '_get') {\r\n            operation.value = document;\r\n            return returnValue;\r\n        }\r\n        else {\r\n            if (validateOperation) {\r\n                throw new exports.JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', 0, operation, document);\r\n            }\r\n            else {\r\n                return returnValue;\r\n            }\r\n        }\r\n    } /* END ROOT OPERATIONS */\r\n    else {\r\n        if (!mutateDocument) {\r\n            document = helpers_1._deepClone(document);\r\n        }\r\n        var path = operation.path || \"\";\r\n        var keys = path.split('/');\r\n        var obj = document;\r\n        var t = 1; //skip empty element - http://jsperf.com/to-shift-or-not-to-shift\r\n        var len = keys.length;\r\n        var existingPathFragment = undefined;\r\n        var key = void 0;\r\n        var validateFunction = void 0;\r\n        if (typeof validateOperation == 'function') {\r\n            validateFunction = validateOperation;\r\n        }\r\n        else {\r\n            validateFunction = validator;\r\n        }\r\n        while (true) {\r\n            key = keys[t];\r\n            if (validateOperation) {\r\n                if (existingPathFragment === undefined) {\r\n                    if (obj[key] === undefined) {\r\n                        existingPathFragment = keys.slice(0, t).join('/');\r\n                    }\r\n                    else if (t == len - 1) {\r\n                        existingPathFragment = operation.path;\r\n                    }\r\n                    if (existingPathFragment !== undefined) {\r\n                        validateFunction(operation, 0, document, existingPathFragment);\r\n                    }\r\n                }\r\n            }\r\n            t++;\r\n            if (Array.isArray(obj)) {\r\n                if (key === '-') {\r\n                    key = obj.length;\r\n                }\r\n                else {\r\n                    if (validateOperation && !helpers_1.isInteger(key)) {\r\n                        throw new exports.JsonPatchError(\"Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index\", \"OPERATION_PATH_ILLEGAL_ARRAY_INDEX\", 0, operation.path, operation);\r\n                    } // only parse key when it's an integer for `arr.prop` to work\r\n                    else if (helpers_1.isInteger(key)) {\r\n                        key = ~~key;\r\n                    }\r\n                }\r\n                if (t >= len) {\r\n                    if (validateOperation && operation.op === \"add\" && key > obj.length) {\r\n                        throw new exports.JsonPatchError(\"The specified index MUST NOT be greater than the number of elements in the array\", \"OPERATION_VALUE_OUT_OF_BOUNDS\", 0, operation.path, operation);\r\n                    }\r\n                    var returnValue = arrOps[operation.op].call(operation, obj, key, document); // Apply patch\r\n                    if (returnValue.test === false) {\r\n                        throw new exports.JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', 0, operation, document);\r\n                    }\r\n                    return returnValue;\r\n                }\r\n            }\r\n            else {\r\n                if (key && key.indexOf('~') != -1) {\r\n                    key = helpers_1.unescapePathComponent(key);\r\n                }\r\n                if (t >= len) {\r\n                    var returnValue = objOps[operation.op].call(operation, obj, key, document); // Apply patch\r\n                    if (returnValue.test === false) {\r\n                        throw new exports.JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', 0, operation, document);\r\n                    }\r\n                    return returnValue;\r\n                }\r\n            }\r\n            obj = obj[key];\r\n        }\r\n    }\r\n}\r\nexports.applyOperation = applyOperation;\r\n/**\r\n * Apply a full JSON Patch array on a JSON document.\r\n * Returns the {newDocument, result} of the patch.\r\n * It modifies the `document` object and `patch` - it gets the values by reference.\r\n * If you would like to avoid touching your values, clone them:\r\n * `jsonpatch.applyPatch(document, jsonpatch._deepClone(patch))`.\r\n *\r\n * @param document The document to patch\r\n * @param patch The patch to apply\r\n * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.\r\n * @return An array of `{newDocument, result}` after the patch\r\n */\r\nfunction applyPatch(document, patch, validateOperation) {\r\n    if (validateOperation) {\r\n        if (!Array.isArray(patch)) {\r\n            throw new exports.JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');\r\n        }\r\n    }\r\n    var results = new Array(patch.length);\r\n    for (var i = 0, length_1 = patch.length; i < length_1; i++) {\r\n        results[i] = applyOperation(document, patch[i], validateOperation);\r\n        document = results[i].newDocument; // in case root was replaced\r\n    }\r\n    results.newDocument = document;\r\n    return results;\r\n}\r\nexports.applyPatch = applyPatch;\r\n/**\r\n * Apply a single JSON Patch Operation on a JSON document.\r\n * Returns the updated document.\r\n * Suitable as a reducer.\r\n *\r\n * @param document The document to patch\r\n * @param operation The operation to apply\r\n * @return The updated document\r\n */\r\nfunction applyReducer(document, operation) {\r\n    var operationResult = applyOperation(document, operation);\r\n    if (operationResult.test === false) {\r\n        throw new exports.JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', 0, operation, document);\r\n    }\r\n    return operationResult.newDocument;\r\n}\r\nexports.applyReducer = applyReducer;\r\n/**\r\n * Validates a single operation. Called from `jsonpatch.validate`. Throws `JsonPatchError` in case of an error.\r\n * @param {object} operation - operation object (patch)\r\n * @param {number} index - index of operation in the sequence\r\n * @param {object} [document] - object where the operation is supposed to be applied\r\n * @param {string} [existingPathFragment] - comes along with `document`\r\n */\r\nfunction validator(operation, index, document, existingPathFragment) {\r\n    if (typeof operation !== 'object' || operation === null || Array.isArray(operation)) {\r\n        throw new exports.JsonPatchError('Operation is not an object', 'OPERATION_NOT_AN_OBJECT', index, operation, document);\r\n    }\r\n    else if (!objOps[operation.op]) {\r\n        throw new exports.JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);\r\n    }\r\n    else if (typeof operation.path !== 'string') {\r\n        throw new exports.JsonPatchError('Operation `path` property is not a string', 'OPERATION_PATH_INVALID', index, operation, document);\r\n    }\r\n    else if (operation.path.indexOf('/') !== 0 && operation.path.length > 0) {\r\n        // paths that aren't empty string should start with \"/\"\r\n        throw new exports.JsonPatchError('Operation `path` property must start with \"/\"', 'OPERATION_PATH_INVALID', index, operation, document);\r\n    }\r\n    else if ((operation.op === 'move' || operation.op === 'copy') && typeof operation.from !== 'string') {\r\n        throw new exports.JsonPatchError('Operation `from` property is not present (applicable in `move` and `copy` operations)', 'OPERATION_FROM_REQUIRED', index, operation, document);\r\n    }\r\n    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && operation.value === undefined) {\r\n        throw new exports.JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_REQUIRED', index, operation, document);\r\n    }\r\n    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && helpers_1.hasUndefined(operation.value)) {\r\n        throw new exports.JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED', index, operation, document);\r\n    }\r\n    else if (document) {\r\n        if (operation.op == \"add\") {\r\n            var pathLen = operation.path.split(\"/\").length;\r\n            var existingPathLen = existingPathFragment.split(\"/\").length;\r\n            if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {\r\n                throw new exports.JsonPatchError('Cannot perform an `add` operation at the desired path', 'OPERATION_PATH_CANNOT_ADD', index, operation, document);\r\n            }\r\n        }\r\n        else if (operation.op === 'replace' || operation.op === 'remove' || operation.op === '_get') {\r\n            if (operation.path !== existingPathFragment) {\r\n                throw new exports.JsonPatchError('Cannot perform the operation at a path that does not exist', 'OPERATION_PATH_UNRESOLVABLE', index, operation, document);\r\n            }\r\n        }\r\n        else if (operation.op === 'move' || operation.op === 'copy') {\r\n            var existingValue = { op: \"_get\", path: operation.from, value: undefined };\r\n            var error = validate([existingValue], document);\r\n            if (error && error.name === 'OPERATION_PATH_UNRESOLVABLE') {\r\n                throw new exports.JsonPatchError('Cannot perform the operation from a path that does not exist', 'OPERATION_FROM_UNRESOLVABLE', index, operation, document);\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.validator = validator;\r\n/**\r\n * Validates a sequence of operations. If `document` parameter is provided, the sequence is additionally validated against the object document.\r\n * If error is encountered, returns a JsonPatchError object\r\n * @param sequence\r\n * @param document\r\n * @returns {JsonPatchError|undefined}\r\n */\r\nfunction validate(sequence, document, externalValidator) {\r\n    try {\r\n        if (!Array.isArray(sequence)) {\r\n            throw new exports.JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');\r\n        }\r\n        if (document) {\r\n            //clone document and sequence so that we can safely try applying operations\r\n            applyPatch(helpers_1._deepClone(document), helpers_1._deepClone(sequence), externalValidator || true);\r\n        }\r\n        else {\r\n            externalValidator = externalValidator || validator;\r\n            for (var i = 0; i < sequence.length; i++) {\r\n                externalValidator(sequence[i], i, document, undefined);\r\n            }\r\n        }\r\n    }\r\n    catch (e) {\r\n        if (e instanceof exports.JsonPatchError) {\r\n            return e;\r\n        }\r\n        else {\r\n            throw e;\r\n        }\r\n    }\r\n}\r\nexports.validate = validate;\r\n","var equalsOptions = { strict: true };\r\nvar _equals = require('deep-equal');\r\nvar areEquals = function (a, b) {\r\n    return _equals(a, b, equalsOptions);\r\n};\r\nvar helpers_1 = require('./helpers');\r\nvar core_1 = require('./core');\r\n/* export all core functions */\r\nvar core_2 = require('./core');\r\nexports.applyOperation = core_2.applyOperation;\r\nexports.applyPatch = core_2.applyPatch;\r\nexports.applyReducer = core_2.applyReducer;\r\nexports.getValueByPointer = core_2.getValueByPointer;\r\nexports.validate = core_2.validate;\r\nexports.validator = core_2.validator;\r\n/* export some helpers */\r\nvar helpers_2 = require('./helpers');\r\nexports.JsonPatchError = helpers_2.PatchError;\r\nexports.deepClone = helpers_2._deepClone;\r\nexports.escapePathComponent = helpers_2.escapePathComponent;\r\nexports.unescapePathComponent = helpers_2.unescapePathComponent;\r\nvar beforeDict = [];\r\nvar Mirror = (function () {\r\n    function Mirror(obj) {\r\n        this.observers = [];\r\n        this.obj = obj;\r\n    }\r\n    return Mirror;\r\n}());\r\nvar ObserverInfo = (function () {\r\n    function ObserverInfo(callback, observer) {\r\n        this.callback = callback;\r\n        this.observer = observer;\r\n    }\r\n    return ObserverInfo;\r\n}());\r\nfunction getMirror(obj) {\r\n    for (var i = 0, length = beforeDict.length; i < length; i++) {\r\n        if (beforeDict[i].obj === obj) {\r\n            return beforeDict[i];\r\n        }\r\n    }\r\n}\r\nfunction getObserverFromMirror(mirror, callback) {\r\n    for (var j = 0, length = mirror.observers.length; j < length; j++) {\r\n        if (mirror.observers[j].callback === callback) {\r\n            return mirror.observers[j].observer;\r\n        }\r\n    }\r\n}\r\nfunction removeObserverFromMirror(mirror, observer) {\r\n    for (var j = 0, length = mirror.observers.length; j < length; j++) {\r\n        if (mirror.observers[j].observer === observer) {\r\n            mirror.observers.splice(j, 1);\r\n            return;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Detach an observer from an object\r\n */\r\nfunction unobserve(root, observer) {\r\n    observer.unobserve();\r\n}\r\nexports.unobserve = unobserve;\r\n/**\r\n * Observes changes made to an object, which can then be retrieved using generate\r\n */\r\nfunction observe(obj, callback) {\r\n    var patches = [];\r\n    var root = obj;\r\n    var observer;\r\n    var mirror = getMirror(obj);\r\n    if (!mirror) {\r\n        mirror = new Mirror(obj);\r\n        beforeDict.push(mirror);\r\n    }\r\n    else {\r\n        observer = getObserverFromMirror(mirror, callback);\r\n    }\r\n    if (observer) {\r\n        return observer;\r\n    }\r\n    observer = {};\r\n    mirror.value = helpers_1._deepClone(obj);\r\n    if (callback) {\r\n        observer.callback = callback;\r\n        observer.next = null;\r\n        var dirtyCheck = function () {\r\n            generate(observer);\r\n        };\r\n        var fastCheck = function () {\r\n            clearTimeout(observer.next);\r\n            observer.next = setTimeout(dirtyCheck);\r\n        };\r\n        if (typeof window !== 'undefined') {\r\n            if (window.addEventListener) {\r\n                window.addEventListener('mouseup', fastCheck);\r\n                window.addEventListener('keyup', fastCheck);\r\n                window.addEventListener('mousedown', fastCheck);\r\n                window.addEventListener('keydown', fastCheck);\r\n                window.addEventListener('change', fastCheck);\r\n            }\r\n            else {\r\n                document.documentElement.attachEvent('onmouseup', fastCheck);\r\n                document.documentElement.attachEvent('onkeyup', fastCheck);\r\n                document.documentElement.attachEvent('onmousedown', fastCheck);\r\n                document.documentElement.attachEvent('onkeydown', fastCheck);\r\n                document.documentElement.attachEvent('onchange', fastCheck);\r\n            }\r\n        }\r\n    }\r\n    observer.patches = patches;\r\n    observer.object = obj;\r\n    observer.unobserve = function () {\r\n        generate(observer);\r\n        clearTimeout(observer.next);\r\n        removeObserverFromMirror(mirror, observer);\r\n        if (typeof window !== 'undefined') {\r\n            if (window.removeEventListener) {\r\n                window.removeEventListener('mouseup', fastCheck);\r\n                window.removeEventListener('keyup', fastCheck);\r\n                window.removeEventListener('mousedown', fastCheck);\r\n                window.removeEventListener('keydown', fastCheck);\r\n            }\r\n            else {\r\n                document.documentElement.detachEvent('onmouseup', fastCheck);\r\n                document.documentElement.detachEvent('onkeyup', fastCheck);\r\n                document.documentElement.detachEvent('onmousedown', fastCheck);\r\n                document.documentElement.detachEvent('onkeydown', fastCheck);\r\n            }\r\n        }\r\n    };\r\n    mirror.observers.push(new ObserverInfo(callback, observer));\r\n    return observer;\r\n}\r\nexports.observe = observe;\r\n/**\r\n * Generate an array of patches from an observer\r\n */\r\nfunction generate(observer) {\r\n    var mirror;\r\n    for (var i = 0, length = beforeDict.length; i < length; i++) {\r\n        if (beforeDict[i].obj === observer.object) {\r\n            mirror = beforeDict[i];\r\n            break;\r\n        }\r\n    }\r\n    _generate(mirror.value, observer.object, observer.patches, \"\");\r\n    if (observer.patches.length) {\r\n        core_1.applyPatch(mirror.value, observer.patches);\r\n    }\r\n    var temp = observer.patches;\r\n    if (temp.length > 0) {\r\n        observer.patches = [];\r\n        if (observer.callback) {\r\n            observer.callback(temp);\r\n        }\r\n    }\r\n    return temp;\r\n}\r\nexports.generate = generate;\r\n// Dirty check if obj is different from mirror, generate patches and update mirror\r\nfunction _generate(mirror, obj, patches, path) {\r\n    if (obj === mirror) {\r\n        return;\r\n    }\r\n    if (typeof obj.toJSON === \"function\") {\r\n        obj = obj.toJSON();\r\n    }\r\n    var newKeys = helpers_1._objectKeys(obj);\r\n    var oldKeys = helpers_1._objectKeys(mirror);\r\n    var changed = false;\r\n    var deleted = false;\r\n    //if ever \"move\" operation is implemented here, make sure this test runs OK: \"should not generate the same patch twice (move)\"\r\n    for (var t = oldKeys.length - 1; t >= 0; t--) {\r\n        var key = oldKeys[t];\r\n        var oldVal = mirror[key];\r\n        if (helpers_1.hasOwnProperty(obj, key) && !(obj[key] === undefined && oldVal !== undefined && Array.isArray(obj) === false)) {\r\n            var newVal = obj[key];\r\n            if (typeof oldVal == \"object\" && oldVal != null && typeof newVal == \"object\" && newVal != null) {\r\n                _generate(oldVal, newVal, patches, path + \"/\" + helpers_1.escapePathComponent(key));\r\n            }\r\n            else {\r\n                if (oldVal !== newVal) {\r\n                    changed = true;\r\n                    patches.push({ op: \"replace\", path: path + \"/\" + helpers_1.escapePathComponent(key), value: helpers_1._deepClone(newVal) });\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            patches.push({ op: \"remove\", path: path + \"/\" + helpers_1.escapePathComponent(key) });\r\n            deleted = true; // property has been deleted\r\n        }\r\n    }\r\n    if (!deleted && newKeys.length == oldKeys.length) {\r\n        return;\r\n    }\r\n    for (var t = 0; t < newKeys.length; t++) {\r\n        var key = newKeys[t];\r\n        if (!helpers_1.hasOwnProperty(mirror, key) && obj[key] !== undefined) {\r\n            patches.push({ op: \"add\", path: path + \"/\" + helpers_1.escapePathComponent(key), value: helpers_1._deepClone(obj[key]) });\r\n        }\r\n    }\r\n}\r\n/**\r\n * Create an array of patches from the differences in two objects\r\n */\r\nfunction compare(tree1, tree2) {\r\n    var patches = [];\r\n    _generate(tree1, tree2, patches, '');\r\n    return patches;\r\n}\r\nexports.compare = compare;\r\n","var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\n/*!\r\n * https://github.com/Starcounter-Jack/JSON-Patch\r\n * (c) 2017 Joachim Wester\r\n * MIT license\r\n */\r\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\r\nfunction hasOwnProperty(obj, key) {\r\n    return _hasOwnProperty.call(obj, key);\r\n}\r\nexports.hasOwnProperty = hasOwnProperty;\r\nfunction _objectKeys(obj) {\r\n    if (Array.isArray(obj)) {\r\n        var keys = new Array(obj.length);\r\n        for (var k = 0; k < keys.length; k++) {\r\n            keys[k] = \"\" + k;\r\n        }\r\n        return keys;\r\n    }\r\n    if (Object.keys) {\r\n        return Object.keys(obj);\r\n    }\r\n    var keys = [];\r\n    for (var i in obj) {\r\n        if (hasOwnProperty(obj, i)) {\r\n            keys.push(i);\r\n        }\r\n    }\r\n    return keys;\r\n}\r\nexports._objectKeys = _objectKeys;\r\n;\r\n/**\r\n* Deeply clone the object.\r\n* https://jsperf.com/deep-copy-vs-json-stringify-json-parse/25 (recursiveDeepCopy)\r\n* @param  {any} obj value to clone\r\n* @return {any} cloned obj\r\n*/\r\nfunction _deepClone(obj) {\r\n    switch (typeof obj) {\r\n        case \"object\":\r\n            return JSON.parse(JSON.stringify(obj)); //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5\r\n        case \"undefined\":\r\n            return null; //this is how JSON.stringify behaves for array items\r\n        default:\r\n            return obj; //no need to clone primitives\r\n    }\r\n}\r\nexports._deepClone = _deepClone;\r\n//3x faster than cached /^\\d+$/.test(str)\r\nfunction isInteger(str) {\r\n    var i = 0;\r\n    var len = str.length;\r\n    var charCode;\r\n    while (i < len) {\r\n        charCode = str.charCodeAt(i);\r\n        if (charCode >= 48 && charCode <= 57) {\r\n            i++;\r\n            continue;\r\n        }\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\nexports.isInteger = isInteger;\r\n/**\r\n* Escapes a json pointer path\r\n* @param path The raw pointer\r\n* @return the Escaped path\r\n*/\r\nfunction escapePathComponent(path) {\r\n    if (path.indexOf('/') === -1 && path.indexOf('~') === -1)\r\n        return path;\r\n    return path.replace(/~/g, '~0').replace(/\\//g, '~1');\r\n}\r\nexports.escapePathComponent = escapePathComponent;\r\n/**\r\n * Unescapes a json pointer path\r\n * @param path The escaped pointer\r\n * @return The unescaped path\r\n */\r\nfunction unescapePathComponent(path) {\r\n    return path.replace(/~1/g, '/').replace(/~0/g, '~');\r\n}\r\nexports.unescapePathComponent = unescapePathComponent;\r\nfunction _getPathRecursive(root, obj) {\r\n    var found;\r\n    for (var key in root) {\r\n        if (hasOwnProperty(root, key)) {\r\n            if (root[key] === obj) {\r\n                return escapePathComponent(key) + '/';\r\n            }\r\n            else if (typeof root[key] === 'object') {\r\n                found = _getPathRecursive(root[key], obj);\r\n                if (found != '') {\r\n                    return escapePathComponent(key) + '/' + found;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return '';\r\n}\r\nexports._getPathRecursive = _getPathRecursive;\r\nfunction getPath(root, obj) {\r\n    if (root === obj) {\r\n        return '/';\r\n    }\r\n    var path = _getPathRecursive(root, obj);\r\n    if (path === '') {\r\n        throw new Error(\"Object not found in root\");\r\n    }\r\n    return '/' + path;\r\n}\r\nexports.getPath = getPath;\r\n/**\r\n* Recursively checks whether an object has any undefined values inside.\r\n*/\r\nfunction hasUndefined(obj) {\r\n    if (obj === undefined) {\r\n        return true;\r\n    }\r\n    if (obj) {\r\n        if (Array.isArray(obj)) {\r\n            for (var i = 0, len = obj.length; i < len; i++) {\r\n                if (hasUndefined(obj[i])) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        else if (typeof obj === \"object\") {\r\n            var objKeys = _objectKeys(obj);\r\n            var objKeysLength = objKeys.length;\r\n            for (var i = 0; i < objKeysLength; i++) {\r\n                if (hasUndefined(obj[objKeys[i]])) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nexports.hasUndefined = hasUndefined;\r\nvar PatchError = (function (_super) {\r\n    __extends(PatchError, _super);\r\n    function PatchError(message, name, index, operation, tree) {\r\n        _super.call(this, message);\r\n        this.message = message;\r\n        this.name = name;\r\n        this.index = index;\r\n        this.operation = operation;\r\n        this.tree = tree;\r\n    }\r\n    return PatchError;\r\n}(Error));\r\nexports.PatchError = PatchError;\r\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n","'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n","const EndpointConfig = require('./endpoint-config.class.js');\nconst Endpoint = require('./endpoint.class.js');\nconst Cache = require('./cache.class');\nconst clone = require('./utils.class').clone;\n\n/**\n * Defines the base configuration for an API\n * @constructor\n */\nclass APIConfig {\n  constructor() {\n    this.config = { headers : {}, url : '' };\n    this.endpoints = {};\n    this.cache = new Cache();\n  }\n  /**\n   * Gets / Sets base api url\n   * @param {string=} url - Base url that this endpoint talks to\n   * @returns {(this|string)}\n   */\n  baseUrl(url) {\n    if ('undefined' !== typeof url) {\n      if ('string' === typeof url) {\n        this.config.url = url;\n      }\n      return this;\n    }\n    return this.config.url;\n  }\n  /**\n   * Creates a new endpoint\n   * @param {string} endpointName - The name that will be used to get this endpoint\n   * @returns {@link Endpoint} An instance of Endpoint\n   */\n  endpoint(endpointName = '__default__') {\n    let config = new EndpointConfig().api(this);\n    this[ endpointName ] = new Endpoint(config);\n    return this[ endpointName ];\n  }\n  /**\n   * Sets headers that all calls will use. Helpful for authentication\n   * @param {object=} headers - Key / value pairs of headers\n   * @returns {this | object}\n   */\n  commonHeaders(headers) {\n    if ('undefined' !== typeof headers) {\n      this.config.headers = headers;\n      return this;\n    } else {\n      return clone(this.config.headers);\n    }\n  }\n}\n\nmodule.exports = APIConfig;","/**\n * @constructor\n */\nclass Cache {\n  /**\n   * Create a cache object\n   */\n  constructor() {\n    this.objects = new Map();\n    this.config = {\n      ttl : 60000,\n    };\n  }\n  /**\n   * Fetches an object from the cache using the object's name (typically the url)\n   * @param {string} name \n   * @returns {(object|Array|undefined)} The found object or array if exists, otherwise undefined\n   */\n  get(name) {\n    let now = Date.now();\n    let obj = this.objects.get(name);\n    if ('undefined' !== typeof obj && now - obj[0] < this.config.ttl) {\n      let cachedObject = obj[1];\n      Object.defineProperty(cachedObject,'__fromCache', {value : true});\n      return cachedObject;\n    } else {\n      this.objects.delete(name); //in case the object exists but has expired\n      return undefined;\n    }\n  }\n  /**\n   * Stores any object or primitive into the cache using it's name\n   * NOTE: Primitives WILL be converted to objects prior to caching\n   * @param {string} name \n   * @param {(string|number|boolean|object)} value \n   * @returns {boolean} success\n   */\n  put(name, value) {\n    if ('string' !== typeof name) {\n      throw new Error('Invalid name attribute');\n    }\n    //convert primitive strings to string objects so we can add __fromCached\n    if ('string' === typeof value) {\n      value = new String(value); // jshint ignore:line\n    }\n    if ('number' === typeof value) {\n      value = new Number(value); // jshint ignore:line\n    }\n    if ('boolean' === typeof value) {\n      value = new Boolean(value); // jshint ignore:line      \n    }\n    this.objects.set(name, [Date.now(), value]);\n    return true;\n  }\n  /**\n   * Removes an object from the cache\n   * @param {string} name \n   */\n  invalidate(name) {\n    return this.objects.delete(name);\n  }\n  /**\n   * Changes the default time to live of objects in the cache\n   * @param {number} newTTL \n   * @returns {boolean} success\n   */\n  setTTL(newTTL) {\n    if ('number' !== typeof newTTL) {\n      throw new Error('Invalid TTL value');\n    }\n    this.config.ttl = newTTL;\n    return true;\n  }\n \n}\n\nmodule.exports = Cache;","const Model = require('./model.class');\nconst clone = require('./utils.class').clone;\n/**\n * @constructor\n */\nclass EndpointConfig {\n  constructor(config = {}) {\n    this.config = { api : {}};\n\n    let defaults = {\n      'url' : '/',\n      'responseType' : \"application/json\",\n      'instantiator' : Model\n    };\n    Object.assign(this.config, defaults, clone(config));\n  }\n\n  /**\n   * Gets or sets the expected media return type. Ultimately, it is up to the transport\n   * to use this setting to correctly talk to the api\n   * Note - This is currently unused\n   * @param {string=} newType - The new media type that this endpoint communicates with\n   */\n  mediaType(newType) {\n    if ('undefined' !== typeof newType) {\n      if ('string' === typeof newType) {\n        this.config.responseType = newType;\n      }\n      return this;\n    }\n    return this.config.responseType;\n  }\n\n  /**\n   * Gets / sets the API configuration object. This is needed so each\n   * endpoint can share common settings\n   * @param {APIConfig} config - The parent api configuration \n   * @returns {(this | object)}\n   */\n  api(config) {\n    if ('undefined' !== typeof config) {\n      if ('object' === typeof config && config !== null) {\n        this.config.api = clone(config);\n      }\n      return this;\n    }\n    return this.config.api;\n  }\n\n  /**\n   * Gets the base url from the underlying api configuration \n   * @returns {string} Current root url\n   */\n  baseUrl() {\n    if (!this.config.api || !this.config.api.baseUrl) {\n      return '';\n    }\n    return this.config.api.baseUrl();\n  }\n  /**\n   * Gets / sets the endpoint's relative url\n   * @param {string=} newUrl - Url to use for this endpoint\n   * @returns {(this | string)} This instance or the current url\n   */\n  url(newUrl) {\n    if ('undefined' !== typeof newUrl) {\n      if ('string' === typeof newUrl) {\n        this.config.url = newUrl;\n      }\n      return this;\n    }\n    return this.config.url;\n  }\n  /**\n   * Gets / sets the instantiator function to use when creating a new model. \n   * @param {(function|class)=} instantiator - the function or class to use for instantiation\n   * @returns {(this|function)} This instance or the current insantiation function \n   */\n  model(newFn) {\n    if ('undefined' !== typeof newFn) {\n      if ('function' === typeof newFn) {\n        this.config.instantiator = newFn;\n      }\n      return this;\n    }\n    return this.config.instantiator;\n  }\n\n}\n\nmodule.exports = EndpointConfig;","const URLBuilder = require('./url-builder.class');\nconst Request = require('./request.class');\nconst clone = require('./utils.class').clone;\nconst noop = require('./utils.class').noop;\n\n/**\n * Creates an endpoint instance\n * @constructor\n */\nclass Endpoint {\n  constructor(endpointConfig = {}) {\n    if (!endpointConfig || 'function' !== typeof endpointConfig.model) {\n      throw new Error('Invalid endpoint configuration.');\n    }\n    this.endpointConfig = clone(endpointConfig);\n    this.config = {\n      allowFromCache : true,\n      method : 'get',\n      target : '',\n      query : {}\n    };\n    this.cache = this.endpointConfig.api().cache;\n  }\n  /**\n   * Instantiates a new model instance and returns it\n   * @param {object=} data - Initialization data for the new model instance\n   * @returns {@link Model} New instance of Model\n   */\n  createNew(data = {}) {\n    let root = new URLBuilder([\n      this.endpointConfig.baseUrl(),\n      this.endpointConfig.url()\n    ]);\n    data['@root'] = root;\n    let instantiator = this.endpointConfig.model();\n    let instance = new instantiator(data);\n    instance.config(this.endpointConfig);\n    return instance;\n  }\n  /**\n   * Gets / sets instantiator to use when creating a new model instance. Instantiator *should* inherit\n   * from {@link Model}\n   * @param {(function|class)=} instantiator - Function or class to use when instantiating model\n   * @returns {(this|function)} Current instantiator function or this instance\n   */\n  model(instantiator) {\n    if ('undefined' !== typeof instantiator) {\n      this.endpointConfig.model(instantiator);\n      return this;\n    }\n    return this.endpointConfig.model();\n  }\n  /**\n   * Gets / sets the endpoint's relative url\n   * @param {string=} url - The new url value\n   * @returns {(this|string)} This instance or the current url\n   */\n  url(newUrl) {\n    if ('undefined' !== typeof newUrl) {\n      this.endpointConfig.url(newUrl);\n      return this;\n    }\n    return this.endpointConfig.url();\n  }\n  /**\n   * Builds a query to find an object with the specified identifier\n   * @param {string} id - the unique model identifier\n   * @returns {this}\n   */\n  findById(id) {\n    if ('string' !== typeof id) {\n      throw new Error('Invalid model identifier');\n    }\n    this.config.target = new URLBuilder([\n      this.endpointConfig.baseUrl(),\n      this.endpointConfig.url(),\n      id\n    ]);\n    this.config.method = 'get';\n    return this;\n  }\n  /**\n   * Creates a query to find objects that match the optional query\n   * @param {object=} query\n   * @returns {this}\n   */\n  find(query) {\n    this.config.target = new URLBuilder([\n      this.endpointConfig.baseUrl(),\n      this.endpointConfig.url()\n    ]);\n    this.config.method = 'get';\n    this.config.query.search = JSON.stringify(query);\n    return this;\n  }\n\n  /**\n    * At the moment, this behaves exactly the same as .find, but uses the\n    * SEARCH verb instead\n    * @param {object} query\n    * @returns {this}\n    */\n  search(query) {\n    this.config.target = new URLBuilder([\n      this.endpointConfig.baseUrl(),\n      this.endpointConfig.url()\n    ]);\n    this.config.method = 'search';\n    this.config.query.search = JSON.stringify(query);\n    return this;\n  }\n\n  /**\n   * Creates a query to find a unique model with the specified id\n   * and replaces it's data with the specified body object\n   * @param {string} id - the unique model identifier\n   * @param {object} body\n   * @returns {this}\n   */\n  findByIdAndUpdate(id, body) {\n    if ('string' !== typeof id) {\n      throw new Error('Invalid model identifier');\n    }\n    if ('object' !== typeof body) {\n      throw new Error('Invalid body object');\n    }\n    this.config.target = new URLBuilder([\n      this.endpointConfig.baseUrl(),\n      this.endpointConfig.url(),\n      id\n    ]);\n    this.config.body = body;\n    this.config.method = 'put';\n    return this;\n  }\n\n  /**\n   * Creates a query that finds a model with the specified id and\n   * removes it from the database\n   * @param {string} id - the unique model identifier\n   * @returns {this}\n   */\n  findByIdAndRemove(id) {\n    if ('string' !== typeof id) {\n      throw new Error('Invalid model identifier');\n    }\n    this.config.target = new URLBuilder([\n      this.endpointConfig.baseUrl(),\n      this.endpointConfig.url(),\n      id\n    ]);\n    this.config.method = 'delete';\n    return this;\n  }\n\n  /**\n   * Determines if the query request should allow objects from the cache\n   * or require objects be fresh from the api\n   * @param {boolean=} allow - Specify if using the cache is allowed\n   * @returns {(this | boolean)} This instance or the current allow value\n   */\n  allowFromCache(allow) {\n    if ('undefined' !== typeof allow) {\n      if ('boolean' === typeof allow) {\n        this.config.allowFromCache = allow;\n      }\n      return this;\n    }\n    return this.config.allowFromCache;\n  }\n\n  /**\n   * Runs the query that has been created using the find/findBy.. calls\n   * @param {function=} cb - Function to call on completion (success or failure)\n   * @returns {Promise}\n   */\n  exec(cb = noop) {\n    let allowFromCache = this.allowFromCache();\n    let modelConstructor = this.endpointConfig.model();\n    let endpointConfig = this.endpointConfig;\n\n    let headers = {};\n    try {\n      headers = this.endpointConfig.api().commonHeaders();\n    } catch(e) {\n      // console.error('Unable to get common headers. Something went\\'t wrong (unless you are unit testing). ');\n    }\n    Object.assign(headers, this.config.headers);\n\n    let request = new Request()\n      .method(this.config.method)\n      .body(this.config.body || {})\n      .query(this.config.query || {})\n      .headers(headers || {})\n      .url(this.config.target.toString());\n\n    let Promise = require('./settings').getPromise();\n\n    return new Promise((resolve, reject) => {\n      if (this.hasCache()) {\n        let cachedObject = cache.get(request.url());\n        if (cachedObject && allowFromCache) {\n          cb(null, cachedObject);\n          return resolve(cachedObject);\n        }\n      }\n      //do actual 'get'\n      request.exec().then(response => {\n        let data = response.data;\n        let model;\n\n        if (Array.isArray(data)) {\n          model = data.map((item) => {\n            let entry = new modelConstructor(item);\n            entry.config(endpointConfig);\n            Object.defineProperty(entry, '__request', { value : clone(request), enumerable : false });\n            return entry;\n          });\n        } else {\n          model = new modelConstructor(data);\n          model.config(endpointConfig);\n          Object.defineProperty(model, '__request', { value : clone(request), enumerable : false });\n        }\n\n        if (this.hasCache()) {\n          cache.put(request.url(), model);\n        }\n        cb(null, model);\n        return resolve(model);\n      }).catch(err => {\n        if (this.hasCache()) {\n          cache.invalidate(request.url());\n        }\n        cb(err);\n        return reject(err);\n      });\n    });\n  }\n  /**\n   * Query helper to skip records returned from the api (if supported). Combined\n   * with the .limit method, this function is great for pagination\n   * @param {number} skipAmount\n   * @returns this\n   */\n  skip(skipAmount = 0) {\n    if ('number' === typeof skipAmount) {\n      this.config.query.skip = skipAmount;\n    }\n    return this;\n  }\n /**\n  * Query helper to limit the number of results returned (provided the api\n  * supports it)\n  * @param {number} limitAmount\n  * @returns this\n  */\n  limit(limitAmount = 0) {\n    if ('number' === typeof limitAmount) {\n      this.config.query.limit = limitAmount;\n    }\n    return this;\n  }\n  /**\n   * Sets a list of fields to return from the api (if supported).\n   * @param {(string|string[])} fields - a list of fields to return from the api\n   * @returns this\n   */\n  select(fields = '') {\n    if (Array.isArray(fields)) {\n      fields = fields.join(' ');\n    }\n    if ('string' === typeof fields) {\n      this.config.query.fields = fields;\n    }\n    return this;\n  }\n\n  /**\n   * Checks to see if the cache object has been set and is valid\n   * @access private\n   * @returns {boolean}\n   */\n  hasCache() {\n    return this.cache && 'function' === typeof this.cache;\n  }\n}\n\nmodule.exports = Endpoint;\n","/**\n * @constructor\n */\nclass HTTPMock {\n\tconstructor(verbose = false) {\n\t\tthis.listeners = {};\n\t\tthis.verbose = verbose;\n\t}\n\t/**\n\t * Mock representation of the XMLHttpRequest open method\n\t * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/open}\n\t * @param {string} method \n\t * @param {string} url \n\t * @returns {undefined}\n\t */\n\topen(method, url) {\n\t\tthis.log(`Opening ${url} using ${method}`);\n\t}\n\t/**\n\t * Mock representation of the XMLHttpRequest send method\n\t * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/send}\n\t * @param {object} body \n\t * @returns {undefined}\n\t */\n\tsend(body) {\n\t\tthis.log(`Sending with ${body}`);\n\t\tif ('function' === typeof this.listeners.load) {\n\t\t\tlet mockResponse = {\n\t\t\t\tresponse : {'mock_response' : true, 'data' : ['obj1']},\n\t\t\t\tresponseText : \"{'mock_response' : true}\",\n\t\t\t\tstatus : 200,\n\t\t\t\tstatusText : '200',\n\t\t\t\tresponseURL : '/mock-call'\n\t\t\t};\n\t\t\tObject.assign(this, mockResponse);\n\t\t\tthis.listeners.load();\n\t\t}\n\t}\n\t/**\n\t * Mock representation of the XMLHttpRequest getAllResponseHeaders method\n\t * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getAllResponseHeaders}\n\t * @returns {string} The mock headers\n\t */\n\tgetAllResponseHeaders() {\n\t\treturn \"Mock-Headers: true\";\n\t}\n\t/**\n\t * Representation of Javascript's addEventListener designed to hook into this\n\t * mock XMLHttpRequest object\n\t * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener}\n\t * @param {string} name - The name of the event to listen for\n\t * @param {function} callback - Function to call when event is triggered\n\t */\n\taddEventListener(name, callback) {\n\t\tthis.log(`${name} listener registered`);\n\t\tthis.listeners[name] = callback;\n\t}\n\t/**\n\t * Just a stub so we have a uniform interface between this and the real thing\n\t * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/setRequestHeader}\n\t * @param {string} header \n\t * @param {string} value \n\t */\n\tsetRequestHeader(header, value) {\n\t\treturn true;\n\t}\n\t/**\n\t * Helper function for logging status output based on this object's \n\t * verbosity settings (true/false)\n\t * @param {string} message \n\t */\n\tlog(message) {\n\t\tif (this.verbose === true) {\n\t\t\tconsole.log(message);\n\t\t}\n\t}\n}\n\nmodule.exports = HTTPMock;\n","const jsonpatch = require('fast-json-patch');\nconst clone = require('./utils.class').clone;\nconst noop = require('./utils.class').noop;\nconst Request = require('./request.class');\n\n/**\n * @constructor\n */\nclass Model {\n  constructor(data = {}) {\n    Object.defineProperty(this, '__config', {enumerable : false, writable : true});\n    Object.defineProperty(this, '__response', {enumerable : false, writable : true});\n    Object.defineProperty(this, '__original', {value : data, writable : true});\n    Object.defineProperty(this, '__revision', {value : Date.now(), writable : true});\n\n    Object.assign(this, clone(data));\n  }\n  /**\n   * Persists this model back to the api\n   * @param {function=} cb - Callback to invoke on completion (failure or success)\n   * @returns {Request}\n   */\n  save(cb = noop) {\n    let headers = {};\n    try {\n      headers = this.__config.api().commonHeaders();\n    } catch(e) {\n      //ignore\n    }\n\n    let method = this.id ? 'put' : 'post';\n    let instance = this;\n\n    let request = new Request()\n      .url(this.makeHref())\n      .method(method)\n      .headers(headers)\n      .body(this)\n      .exec()\n      .then((response) => {\n        Object.assign(instance, clone(response.data));\n        instance.__revision = Date.now();\n        instance.__response = response;\n        instance.makeClean();\n        cb();\n        return instance;\n      }).catch(err => {\n        cb(err);\n        throw err;\n      });\n\n    return request;\n  }\n\n  /**\n   * Gets a list of changes that have occured since the last get/save\n   * @returns {Request}\n   */\n  changes() {\n    let headers = this.__config.api().commonHeaders();\n    let targetUrl = this['@changes'];\n    let request = new Request()\n      .url(targetUrl)\n      .query({search : {since : this.__revision}})\n      .method('get')\n      .headers(headers)\n      .exec();\n    return request;\n  }\n\n  /**\n   * Starts listening for changes and calls onChange whenever they are detected\n   * @param {function} onChange - Function to call when changes detected\n   * @param {number} refreshRate - the duration (in milliseconds) between checks\n   * @returns {this}\n   */\n  subscribe(onChange, ttl = 3000) {\n    setInterval(() => {\n      this.changes().then(changeList => {\n        if (changeList && changeList.length) {\n          this.__revision = Date.now();\n          onChange(changeList, Date.now());\n        }\n      });\n    },ttl);\n\n    return this;\n  }\n\n  /**\n   * Puts only the changes (in patch notation) back to the api. The\n   * server-side endpoint must support PATCH\n   * @returns {Request}\n   */\n  update() {\n    //use patch\n    let headers = this.__config.api().commonHeaders();\n\n    let patches = this.getDiffs();\n    let targetUrl = this.makeHref();\n    let instance = this;\n    let request = new Request()\n      .url(targetUrl)\n      .method('patch')\n      .headers(headers)\n      .body(patches)\n      .exec()\n      .then((response) => {\n        Object.assign(instance, clone(response.data));\n        instance.__revision = Date.now();\n        instance.__response = response;\n        instance.makeClean();\n      });\n    return request;\n  }\n\n  /**\n   * Sets the underlying API config\n   * @param {EndpointConfig} endpointConfig\n   */\n  config(endpointConfig = {}) {\n    this.__config = endpointConfig;\n  }\n\n  makeHref() {\n    let correctHref;\n    if ('object' === typeof this.__config) {\n      correctHref = this.__config.baseUrl() + '/' + this.__config.url() + '/';\n      if ('string' === typeof this.id ) {\n        correctHref += this.id;\n      }\n    } else {\n      correctHref = '/__unit_test__';\n    }\n    return correctHref;\n  }\n\n  /**\n   * Returns a list of diffs comparing this version to the last\n   * synced version from the server\n   * @private\n   * @returns {object[]} Array of changes\n   */\n  getDiffs() {\n    return jsonpatch.compare(this.__original, this);\n  }\n  /**\n   * Returns the current status of this model\n   * @returns {boolean}\n   */\n  isDirty() {\n    return this.getDiffs().length > 0;\n  }\n  /**\n   * Clears out the change history and syncs the underlying original version\n   * to the current version\n   * @returns {undefined}\n   */\n  makeClean() {\n    this.__original = clone(this);\n  }\n\n  /**\n   * Removes this modal from the api\n   * @param {function=} cb - Function to call on completetion (success or failure)\n   * @returns {Request}\n   */\n  remove(cb = noop) {\n    let headers = {};\n    try {\n      headers = this.__config.api().commonHeaders();\n    } catch(e) {}\n\n    let targetUrl = this.makeHref();\n    let instance = this;\n\n    let request = new Request()\n      .url(targetUrl)\n      .method('delete')\n      .headers(headers)\n      .exec()\n      .then((response) => {\n        instance.__response = response;\n        return cb();\n      }).catch(err => {\n        cb(err);\n        throw err;\n      });\n    return request;\n  }\n\n}\n\nmodule.exports = Model;\n","const Transport = require('./transport.class.js');\nconst clone = require('./utils.class').clone;\n\n/**\n * @constructor\n * @param {object=} config\n */\nclass Request {\n  constructor(config = {}) {\n    var defaults = {\n      method: 'GET',\n      url: '/',\n      headers: {},\n      data: undefined,\n      responseType : 'application/json',\n      params : {}\n    };\n    this.config = {};\n    Object.assign(this.config, defaults, config);\n  }\n  /**\n   * Executes the current request using the underlying transport mechanism (ie http)\n   * @returns {Promise}\n   */\n  exec() {\n    let originalRequest = this;\n    let Promise = require('./settings').getPromise();\n    return new Promise((resolve, reject) => {\n      originalRequest.transport = new Transport(originalRequest);\n\n      originalRequest.transport\n      .exec()\n      .then(function successCallback(response) {\n        response.data = clone(response.response);\n        // originalRequest.response = response;\n        response.request = originalRequest;\n        return resolve(response);\n      }, function errorCallback(response) {\n        // originalRequest.response = response;\n        response.request = originalRequest;        \n        return reject(response);\n      });\n    });\n  }\n  /**\n   * Gets / sets the query object to use\n   * @param {object=} newQuery \n   * @returns {(this | object)}\n   */\n  query(newQuery) {\n    if ('undefined' !== typeof newQuery) {\n      if ('object' === typeof newQuery && newQuery !== null) {\n        newQuery = clone(newQuery);\n      }\n      this.config.params = newQuery;\n      return this;\n    } else {\n      return this.config.params;\n    }\n  }\n  \n  /**\n   * Gets / sets the http verb (method) to use (ie get,put,post, etc)\n   * @param {string=} newMethod \n   * @returns {(this | string)}\n   */\n  method(newMethod) {\n    if ('undefined' !== typeof newMethod) {\n      if ('string' === typeof newMethod) {\n        this.config.method = newMethod;\n      }\n      return this;\n    } else {\n      return this.config.method;\n    }\n  }\n  \n  /**\n   * Gets / sets the target url to make the request to\n   * @param {string=} newUrl \n   * @returns {(this | string)}\n   */\n  url(newUrl) {\n    if ('undefined' !== typeof newUrl) {\n      if ('string' === typeof newUrl) {\n        this.config.url = newUrl;\n      }\n      return this;\n    } else {\n      return this.config.url;\n    }\n  }\n\n  /**\n   * Gets / sets headers (key / value pairs ) to use for the request\n   * @param {object=} newHeaderObj \n   * @returns {(this | object)}\n   */\n  headers(newHeaderObj) {\n    if ('undefined' !== typeof newHeaderObj) {\n      if ('object' === typeof newHeaderObj && newHeaderObj !== null) {\n        this.config.headers = clone(newHeaderObj);\n      }\n      return this;\n    } else {\n      return this.config.headers;\n    }\n  }\n\n  /**\n   * Gets / sets the request body\n   * @param {object=} newBody \n   * @returns {(this | object | undefined)}\n   */\n  body(newBody) {\n    if ('undefined' !== typeof newBody) {\n      if ('object' === typeof newBody && newBody !== null) {\n        this.config.data = clone(newBody);\n      }\n      return this;\n    } else {\n      return this.config.data;\n    }\n  }\n  /**\n   * Gets or sets the response type for the request\n   * @param {string=} newType \n   * @returns {(this | string)}\n   */\n  mediaType(newType) {\n    if ('undefined' !== typeof newType) {\n      if ('string' === typeof newType) {\n        this.config.responseType = newType;\n      }\n      return this;\n    }\n    return this.config.responseType;\n  }\n\n  /**\n   * Returns a copy of this request's configurations\n   * @returns {object}\n   */\n  toJSON() {\n    return JSON.parse( JSON.stringify(this.config) );\n  }\n}\n\nmodule.exports = Request;\n","/**\n * Reference point for all of the sdk modules to find common\n * settings, such as what promise to use\n * @singleton\n * @namespace OfficeBotSDK.Settings\n */\nlet settings = {\n  _p : Promise,\n  setPromiseLib : function(p) {\n    this._p = p;\n  },\n  getPromise : function() {\n    return this._p;\n  }\n};\n\nmodule.exports = settings;","const clone = require('./utils.class').clone;\nconst querystring = require('querystring');\n\n/**\n * @constructor\n */\nclass Transport {\n\tconstructor(request) {\n\t\tif ('undefined' !== typeof window && window.XMLHttpRequest) {\n\t\t\tthis.HTTPRequest = window.XMLHttpRequest;\n\t\t} else {\n\t\t\tthis.HTTPRequest = require('./http-mock.class.js'); //used for Node based tests\n\t\t}\n\t\tthis.setRequest(request);\n\t}\n\t/**\n\t * Stores the request object for use later (ie when .exec() gets called). Helpfull \n\t * if building the transport request up instead of passing everything into constructor.\n\t * @param {Request} request \n\t * @returns {this}\n\t */\n\tsetRequest(request) {\n\t\tthis.request = clone(request);\n\t\treturn this;\n\t}\n\t/**\n\t * Makes the actual api call using the Request object that was passed into the constructor \n\t * or added using the setRequest method.\n\t * @returns {Promise}\n\t */\n\texec() {\n\t\tlet Promise = require('./settings').getPromise();\t\t\n\t\tlet instance = this;\n\t\t\n\t\treturn new Promise((resolve, reject) => {\n\t\t\t\n\t\t\tlet httpInstance = new instance.HTTPRequest();\n\t\t\tlet url = instance.request.url() ;\n\n\t\t\tlet query = querystring.stringify(instance.request.query());\n\t\t\tif (query && query.length) {\n\t\t\t\turl = url + '?' + query;\n\t\t\t}\n\t\t\tlet body = instance.request.body();\n\t\t\tif ('object' === typeof body) {\n\t\t\t\tbody = JSON.stringify(body);\n\t\t\t}\n\t\t\t\n\t\t\thttpInstance.addEventListener(\"load\", transferComplete);\n\t\t\thttpInstance.addEventListener(\"error\", transferFailed);\n\t\t\thttpInstance.addEventListener(\"abort\", transferAborted);\n\t\t\thttpInstance.open( instance.request.method().toUpperCase(), url );\n\t\t\thttpInstance.responseType = 'json';\n\t\t\t\n\t\t\tlet headers = instance.request.headers();\n\t\t\thttpInstance.setRequestHeader(\"Content-Type\", instance.request.mediaType());\t\n\t\t\t\n\t\t\tfor ( let headerName in headers ) {\n\t\t\t\thttpInstance.setRequestHeader(headerName, headers[headerName]);\n\t\t\t}\n\t\t\thttpInstance.send( body );\n\n\t\t\t/**\n\t\t\t\t* Handler:Aborted\n\t\t\t\t*/\n\t\t\tfunction transferAborted() {\n\t\t\t\tlet failed = new Error('Transfer cancelled.');\n\t\t\t\treject(failed);\n\t\t\t}\n\t\t\t/**\n\t\t\t\t* Handler:Failed\n\t\t\t\t*/\n\t\t\tfunction transferFailed(e) {\n\t\t\t\treject(httpInstance);\n\t\t\t}\n\t\t\t/**\n\t\t\t\t* Handler:Finished\n\t\t\t\t*/\n\t\t\tfunction transferComplete() {\t\n\t\t\t\tif (httpInstance.status < 400) {\n\t\t\t\t\tresolve(httpInstance);\n\t\t\t\t} else {\n\t\t\t\t\treject(httpInstance);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n\nmodule.exports = Transport;\n","/**\n * @constructor\n * @param {string[]} args \n */\nclass URLBuilder {\n  constructor(args = []) {\n    if (!args || 'function' !== typeof args.join) {\n      throw new Error('URL Builder requires param 1 to be an array.');\n    }\n    this.target = args.filter(item => {\n      return item !== '/';\n    }).join('/') || \"/\";\n  }\n  /**\n   * @returns {string} url\n   */\n  toString() {\n    return this.target || '';\n  }\n}\n\nmodule.exports = URLBuilder;","var clone_lib = require('clone');\n\n/**\n * @constructor\n */\nclass Utils {\n    constructor() {\n\n    }\n    /**\n     * Does nothing\n     * @returns {undefined}\n     */\n    static noop() {\n\n    }\n\n    /**\n     * Creates a deep copy of the passed in object\n     * @param {object} obj - Object to copy\n     * @returns {object} Copied object\n     */\n    static clone(obj) {\n        return obj;\n        // return clone_lib(obj);\n        // return privateClone(obj);\n    }\n}\n/**\n * Allows our static method to call this recursively\n * @param {object} obj\n * @private\n * @returns {object} Copied object \n */\nfunction privateClone(obj) {\n   if(obj === null || typeof(obj) != 'object') {\n      return obj;\n   }\n   var temp = new obj.constructor();\n   for(var key in obj) {\n      temp[key] = privateClone(obj[key]);\n   }\n   return temp;\n}\n\nmodule.exports = Utils;"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJpbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Nsb25lL2Nsb25lLmpzIiwibm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9saWIvaXNfYXJndW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvbGliL2tleXMuanMiLCJub2RlX21vZHVsZXMvZmFzdC1qc29uLXBhdGNoL2xpYi9jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtanNvbi1wYXRjaC9saWIvZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtanNvbi1wYXRjaC9saWIvaGVscGVycy5qcyIsIm5vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9kZWNvZGUuanMiLCJub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCJzcmMvYXBpLWNvbmZpZy5jbGFzcy5qcyIsInNyYy9jYWNoZS5jbGFzcy5qcyIsInNyYy9lbmRwb2ludC1jb25maWcuY2xhc3MuanMiLCJzcmMvZW5kcG9pbnQuY2xhc3MuanMiLCJzcmMvaHR0cC1tb2NrLmNsYXNzLmpzIiwic3JjL21vZGVsLmNsYXNzLmpzIiwic3JjL3JlcXVlc3QuY2xhc3MuanMiLCJzcmMvc2V0dGluZ3MuanMiLCJzcmMvdHJhbnNwb3J0LmNsYXNzLmpzIiwic3JjL3VybC1idWlsZGVyLmNsYXNzLmpzIiwic3JjL3V0aWxzLmNsYXNzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUNBQTs7OztBQUlBLElBQUksTUFBTyxVQUFTLE9BQVQsRUFBa0I7O0FBRTNCLE1BQUksV0FBVyxRQUFRLG1CQUFSLENBQWY7QUFDQSxXQUFTLGFBQVQsQ0FBdUIsT0FBdkI7O0FBRUEsTUFBSSxVQUFVO0FBQ1osU0FBa0IsUUFBUSx3QkFBUixDQUROO0FBRVosV0FBa0IsUUFBUSxtQkFBUixDQUZOO0FBR1osb0JBQWtCLFFBQVEsNkJBQVIsQ0FITjtBQUlaLGNBQWtCLFFBQVEsc0JBQVIsQ0FKTjtBQUtaLGNBQWtCLFFBQVEsdUJBQVIsQ0FMTjtBQU1aLFdBQWtCLFFBQVEsbUJBQVIsQ0FOTjtBQU9aLGFBQWtCLFFBQVEscUJBQVIsQ0FQTjtBQVFaLGNBQWtCLFFBUk47QUFTWixjQUFrQixRQUFRLHVCQUFSLENBVE47QUFVWixnQkFBa0IsUUFBUSx5QkFBUixDQVZOO0FBV1osV0FBa0IsUUFBUSxtQkFBUjtBQVhOLEdBQWQ7O0FBY0EsU0FBTyxPQUFQO0FBRUQsQ0FyQlMsQ0FxQlAsT0FyQk8sQ0FBVjs7QUF1QkEsT0FBTyxPQUFQLEdBQWlCLEdBQWpCOzs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDSkEsSUFBTSxpQkFBaUIsUUFBUSw0QkFBUixDQUF2QjtBQUNBLElBQU0sV0FBVyxRQUFRLHFCQUFSLENBQWpCO0FBQ0EsSUFBTSxRQUFRLFFBQVEsZUFBUixDQUFkO0FBQ0EsSUFBTSxRQUFRLFFBQVEsZUFBUixFQUF5QixLQUF2Qzs7QUFFQTs7Ozs7SUFJTSxTO0FBQ0osdUJBQWM7QUFBQTs7QUFDWixTQUFLLE1BQUwsR0FBYyxFQUFFLFNBQVUsRUFBWixFQUFnQixLQUFNLEVBQXRCLEVBQWQ7QUFDQSxTQUFLLFNBQUwsR0FBaUIsRUFBakI7QUFDQSxTQUFLLEtBQUwsR0FBYSxJQUFJLEtBQUosRUFBYjtBQUNEO0FBQ0Q7Ozs7Ozs7Ozs0QkFLUSxHLEVBQUs7QUFDWCxVQUFJLGdCQUFnQixPQUFPLEdBQTNCLEVBQWdDO0FBQzlCLFlBQUksYUFBYSxPQUFPLEdBQXhCLEVBQTZCO0FBQzNCLGVBQUssTUFBTCxDQUFZLEdBQVosR0FBa0IsR0FBbEI7QUFDRDtBQUNELGVBQU8sSUFBUDtBQUNEO0FBQ0QsYUFBTyxLQUFLLE1BQUwsQ0FBWSxHQUFuQjtBQUNEO0FBQ0Q7Ozs7Ozs7OytCQUt1QztBQUFBLFVBQTlCLFlBQThCLHVFQUFmLGFBQWU7O0FBQ3JDLFVBQUksU0FBUyxJQUFJLGNBQUosR0FBcUIsR0FBckIsQ0FBeUIsSUFBekIsQ0FBYjtBQUNBLFdBQU0sWUFBTixJQUF1QixJQUFJLFFBQUosQ0FBYSxNQUFiLENBQXZCO0FBQ0EsYUFBTyxLQUFNLFlBQU4sQ0FBUDtBQUNEO0FBQ0Q7Ozs7Ozs7O2tDQUtjLE8sRUFBUztBQUNyQixVQUFJLGdCQUFnQixPQUFPLE9BQTNCLEVBQW9DO0FBQ2xDLGFBQUssTUFBTCxDQUFZLE9BQVosR0FBc0IsT0FBdEI7QUFDQSxlQUFPLElBQVA7QUFDRCxPQUhELE1BR087QUFDTCxlQUFPLE1BQU0sS0FBSyxNQUFMLENBQVksT0FBbEIsQ0FBUDtBQUNEO0FBQ0Y7Ozs7OztBQUdILE9BQU8sT0FBUCxHQUFpQixTQUFqQjs7Ozs7Ozs7O0FDdERBOzs7SUFHTSxLO0FBQ0o7OztBQUdBLG1CQUFjO0FBQUE7O0FBQ1osU0FBSyxPQUFMLEdBQWUsSUFBSSxHQUFKLEVBQWY7QUFDQSxTQUFLLE1BQUwsR0FBYztBQUNaLFdBQU07QUFETSxLQUFkO0FBR0Q7QUFDRDs7Ozs7Ozs7O3dCQUtJLEksRUFBTTtBQUNSLFVBQUksTUFBTSxLQUFLLEdBQUwsRUFBVjtBQUNBLFVBQUksTUFBTSxLQUFLLE9BQUwsQ0FBYSxHQUFiLENBQWlCLElBQWpCLENBQVY7QUFDQSxVQUFJLGdCQUFnQixPQUFPLEdBQXZCLElBQThCLE1BQU0sSUFBSSxDQUFKLENBQU4sR0FBZSxLQUFLLE1BQUwsQ0FBWSxHQUE3RCxFQUFrRTtBQUNoRSxZQUFJLGVBQWUsSUFBSSxDQUFKLENBQW5CO0FBQ0EsZUFBTyxjQUFQLENBQXNCLFlBQXRCLEVBQW1DLGFBQW5DLEVBQWtELEVBQUMsT0FBUSxJQUFULEVBQWxEO0FBQ0EsZUFBTyxZQUFQO0FBQ0QsT0FKRCxNQUlPO0FBQ0wsYUFBSyxPQUFMLENBQWEsTUFBYixDQUFvQixJQUFwQixFQURLLENBQ3NCO0FBQzNCLGVBQU8sU0FBUDtBQUNEO0FBQ0Y7QUFDRDs7Ozs7Ozs7Ozt3QkFPSSxJLEVBQU0sSyxFQUFPO0FBQ2YsVUFBSSxhQUFhLE9BQU8sSUFBeEIsRUFBOEI7QUFDNUIsY0FBTSxJQUFJLEtBQUosQ0FBVSx3QkFBVixDQUFOO0FBQ0Q7QUFDRDtBQUNBLFVBQUksYUFBYSxPQUFPLEtBQXhCLEVBQStCO0FBQzdCLGdCQUFRLElBQUksTUFBSixDQUFXLEtBQVgsQ0FBUixDQUQ2QixDQUNGO0FBQzVCO0FBQ0QsVUFBSSxhQUFhLE9BQU8sS0FBeEIsRUFBK0I7QUFDN0IsZ0JBQVEsSUFBSSxNQUFKLENBQVcsS0FBWCxDQUFSLENBRDZCLENBQ0Y7QUFDNUI7QUFDRCxVQUFJLGNBQWMsT0FBTyxLQUF6QixFQUFnQztBQUM5QixnQkFBUSxJQUFJLE9BQUosQ0FBWSxLQUFaLENBQVIsQ0FEOEIsQ0FDRjtBQUM3QjtBQUNELFdBQUssT0FBTCxDQUFhLEdBQWIsQ0FBaUIsSUFBakIsRUFBdUIsQ0FBQyxLQUFLLEdBQUwsRUFBRCxFQUFhLEtBQWIsQ0FBdkI7QUFDQSxhQUFPLElBQVA7QUFDRDtBQUNEOzs7Ozs7OytCQUlXLEksRUFBTTtBQUNmLGFBQU8sS0FBSyxPQUFMLENBQWEsTUFBYixDQUFvQixJQUFwQixDQUFQO0FBQ0Q7QUFDRDs7Ozs7Ozs7MkJBS08sTSxFQUFRO0FBQ2IsVUFBSSxhQUFhLE9BQU8sTUFBeEIsRUFBZ0M7QUFDOUIsY0FBTSxJQUFJLEtBQUosQ0FBVSxtQkFBVixDQUFOO0FBQ0Q7QUFDRCxXQUFLLE1BQUwsQ0FBWSxHQUFaLEdBQWtCLE1BQWxCO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7Ozs7OztBQUlILE9BQU8sT0FBUCxHQUFpQixLQUFqQjs7Ozs7Ozs7Ozs7QUM1RUEsSUFBTSxRQUFRLFFBQVEsZUFBUixDQUFkO0FBQ0EsSUFBTSxRQUFRLFFBQVEsZUFBUixFQUF5QixLQUF2QztBQUNBOzs7O0lBR00sYztBQUNKLDRCQUF5QjtBQUFBLFFBQWIsTUFBYSx1RUFBSixFQUFJOztBQUFBOztBQUN2QixTQUFLLE1BQUwsR0FBYyxFQUFFLEtBQU0sRUFBUixFQUFkOztBQUVBLFFBQUksV0FBVztBQUNiLGFBQVEsR0FESztBQUViLHNCQUFpQixrQkFGSjtBQUdiLHNCQUFpQjtBQUhKLEtBQWY7QUFLQSxXQUFPLE1BQVAsQ0FBYyxLQUFLLE1BQW5CLEVBQTJCLFFBQTNCLEVBQXFDLE1BQU0sTUFBTixDQUFyQztBQUNEOztBQUVEOzs7Ozs7Ozs7OzhCQU1VLE8sRUFBUztBQUNqQixVQUFJLGdCQUFnQixPQUFPLE9BQTNCLEVBQW9DO0FBQ2xDLFlBQUksYUFBYSxPQUFPLE9BQXhCLEVBQWlDO0FBQy9CLGVBQUssTUFBTCxDQUFZLFlBQVosR0FBMkIsT0FBM0I7QUFDRDtBQUNELGVBQU8sSUFBUDtBQUNEO0FBQ0QsYUFBTyxLQUFLLE1BQUwsQ0FBWSxZQUFuQjtBQUNEOztBQUVEOzs7Ozs7Ozs7d0JBTUksTSxFQUFRO0FBQ1YsVUFBSSxnQkFBZ0IsT0FBTyxNQUEzQixFQUFtQztBQUNqQyxZQUFJLHFCQUFvQixNQUFwQix5Q0FBb0IsTUFBcEIsTUFBOEIsV0FBVyxJQUE3QyxFQUFtRDtBQUNqRCxlQUFLLE1BQUwsQ0FBWSxHQUFaLEdBQWtCLE1BQU0sTUFBTixDQUFsQjtBQUNEO0FBQ0QsZUFBTyxJQUFQO0FBQ0Q7QUFDRCxhQUFPLEtBQUssTUFBTCxDQUFZLEdBQW5CO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OEJBSVU7QUFDUixVQUFJLENBQUMsS0FBSyxNQUFMLENBQVksR0FBYixJQUFvQixDQUFDLEtBQUssTUFBTCxDQUFZLEdBQVosQ0FBZ0IsT0FBekMsRUFBa0Q7QUFDaEQsZUFBTyxFQUFQO0FBQ0Q7QUFDRCxhQUFPLEtBQUssTUFBTCxDQUFZLEdBQVosQ0FBZ0IsT0FBaEIsRUFBUDtBQUNEO0FBQ0Q7Ozs7Ozs7O3dCQUtJLE0sRUFBUTtBQUNWLFVBQUksZ0JBQWdCLE9BQU8sTUFBM0IsRUFBbUM7QUFDakMsWUFBSSxhQUFhLE9BQU8sTUFBeEIsRUFBZ0M7QUFDOUIsZUFBSyxNQUFMLENBQVksR0FBWixHQUFrQixNQUFsQjtBQUNEO0FBQ0QsZUFBTyxJQUFQO0FBQ0Q7QUFDRCxhQUFPLEtBQUssTUFBTCxDQUFZLEdBQW5CO0FBQ0Q7QUFDRDs7Ozs7Ozs7MEJBS00sSyxFQUFPO0FBQ1gsVUFBSSxnQkFBZ0IsT0FBTyxLQUEzQixFQUFrQztBQUNoQyxZQUFJLGVBQWUsT0FBTyxLQUExQixFQUFpQztBQUMvQixlQUFLLE1BQUwsQ0FBWSxZQUFaLEdBQTJCLEtBQTNCO0FBQ0Q7QUFDRCxlQUFPLElBQVA7QUFDRDtBQUNELGFBQU8sS0FBSyxNQUFMLENBQVksWUFBbkI7QUFDRDs7Ozs7O0FBSUgsT0FBTyxPQUFQLEdBQWlCLGNBQWpCOzs7Ozs7Ozs7OztBQzFGQSxJQUFNLGFBQWEsUUFBUSxxQkFBUixDQUFuQjtBQUNBLElBQU0sVUFBVSxRQUFRLGlCQUFSLENBQWhCO0FBQ0EsSUFBTSxRQUFRLFFBQVEsZUFBUixFQUF5QixLQUF2QztBQUNBLElBQU0sT0FBTyxRQUFRLGVBQVIsRUFBeUIsSUFBdEM7O0FBRUE7Ozs7O0lBSU0sUTtBQUNKLHNCQUFpQztBQUFBLFFBQXJCLGNBQXFCLHVFQUFKLEVBQUk7O0FBQUE7O0FBQy9CLFFBQUksQ0FBQyxjQUFELElBQW1CLGVBQWUsT0FBTyxlQUFlLEtBQTVELEVBQW1FO0FBQ2pFLFlBQU0sSUFBSSxLQUFKLENBQVUsaUNBQVYsQ0FBTjtBQUNEO0FBQ0QsU0FBSyxjQUFMLEdBQXNCLE1BQU0sY0FBTixDQUF0QjtBQUNBLFNBQUssTUFBTCxHQUFjO0FBQ1osc0JBQWlCLElBREw7QUFFWixjQUFTLEtBRkc7QUFHWixjQUFTLEVBSEc7QUFJWixhQUFRO0FBSkksS0FBZDtBQU1BLFNBQUssS0FBTCxHQUFhLEtBQUssY0FBTCxDQUFvQixHQUFwQixHQUEwQixLQUF2QztBQUNEO0FBQ0Q7Ozs7Ozs7OztnQ0FLcUI7QUFBQSxVQUFYLElBQVcsdUVBQUosRUFBSTs7QUFDbkIsVUFBSSxPQUFPLElBQUksVUFBSixDQUFlLENBQ3hCLEtBQUssY0FBTCxDQUFvQixPQUFwQixFQUR3QixFQUV4QixLQUFLLGNBQUwsQ0FBb0IsR0FBcEIsRUFGd0IsQ0FBZixDQUFYO0FBSUEsV0FBSyxPQUFMLElBQWdCLElBQWhCO0FBQ0EsVUFBSSxlQUFlLEtBQUssY0FBTCxDQUFvQixLQUFwQixFQUFuQjtBQUNBLFVBQUksV0FBVyxJQUFJLFlBQUosQ0FBaUIsSUFBakIsQ0FBZjtBQUNBLGVBQVMsTUFBVCxDQUFnQixLQUFLLGNBQXJCO0FBQ0EsYUFBTyxRQUFQO0FBQ0Q7QUFDRDs7Ozs7Ozs7OzBCQU1NLFksRUFBYztBQUNsQixVQUFJLGdCQUFnQixPQUFPLFlBQTNCLEVBQXlDO0FBQ3ZDLGFBQUssY0FBTCxDQUFvQixLQUFwQixDQUEwQixZQUExQjtBQUNBLGVBQU8sSUFBUDtBQUNEO0FBQ0QsYUFBTyxLQUFLLGNBQUwsQ0FBb0IsS0FBcEIsRUFBUDtBQUNEO0FBQ0Q7Ozs7Ozs7O3dCQUtJLE0sRUFBUTtBQUNWLFVBQUksZ0JBQWdCLE9BQU8sTUFBM0IsRUFBbUM7QUFDakMsYUFBSyxjQUFMLENBQW9CLEdBQXBCLENBQXdCLE1BQXhCO0FBQ0EsZUFBTyxJQUFQO0FBQ0Q7QUFDRCxhQUFPLEtBQUssY0FBTCxDQUFvQixHQUFwQixFQUFQO0FBQ0Q7QUFDRDs7Ozs7Ozs7NkJBS1MsRSxFQUFJO0FBQ1gsVUFBSSxhQUFhLE9BQU8sRUFBeEIsRUFBNEI7QUFDMUIsY0FBTSxJQUFJLEtBQUosQ0FBVSwwQkFBVixDQUFOO0FBQ0Q7QUFDRCxXQUFLLE1BQUwsQ0FBWSxNQUFaLEdBQXFCLElBQUksVUFBSixDQUFlLENBQ2xDLEtBQUssY0FBTCxDQUFvQixPQUFwQixFQURrQyxFQUVsQyxLQUFLLGNBQUwsQ0FBb0IsR0FBcEIsRUFGa0MsRUFHbEMsRUFIa0MsQ0FBZixDQUFyQjtBQUtBLFdBQUssTUFBTCxDQUFZLE1BQVosR0FBcUIsS0FBckI7QUFDQSxhQUFPLElBQVA7QUFDRDtBQUNEOzs7Ozs7Ozt5QkFLSyxLLEVBQU87QUFDVixXQUFLLE1BQUwsQ0FBWSxNQUFaLEdBQXFCLElBQUksVUFBSixDQUFlLENBQ2xDLEtBQUssY0FBTCxDQUFvQixPQUFwQixFQURrQyxFQUVsQyxLQUFLLGNBQUwsQ0FBb0IsR0FBcEIsRUFGa0MsQ0FBZixDQUFyQjtBQUlBLFdBQUssTUFBTCxDQUFZLE1BQVosR0FBcUIsS0FBckI7QUFDQSxXQUFLLE1BQUwsQ0FBWSxLQUFaLENBQWtCLE1BQWxCLEdBQTJCLEtBQUssU0FBTCxDQUFlLEtBQWYsQ0FBM0I7QUFDQSxhQUFPLElBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7OzJCQU1PLEssRUFBTztBQUNaLFdBQUssTUFBTCxDQUFZLE1BQVosR0FBcUIsSUFBSSxVQUFKLENBQWUsQ0FDbEMsS0FBSyxjQUFMLENBQW9CLE9BQXBCLEVBRGtDLEVBRWxDLEtBQUssY0FBTCxDQUFvQixHQUFwQixFQUZrQyxDQUFmLENBQXJCO0FBSUEsV0FBSyxNQUFMLENBQVksTUFBWixHQUFxQixRQUFyQjtBQUNBLFdBQUssTUFBTCxDQUFZLEtBQVosQ0FBa0IsTUFBbEIsR0FBMkIsS0FBSyxTQUFMLENBQWUsS0FBZixDQUEzQjtBQUNBLGFBQU8sSUFBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7O3NDQU9rQixFLEVBQUksSSxFQUFNO0FBQzFCLFVBQUksYUFBYSxPQUFPLEVBQXhCLEVBQTRCO0FBQzFCLGNBQU0sSUFBSSxLQUFKLENBQVUsMEJBQVYsQ0FBTjtBQUNEO0FBQ0QsVUFBSSxxQkFBb0IsSUFBcEIseUNBQW9CLElBQXBCLEVBQUosRUFBOEI7QUFDNUIsY0FBTSxJQUFJLEtBQUosQ0FBVSxxQkFBVixDQUFOO0FBQ0Q7QUFDRCxXQUFLLE1BQUwsQ0FBWSxNQUFaLEdBQXFCLElBQUksVUFBSixDQUFlLENBQ2xDLEtBQUssY0FBTCxDQUFvQixPQUFwQixFQURrQyxFQUVsQyxLQUFLLGNBQUwsQ0FBb0IsR0FBcEIsRUFGa0MsRUFHbEMsRUFIa0MsQ0FBZixDQUFyQjtBQUtBLFdBQUssTUFBTCxDQUFZLElBQVosR0FBbUIsSUFBbkI7QUFDQSxXQUFLLE1BQUwsQ0FBWSxNQUFaLEdBQXFCLEtBQXJCO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztzQ0FNa0IsRSxFQUFJO0FBQ3BCLFVBQUksYUFBYSxPQUFPLEVBQXhCLEVBQTRCO0FBQzFCLGNBQU0sSUFBSSxLQUFKLENBQVUsMEJBQVYsQ0FBTjtBQUNEO0FBQ0QsV0FBSyxNQUFMLENBQVksTUFBWixHQUFxQixJQUFJLFVBQUosQ0FBZSxDQUNsQyxLQUFLLGNBQUwsQ0FBb0IsT0FBcEIsRUFEa0MsRUFFbEMsS0FBSyxjQUFMLENBQW9CLEdBQXBCLEVBRmtDLEVBR2xDLEVBSGtDLENBQWYsQ0FBckI7QUFLQSxXQUFLLE1BQUwsQ0FBWSxNQUFaLEdBQXFCLFFBQXJCO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OzttQ0FNZSxLLEVBQU87QUFDcEIsVUFBSSxnQkFBZ0IsT0FBTyxLQUEzQixFQUFrQztBQUNoQyxZQUFJLGNBQWMsT0FBTyxLQUF6QixFQUFnQztBQUM5QixlQUFLLE1BQUwsQ0FBWSxjQUFaLEdBQTZCLEtBQTdCO0FBQ0Q7QUFDRCxlQUFPLElBQVA7QUFDRDtBQUNELGFBQU8sS0FBSyxNQUFMLENBQVksY0FBbkI7QUFDRDs7QUFFRDs7Ozs7Ozs7MkJBS2dCO0FBQUE7O0FBQUEsVUFBWCxFQUFXLHVFQUFOLElBQU07O0FBQ2QsVUFBSSxpQkFBaUIsS0FBSyxjQUFMLEVBQXJCO0FBQ0EsVUFBSSxtQkFBbUIsS0FBSyxjQUFMLENBQW9CLEtBQXBCLEVBQXZCO0FBQ0EsVUFBSSxpQkFBaUIsS0FBSyxjQUExQjs7QUFFQSxVQUFJLFVBQVUsRUFBZDtBQUNBLFVBQUk7QUFDRixrQkFBVSxLQUFLLGNBQUwsQ0FBb0IsR0FBcEIsR0FBMEIsYUFBMUIsRUFBVjtBQUNELE9BRkQsQ0FFRSxPQUFNLENBQU4sRUFBUztBQUNUO0FBQ0Q7QUFDRCxhQUFPLE1BQVAsQ0FBYyxPQUFkLEVBQXVCLEtBQUssTUFBTCxDQUFZLE9BQW5DOztBQUVBLFVBQUksVUFBVSxJQUFJLE9BQUosR0FDWCxNQURXLENBQ0osS0FBSyxNQUFMLENBQVksTUFEUixFQUVYLElBRlcsQ0FFTixLQUFLLE1BQUwsQ0FBWSxJQUFaLElBQW9CLEVBRmQsRUFHWCxLQUhXLENBR0wsS0FBSyxNQUFMLENBQVksS0FBWixJQUFxQixFQUhoQixFQUlYLE9BSlcsQ0FJSCxXQUFXLEVBSlIsRUFLWCxHQUxXLENBS1AsS0FBSyxNQUFMLENBQVksTUFBWixDQUFtQixRQUFuQixFQUxPLENBQWQ7O0FBT0EsVUFBSSxVQUFVLFFBQVEsWUFBUixFQUFzQixVQUF0QixFQUFkOztBQUVBLGFBQU8sSUFBSSxPQUFKLENBQVksVUFBQyxPQUFELEVBQVUsTUFBVixFQUFxQjtBQUN0QyxZQUFJLE1BQUssUUFBTCxFQUFKLEVBQXFCO0FBQ25CLGNBQUksZUFBZSxNQUFNLEdBQU4sQ0FBVSxRQUFRLEdBQVIsRUFBVixDQUFuQjtBQUNBLGNBQUksZ0JBQWdCLGNBQXBCLEVBQW9DO0FBQ2xDLGVBQUcsSUFBSCxFQUFTLFlBQVQ7QUFDQSxtQkFBTyxRQUFRLFlBQVIsQ0FBUDtBQUNEO0FBQ0Y7QUFDRDtBQUNBLGdCQUFRLElBQVIsR0FBZSxJQUFmLENBQW9CLG9CQUFZO0FBQzlCLGNBQUksT0FBTyxTQUFTLElBQXBCO0FBQ0EsY0FBSSxjQUFKOztBQUVBLGNBQUksTUFBTSxPQUFOLENBQWMsSUFBZCxDQUFKLEVBQXlCO0FBQ3ZCLG9CQUFRLEtBQUssR0FBTCxDQUFTLFVBQUMsSUFBRCxFQUFVO0FBQ3pCLGtCQUFJLFFBQVEsSUFBSSxnQkFBSixDQUFxQixJQUFyQixDQUFaO0FBQ0Esb0JBQU0sTUFBTixDQUFhLGNBQWI7QUFDQSxxQkFBTyxjQUFQLENBQXNCLEtBQXRCLEVBQTZCLFdBQTdCLEVBQTBDLEVBQUUsT0FBUSxNQUFNLE9BQU4sQ0FBVixFQUEwQixZQUFhLEtBQXZDLEVBQTFDO0FBQ0EscUJBQU8sS0FBUDtBQUNELGFBTE8sQ0FBUjtBQU1ELFdBUEQsTUFPTztBQUNMLG9CQUFRLElBQUksZ0JBQUosQ0FBcUIsSUFBckIsQ0FBUjtBQUNBLGtCQUFNLE1BQU4sQ0FBYSxjQUFiO0FBQ0EsbUJBQU8sY0FBUCxDQUFzQixLQUF0QixFQUE2QixXQUE3QixFQUEwQyxFQUFFLE9BQVEsTUFBTSxPQUFOLENBQVYsRUFBMEIsWUFBYSxLQUF2QyxFQUExQztBQUNEOztBQUVELGNBQUksTUFBSyxRQUFMLEVBQUosRUFBcUI7QUFDbkIsa0JBQU0sR0FBTixDQUFVLFFBQVEsR0FBUixFQUFWLEVBQXlCLEtBQXpCO0FBQ0Q7QUFDRCxhQUFHLElBQUgsRUFBUyxLQUFUO0FBQ0EsaUJBQU8sUUFBUSxLQUFSLENBQVA7QUFDRCxTQXRCRCxFQXNCRyxLQXRCSCxDQXNCUyxlQUFPO0FBQ2QsY0FBSSxNQUFLLFFBQUwsRUFBSixFQUFxQjtBQUNuQixrQkFBTSxVQUFOLENBQWlCLFFBQVEsR0FBUixFQUFqQjtBQUNEO0FBQ0QsYUFBRyxHQUFIO0FBQ0EsaUJBQU8sT0FBTyxHQUFQLENBQVA7QUFDRCxTQTVCRDtBQTZCRCxPQXRDTSxDQUFQO0FBdUNEO0FBQ0Q7Ozs7Ozs7OzsyQkFNcUI7QUFBQSxVQUFoQixVQUFnQix1RUFBSCxDQUFHOztBQUNuQixVQUFJLGFBQWEsT0FBTyxVQUF4QixFQUFvQztBQUNsQyxhQUFLLE1BQUwsQ0FBWSxLQUFaLENBQWtCLElBQWxCLEdBQXlCLFVBQXpCO0FBQ0Q7QUFDRCxhQUFPLElBQVA7QUFDRDtBQUNGOzs7Ozs7Ozs7NEJBTXdCO0FBQUEsVUFBakIsV0FBaUIsdUVBQUgsQ0FBRzs7QUFDckIsVUFBSSxhQUFhLE9BQU8sV0FBeEIsRUFBcUM7QUFDbkMsYUFBSyxNQUFMLENBQVksS0FBWixDQUFrQixLQUFsQixHQUEwQixXQUExQjtBQUNEO0FBQ0QsYUFBTyxJQUFQO0FBQ0Q7QUFDRDs7Ozs7Ozs7NkJBS29CO0FBQUEsVUFBYixNQUFhLHVFQUFKLEVBQUk7O0FBQ2xCLFVBQUksTUFBTSxPQUFOLENBQWMsTUFBZCxDQUFKLEVBQTJCO0FBQ3pCLGlCQUFTLE9BQU8sSUFBUCxDQUFZLEdBQVosQ0FBVDtBQUNEO0FBQ0QsVUFBSSxhQUFhLE9BQU8sTUFBeEIsRUFBZ0M7QUFDOUIsYUFBSyxNQUFMLENBQVksS0FBWixDQUFrQixNQUFsQixHQUEyQixNQUEzQjtBQUNEO0FBQ0QsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OytCQUtXO0FBQ1QsYUFBTyxLQUFLLEtBQUwsSUFBYyxlQUFlLE9BQU8sS0FBSyxLQUFoRDtBQUNEOzs7Ozs7QUFHSCxPQUFPLE9BQVAsR0FBaUIsUUFBakI7Ozs7Ozs7OztBQy9SQTs7O0lBR00sUTtBQUNMLHFCQUE2QjtBQUFBLE1BQWpCLE9BQWlCLHVFQUFQLEtBQU87O0FBQUE7O0FBQzVCLE9BQUssU0FBTCxHQUFpQixFQUFqQjtBQUNBLE9BQUssT0FBTCxHQUFlLE9BQWY7QUFDQTtBQUNEOzs7Ozs7Ozs7Ozt1QkFPSyxNLEVBQVEsRyxFQUFLO0FBQ2pCLFFBQUssR0FBTCxjQUFvQixHQUFwQixlQUFpQyxNQUFqQztBQUNBO0FBQ0Q7Ozs7Ozs7Ozt1QkFNSyxJLEVBQU07QUFDVixRQUFLLEdBQUwsbUJBQXlCLElBQXpCO0FBQ0EsT0FBSSxlQUFlLE9BQU8sS0FBSyxTQUFMLENBQWUsSUFBekMsRUFBK0M7QUFDOUMsUUFBSSxlQUFlO0FBQ2xCLGVBQVcsRUFBQyxpQkFBa0IsSUFBbkIsRUFBeUIsUUFBUyxDQUFDLE1BQUQsQ0FBbEMsRUFETztBQUVsQixtQkFBZSwwQkFGRztBQUdsQixhQUFTLEdBSFM7QUFJbEIsaUJBQWEsS0FKSztBQUtsQixrQkFBYztBQUxJLEtBQW5CO0FBT0EsV0FBTyxNQUFQLENBQWMsSUFBZCxFQUFvQixZQUFwQjtBQUNBLFNBQUssU0FBTCxDQUFlLElBQWY7QUFDQTtBQUNEO0FBQ0Q7Ozs7Ozs7OzBDQUt3QjtBQUN2QixVQUFPLG9CQUFQO0FBQ0E7QUFDRDs7Ozs7Ozs7OzttQ0FPaUIsSSxFQUFNLFEsRUFBVTtBQUNoQyxRQUFLLEdBQUwsQ0FBWSxJQUFaO0FBQ0EsUUFBSyxTQUFMLENBQWUsSUFBZixJQUF1QixRQUF2QjtBQUNBO0FBQ0Q7Ozs7Ozs7OzttQ0FNaUIsTSxFQUFRLEssRUFBTztBQUMvQixVQUFPLElBQVA7QUFDQTtBQUNEOzs7Ozs7OztzQkFLSSxPLEVBQVM7QUFDWixPQUFJLEtBQUssT0FBTCxLQUFpQixJQUFyQixFQUEyQjtBQUMxQixZQUFRLEdBQVIsQ0FBWSxPQUFaO0FBQ0E7QUFDRDs7Ozs7O0FBR0YsT0FBTyxPQUFQLEdBQWlCLFFBQWpCOzs7Ozs7Ozs7OztBQzlFQSxJQUFNLFlBQVksUUFBUSxpQkFBUixDQUFsQjtBQUNBLElBQU0sUUFBUSxRQUFRLGVBQVIsRUFBeUIsS0FBdkM7QUFDQSxJQUFNLE9BQU8sUUFBUSxlQUFSLEVBQXlCLElBQXRDO0FBQ0EsSUFBTSxVQUFVLFFBQVEsaUJBQVIsQ0FBaEI7O0FBRUE7Ozs7SUFHTSxLO0FBQ0osbUJBQXVCO0FBQUEsUUFBWCxJQUFXLHVFQUFKLEVBQUk7O0FBQUE7O0FBQ3JCLFdBQU8sY0FBUCxDQUFzQixJQUF0QixFQUE0QixVQUE1QixFQUF3QyxFQUFDLFlBQWEsS0FBZCxFQUFxQixVQUFXLElBQWhDLEVBQXhDO0FBQ0EsV0FBTyxjQUFQLENBQXNCLElBQXRCLEVBQTRCLFlBQTVCLEVBQTBDLEVBQUMsWUFBYSxLQUFkLEVBQXFCLFVBQVcsSUFBaEMsRUFBMUM7QUFDQSxXQUFPLGNBQVAsQ0FBc0IsSUFBdEIsRUFBNEIsWUFBNUIsRUFBMEMsRUFBQyxPQUFRLElBQVQsRUFBZSxVQUFXLElBQTFCLEVBQTFDO0FBQ0EsV0FBTyxjQUFQLENBQXNCLElBQXRCLEVBQTRCLFlBQTVCLEVBQTBDLEVBQUMsT0FBUSxLQUFLLEdBQUwsRUFBVCxFQUFxQixVQUFXLElBQWhDLEVBQTFDOztBQUVBLFdBQU8sTUFBUCxDQUFjLElBQWQsRUFBb0IsTUFBTSxJQUFOLENBQXBCO0FBQ0Q7QUFDRDs7Ozs7Ozs7OzJCQUtnQjtBQUFBLFVBQVgsRUFBVyx1RUFBTixJQUFNOztBQUNkLFVBQUksVUFBVSxFQUFkO0FBQ0EsVUFBSTtBQUNGLGtCQUFVLEtBQUssUUFBTCxDQUFjLEdBQWQsR0FBb0IsYUFBcEIsRUFBVjtBQUNELE9BRkQsQ0FFRSxPQUFNLENBQU4sRUFBUztBQUNUO0FBQ0Q7O0FBRUQsVUFBSSxTQUFTLEtBQUssRUFBTCxHQUFVLEtBQVYsR0FBa0IsTUFBL0I7QUFDQSxVQUFJLFdBQVcsSUFBZjs7QUFFQSxVQUFJLFVBQVUsSUFBSSxPQUFKLEdBQ1gsR0FEVyxDQUNQLEtBQUssUUFBTCxFQURPLEVBRVgsTUFGVyxDQUVKLE1BRkksRUFHWCxPQUhXLENBR0gsT0FIRyxFQUlYLElBSlcsQ0FJTixJQUpNLEVBS1gsSUFMVyxHQU1YLElBTlcsQ0FNTixVQUFDLFFBQUQsRUFBYztBQUNsQixlQUFPLE1BQVAsQ0FBYyxRQUFkLEVBQXdCLE1BQU0sU0FBUyxJQUFmLENBQXhCO0FBQ0EsaUJBQVMsVUFBVCxHQUFzQixLQUFLLEdBQUwsRUFBdEI7QUFDQSxpQkFBUyxVQUFULEdBQXNCLFFBQXRCO0FBQ0EsaUJBQVMsU0FBVDtBQUNBO0FBQ0EsZUFBTyxRQUFQO0FBQ0QsT0FiVyxFQWFULEtBYlMsQ0FhSCxlQUFPO0FBQ2QsV0FBRyxHQUFIO0FBQ0EsY0FBTSxHQUFOO0FBQ0QsT0FoQlcsQ0FBZDs7QUFrQkEsYUFBTyxPQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OEJBSVU7QUFDUixVQUFJLFVBQVUsS0FBSyxRQUFMLENBQWMsR0FBZCxHQUFvQixhQUFwQixFQUFkO0FBQ0EsVUFBSSxZQUFZLEtBQUssVUFBTCxDQUFoQjtBQUNBLFVBQUksVUFBVSxJQUFJLE9BQUosR0FDWCxHQURXLENBQ1AsU0FETyxFQUVYLEtBRlcsQ0FFTCxFQUFDLFFBQVMsRUFBQyxPQUFRLEtBQUssVUFBZCxFQUFWLEVBRkssRUFHWCxNQUhXLENBR0osS0FISSxFQUlYLE9BSlcsQ0FJSCxPQUpHLEVBS1gsSUFMVyxFQUFkO0FBTUEsYUFBTyxPQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs4QkFNVSxRLEVBQXNCO0FBQUE7O0FBQUEsVUFBWixHQUFZLHVFQUFOLElBQU07O0FBQzlCLGtCQUFZLFlBQU07QUFDaEIsY0FBSyxPQUFMLEdBQWUsSUFBZixDQUFvQixzQkFBYztBQUNoQyxjQUFJLGNBQWMsV0FBVyxNQUE3QixFQUFxQztBQUNuQyxrQkFBSyxVQUFMLEdBQWtCLEtBQUssR0FBTCxFQUFsQjtBQUNBLHFCQUFTLFVBQVQsRUFBcUIsS0FBSyxHQUFMLEVBQXJCO0FBQ0Q7QUFDRixTQUxEO0FBTUQsT0FQRCxFQU9FLEdBUEY7O0FBU0EsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OzZCQUtTO0FBQ1A7QUFDQSxVQUFJLFVBQVUsS0FBSyxRQUFMLENBQWMsR0FBZCxHQUFvQixhQUFwQixFQUFkOztBQUVBLFVBQUksVUFBVSxLQUFLLFFBQUwsRUFBZDtBQUNBLFVBQUksWUFBWSxLQUFLLFFBQUwsRUFBaEI7QUFDQSxVQUFJLFdBQVcsSUFBZjtBQUNBLFVBQUksVUFBVSxJQUFJLE9BQUosR0FDWCxHQURXLENBQ1AsU0FETyxFQUVYLE1BRlcsQ0FFSixPQUZJLEVBR1gsT0FIVyxDQUdILE9BSEcsRUFJWCxJQUpXLENBSU4sT0FKTSxFQUtYLElBTFcsR0FNWCxJQU5XLENBTU4sVUFBQyxRQUFELEVBQWM7QUFDbEIsZUFBTyxNQUFQLENBQWMsUUFBZCxFQUF3QixNQUFNLFNBQVMsSUFBZixDQUF4QjtBQUNBLGlCQUFTLFVBQVQsR0FBc0IsS0FBSyxHQUFMLEVBQXRCO0FBQ0EsaUJBQVMsVUFBVCxHQUFzQixRQUF0QjtBQUNBLGlCQUFTLFNBQVQ7QUFDRCxPQVhXLENBQWQ7QUFZQSxhQUFPLE9BQVA7QUFDRDs7QUFFRDs7Ozs7Ozs2QkFJNEI7QUFBQSxVQUFyQixjQUFxQix1RUFBSixFQUFJOztBQUMxQixXQUFLLFFBQUwsR0FBZ0IsY0FBaEI7QUFDRDs7OytCQUVVO0FBQ1QsVUFBSSxvQkFBSjtBQUNBLFVBQUkscUJBQW9CLEtBQUssUUFBekIsQ0FBSixFQUF1QztBQUNyQyxzQkFBYyxLQUFLLFFBQUwsQ0FBYyxPQUFkLEtBQTBCLEdBQTFCLEdBQWdDLEtBQUssUUFBTCxDQUFjLEdBQWQsRUFBaEMsR0FBc0QsR0FBcEU7QUFDQSxZQUFJLGFBQWEsT0FBTyxLQUFLLEVBQTdCLEVBQWtDO0FBQ2hDLHlCQUFlLEtBQUssRUFBcEI7QUFDRDtBQUNGLE9BTEQsTUFLTztBQUNMLHNCQUFjLGdCQUFkO0FBQ0Q7QUFDRCxhQUFPLFdBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7OytCQU1XO0FBQ1QsYUFBTyxVQUFVLE9BQVYsQ0FBa0IsS0FBSyxVQUF2QixFQUFtQyxJQUFuQyxDQUFQO0FBQ0Q7QUFDRDs7Ozs7Ozs4QkFJVTtBQUNSLGFBQU8sS0FBSyxRQUFMLEdBQWdCLE1BQWhCLEdBQXlCLENBQWhDO0FBQ0Q7QUFDRDs7Ozs7Ozs7Z0NBS1k7QUFDVixXQUFLLFVBQUwsR0FBa0IsTUFBTSxJQUFOLENBQWxCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OzZCQUtrQjtBQUFBLFVBQVgsRUFBVyx1RUFBTixJQUFNOztBQUNoQixVQUFJLFVBQVUsRUFBZDtBQUNBLFVBQUk7QUFDRixrQkFBVSxLQUFLLFFBQUwsQ0FBYyxHQUFkLEdBQW9CLGFBQXBCLEVBQVY7QUFDRCxPQUZELENBRUUsT0FBTSxDQUFOLEVBQVMsQ0FBRTs7QUFFYixVQUFJLFlBQVksS0FBSyxRQUFMLEVBQWhCO0FBQ0EsVUFBSSxXQUFXLElBQWY7O0FBRUEsVUFBSSxVQUFVLElBQUksT0FBSixHQUNYLEdBRFcsQ0FDUCxTQURPLEVBRVgsTUFGVyxDQUVKLFFBRkksRUFHWCxPQUhXLENBR0gsT0FIRyxFQUlYLElBSlcsR0FLWCxJQUxXLENBS04sVUFBQyxRQUFELEVBQWM7QUFDbEIsaUJBQVMsVUFBVCxHQUFzQixRQUF0QjtBQUNBLGVBQU8sSUFBUDtBQUNELE9BUlcsRUFRVCxLQVJTLENBUUgsZUFBTztBQUNkLFdBQUcsR0FBSDtBQUNBLGNBQU0sR0FBTjtBQUNELE9BWFcsQ0FBZDtBQVlBLGFBQU8sT0FBUDtBQUNEOzs7Ozs7QUFJSCxPQUFPLE9BQVAsR0FBaUIsS0FBakI7Ozs7Ozs7Ozs7O0FDak1BLElBQU0sWUFBWSxRQUFRLHNCQUFSLENBQWxCO0FBQ0EsSUFBTSxRQUFRLFFBQVEsZUFBUixFQUF5QixLQUF2Qzs7QUFFQTs7Ozs7SUFJTSxPO0FBQ0oscUJBQXlCO0FBQUEsUUFBYixNQUFhLHVFQUFKLEVBQUk7O0FBQUE7O0FBQ3ZCLFFBQUksV0FBVztBQUNiLGNBQVEsS0FESztBQUViLFdBQUssR0FGUTtBQUdiLGVBQVMsRUFISTtBQUliLFlBQU0sU0FKTztBQUtiLG9CQUFlLGtCQUxGO0FBTWIsY0FBUztBQU5JLEtBQWY7QUFRQSxTQUFLLE1BQUwsR0FBYyxFQUFkO0FBQ0EsV0FBTyxNQUFQLENBQWMsS0FBSyxNQUFuQixFQUEyQixRQUEzQixFQUFxQyxNQUFyQztBQUNEO0FBQ0Q7Ozs7Ozs7OzJCQUlPO0FBQ0wsVUFBSSxrQkFBa0IsSUFBdEI7QUFDQSxVQUFJLFVBQVUsUUFBUSxZQUFSLEVBQXNCLFVBQXRCLEVBQWQ7QUFDQSxhQUFPLElBQUksT0FBSixDQUFZLFVBQUMsT0FBRCxFQUFVLE1BQVYsRUFBcUI7QUFDdEMsd0JBQWdCLFNBQWhCLEdBQTRCLElBQUksU0FBSixDQUFjLGVBQWQsQ0FBNUI7O0FBRUEsd0JBQWdCLFNBQWhCLENBQ0MsSUFERCxHQUVDLElBRkQsQ0FFTSxTQUFTLGVBQVQsQ0FBeUIsUUFBekIsRUFBbUM7QUFDdkMsbUJBQVMsSUFBVCxHQUFnQixNQUFNLFNBQVMsUUFBZixDQUFoQjtBQUNBO0FBQ0EsbUJBQVMsT0FBVCxHQUFtQixlQUFuQjtBQUNBLGlCQUFPLFFBQVEsUUFBUixDQUFQO0FBQ0QsU0FQRCxFQU9HLFNBQVMsYUFBVCxDQUF1QixRQUF2QixFQUFpQztBQUNsQztBQUNBLG1CQUFTLE9BQVQsR0FBbUIsZUFBbkI7QUFDQSxpQkFBTyxPQUFPLFFBQVAsQ0FBUDtBQUNELFNBWEQ7QUFZRCxPQWZNLENBQVA7QUFnQkQ7QUFDRDs7Ozs7Ozs7MEJBS00sUSxFQUFVO0FBQ2QsVUFBSSxnQkFBZ0IsT0FBTyxRQUEzQixFQUFxQztBQUNuQyxZQUFJLHFCQUFvQixRQUFwQix5Q0FBb0IsUUFBcEIsTUFBZ0MsYUFBYSxJQUFqRCxFQUF1RDtBQUNyRCxxQkFBVyxNQUFNLFFBQU4sQ0FBWDtBQUNEO0FBQ0QsYUFBSyxNQUFMLENBQVksTUFBWixHQUFxQixRQUFyQjtBQUNBLGVBQU8sSUFBUDtBQUNELE9BTkQsTUFNTztBQUNMLGVBQU8sS0FBSyxNQUFMLENBQVksTUFBbkI7QUFDRDtBQUNGOztBQUVEOzs7Ozs7OzsyQkFLTyxTLEVBQVc7QUFDaEIsVUFBSSxnQkFBZ0IsT0FBTyxTQUEzQixFQUFzQztBQUNwQyxZQUFJLGFBQWEsT0FBTyxTQUF4QixFQUFtQztBQUNqQyxlQUFLLE1BQUwsQ0FBWSxNQUFaLEdBQXFCLFNBQXJCO0FBQ0Q7QUFDRCxlQUFPLElBQVA7QUFDRCxPQUxELE1BS087QUFDTCxlQUFPLEtBQUssTUFBTCxDQUFZLE1BQW5CO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7d0JBS0ksTSxFQUFRO0FBQ1YsVUFBSSxnQkFBZ0IsT0FBTyxNQUEzQixFQUFtQztBQUNqQyxZQUFJLGFBQWEsT0FBTyxNQUF4QixFQUFnQztBQUM5QixlQUFLLE1BQUwsQ0FBWSxHQUFaLEdBQWtCLE1BQWxCO0FBQ0Q7QUFDRCxlQUFPLElBQVA7QUFDRCxPQUxELE1BS087QUFDTCxlQUFPLEtBQUssTUFBTCxDQUFZLEdBQW5CO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7NEJBS1EsWSxFQUFjO0FBQ3BCLFVBQUksZ0JBQWdCLE9BQU8sWUFBM0IsRUFBeUM7QUFDdkMsWUFBSSxxQkFBb0IsWUFBcEIseUNBQW9CLFlBQXBCLE1BQW9DLGlCQUFpQixJQUF6RCxFQUErRDtBQUM3RCxlQUFLLE1BQUwsQ0FBWSxPQUFaLEdBQXNCLE1BQU0sWUFBTixDQUF0QjtBQUNEO0FBQ0QsZUFBTyxJQUFQO0FBQ0QsT0FMRCxNQUtPO0FBQ0wsZUFBTyxLQUFLLE1BQUwsQ0FBWSxPQUFuQjtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7O3lCQUtLLE8sRUFBUztBQUNaLFVBQUksZ0JBQWdCLE9BQU8sT0FBM0IsRUFBb0M7QUFDbEMsWUFBSSxxQkFBb0IsT0FBcEIseUNBQW9CLE9BQXBCLE1BQStCLFlBQVksSUFBL0MsRUFBcUQ7QUFDbkQsZUFBSyxNQUFMLENBQVksSUFBWixHQUFtQixNQUFNLE9BQU4sQ0FBbkI7QUFDRDtBQUNELGVBQU8sSUFBUDtBQUNELE9BTEQsTUFLTztBQUNMLGVBQU8sS0FBSyxNQUFMLENBQVksSUFBbkI7QUFDRDtBQUNGO0FBQ0Q7Ozs7Ozs7OzhCQUtVLE8sRUFBUztBQUNqQixVQUFJLGdCQUFnQixPQUFPLE9BQTNCLEVBQW9DO0FBQ2xDLFlBQUksYUFBYSxPQUFPLE9BQXhCLEVBQWlDO0FBQy9CLGVBQUssTUFBTCxDQUFZLFlBQVosR0FBMkIsT0FBM0I7QUFDRDtBQUNELGVBQU8sSUFBUDtBQUNEO0FBQ0QsYUFBTyxLQUFLLE1BQUwsQ0FBWSxZQUFuQjtBQUNEOztBQUVEOzs7Ozs7OzZCQUlTO0FBQ1AsYUFBTyxLQUFLLEtBQUwsQ0FBWSxLQUFLLFNBQUwsQ0FBZSxLQUFLLE1BQXBCLENBQVosQ0FBUDtBQUNEOzs7Ozs7QUFHSCxPQUFPLE9BQVAsR0FBaUIsT0FBakI7Ozs7O0FDcEpBOzs7Ozs7QUFNQSxJQUFJLFdBQVc7QUFDYixNQUFLLE9BRFE7QUFFYixpQkFBZ0IsdUJBQVMsQ0FBVCxFQUFZO0FBQzFCLFNBQUssRUFBTCxHQUFVLENBQVY7QUFDRCxHQUpZO0FBS2IsY0FBYSxzQkFBVztBQUN0QixXQUFPLEtBQUssRUFBWjtBQUNEO0FBUFksQ0FBZjs7QUFVQSxPQUFPLE9BQVAsR0FBaUIsUUFBakI7Ozs7Ozs7Ozs7O0FDaEJBLElBQU0sUUFBUSxRQUFRLGVBQVIsRUFBeUIsS0FBdkM7QUFDQSxJQUFNLGNBQWMsUUFBUSxhQUFSLENBQXBCOztBQUVBOzs7O0lBR00sUztBQUNMLG9CQUFZLE9BQVosRUFBcUI7QUFBQTs7QUFDcEIsTUFBSSxnQkFBZ0IsT0FBTyxNQUF2QixJQUFpQyxPQUFPLGNBQTVDLEVBQTREO0FBQzNELFFBQUssV0FBTCxHQUFtQixPQUFPLGNBQTFCO0FBQ0EsR0FGRCxNQUVPO0FBQ04sUUFBSyxXQUFMLEdBQW1CLFFBQVEsc0JBQVIsQ0FBbkIsQ0FETSxDQUM4QztBQUNwRDtBQUNELE9BQUssVUFBTCxDQUFnQixPQUFoQjtBQUNBO0FBQ0Q7Ozs7Ozs7Ozs7NkJBTVcsTyxFQUFTO0FBQ25CLFFBQUssT0FBTCxHQUFlLE1BQU0sT0FBTixDQUFmO0FBQ0EsVUFBTyxJQUFQO0FBQ0E7QUFDRDs7Ozs7Ozs7eUJBS087QUFDTixPQUFJLFVBQVUsUUFBUSxZQUFSLEVBQXNCLFVBQXRCLEVBQWQ7QUFDQSxPQUFJLFdBQVcsSUFBZjs7QUFFQSxVQUFPLElBQUksT0FBSixDQUFZLFVBQUMsT0FBRCxFQUFVLE1BQVYsRUFBcUI7O0FBRXZDLFFBQUksZUFBZSxJQUFJLFNBQVMsV0FBYixFQUFuQjtBQUNBLFFBQUksTUFBTSxTQUFTLE9BQVQsQ0FBaUIsR0FBakIsRUFBVjs7QUFFQSxRQUFJLFFBQVEsWUFBWSxTQUFaLENBQXNCLFNBQVMsT0FBVCxDQUFpQixLQUFqQixFQUF0QixDQUFaO0FBQ0EsUUFBSSxTQUFTLE1BQU0sTUFBbkIsRUFBMkI7QUFDMUIsV0FBTSxNQUFNLEdBQU4sR0FBWSxLQUFsQjtBQUNBO0FBQ0QsUUFBSSxPQUFPLFNBQVMsT0FBVCxDQUFpQixJQUFqQixFQUFYO0FBQ0EsUUFBSSxxQkFBb0IsSUFBcEIseUNBQW9CLElBQXBCLEVBQUosRUFBOEI7QUFDN0IsWUFBTyxLQUFLLFNBQUwsQ0FBZSxJQUFmLENBQVA7QUFDQTs7QUFFRCxpQkFBYSxnQkFBYixDQUE4QixNQUE5QixFQUFzQyxnQkFBdEM7QUFDQSxpQkFBYSxnQkFBYixDQUE4QixPQUE5QixFQUF1QyxjQUF2QztBQUNBLGlCQUFhLGdCQUFiLENBQThCLE9BQTlCLEVBQXVDLGVBQXZDO0FBQ0EsaUJBQWEsSUFBYixDQUFtQixTQUFTLE9BQVQsQ0FBaUIsTUFBakIsR0FBMEIsV0FBMUIsRUFBbkIsRUFBNEQsR0FBNUQ7QUFDQSxpQkFBYSxZQUFiLEdBQTRCLE1BQTVCOztBQUVBLFFBQUksVUFBVSxTQUFTLE9BQVQsQ0FBaUIsT0FBakIsRUFBZDtBQUNBLGlCQUFhLGdCQUFiLENBQThCLGNBQTlCLEVBQThDLFNBQVMsT0FBVCxDQUFpQixTQUFqQixFQUE5Qzs7QUFFQSxTQUFNLElBQUksVUFBVixJQUF3QixPQUF4QixFQUFrQztBQUNqQyxrQkFBYSxnQkFBYixDQUE4QixVQUE5QixFQUEwQyxRQUFRLFVBQVIsQ0FBMUM7QUFDQTtBQUNELGlCQUFhLElBQWIsQ0FBbUIsSUFBbkI7O0FBRUE7OztBQUdBLGFBQVMsZUFBVCxHQUEyQjtBQUMxQixTQUFJLFNBQVMsSUFBSSxLQUFKLENBQVUscUJBQVYsQ0FBYjtBQUNBLFlBQU8sTUFBUDtBQUNBO0FBQ0Q7OztBQUdBLGFBQVMsY0FBVCxDQUF3QixDQUF4QixFQUEyQjtBQUMxQixZQUFPLFlBQVA7QUFDQTtBQUNEOzs7QUFHQSxhQUFTLGdCQUFULEdBQTRCO0FBQzNCLFNBQUksYUFBYSxNQUFiLEdBQXNCLEdBQTFCLEVBQStCO0FBQzlCLGNBQVEsWUFBUjtBQUNBLE1BRkQsTUFFTztBQUNOLGFBQU8sWUFBUDtBQUNBO0FBQ0Q7QUFDRCxJQW5ETSxDQUFQO0FBb0RBOzs7Ozs7QUFHRixPQUFPLE9BQVAsR0FBaUIsU0FBakI7Ozs7Ozs7OztBQ3pGQTs7OztJQUlNLFU7QUFDSix3QkFBdUI7QUFBQSxRQUFYLElBQVcsdUVBQUosRUFBSTs7QUFBQTs7QUFDckIsUUFBSSxDQUFDLElBQUQsSUFBUyxlQUFlLE9BQU8sS0FBSyxJQUF4QyxFQUE4QztBQUM1QyxZQUFNLElBQUksS0FBSixDQUFVLDhDQUFWLENBQU47QUFDRDtBQUNELFNBQUssTUFBTCxHQUFjLEtBQUssTUFBTCxDQUFZLGdCQUFRO0FBQ2hDLGFBQU8sU0FBUyxHQUFoQjtBQUNELEtBRmEsRUFFWCxJQUZXLENBRU4sR0FGTSxLQUVFLEdBRmhCO0FBR0Q7QUFDRDs7Ozs7OzsrQkFHVztBQUNULGFBQU8sS0FBSyxNQUFMLElBQWUsRUFBdEI7QUFDRDs7Ozs7O0FBR0gsT0FBTyxPQUFQLEdBQWlCLFVBQWpCOzs7Ozs7Ozs7OztBQ3JCQSxJQUFJLFlBQVksUUFBUSxPQUFSLENBQWhCOztBQUVBOzs7O0lBR00sSztBQUNGLG1CQUFjO0FBQUE7QUFFYjtBQUNEOzs7Ozs7OzsyQkFJYyxDQUViOztBQUVEOzs7Ozs7OzswQkFLYSxHLEVBQUs7QUFDZCxhQUFPLEdBQVA7QUFDQTtBQUNBO0FBQ0g7Ozs7O0FBRUw7Ozs7Ozs7O0FBTUEsU0FBUyxZQUFULENBQXNCLEdBQXRCLEVBQTJCO0FBQ3hCLE1BQUcsUUFBUSxJQUFSLElBQWdCLFFBQU8sR0FBUCx5Q0FBTyxHQUFQLE1BQWUsUUFBbEMsRUFBNEM7QUFDekMsV0FBTyxHQUFQO0FBQ0Y7QUFDRCxNQUFJLE9BQU8sSUFBSSxJQUFJLFdBQVIsRUFBWDtBQUNBLE9BQUksSUFBSSxHQUFSLElBQWUsR0FBZixFQUFvQjtBQUNqQixTQUFLLEdBQUwsSUFBWSxhQUFhLElBQUksR0FBSixDQUFiLENBQVo7QUFDRjtBQUNELFNBQU8sSUFBUDtBQUNGOztBQUVELE9BQU8sT0FBUCxHQUFpQixLQUFqQiIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKipcbiAqIFRoaXMgY3JlYXRlcyBhIHNpbXBsZSBwYWNrYWdlIHRoYXQgY2FuIGJlIGV4cG9ydGVkXG4gKiBAbmFtZXNwYWNlIE9mZmljZUJvdFNESy5JbmRleFxuICovXG5sZXQgU0RLID0gKGZ1bmN0aW9uKFByb21pc2UpIHtcblxuICBsZXQgU2V0dGluZ3MgPSByZXF1aXJlKCcuL3NyYy9zZXR0aW5ncy5qcycpO1xuICBTZXR0aW5ncy5zZXRQcm9taXNlTGliKFByb21pc2UpO1xuXG4gIGxldCBleHBvcnRzID0ge1xuICAgIEFQSSAgICAgICAgICAgICA6IHJlcXVpcmUoJy4vc3JjL2FwaS1jb25maWcuY2xhc3MnKSxcbiAgICBDYWNoZSAgICAgICAgICAgOiByZXF1aXJlKCcuL3NyYy9jYWNoZS5jbGFzcycpLFxuICAgIEVuZHBvaW50Q29uZmlnICA6IHJlcXVpcmUoJy4vc3JjL2VuZHBvaW50LWNvbmZpZy5jbGFzcycpLFxuICAgIEVuZHBvaW50ICAgICAgICA6IHJlcXVpcmUoJy4vc3JjL2VuZHBvaW50LmNsYXNzJyksXG4gICAgSFRUUE1vY2sgICAgICAgIDogcmVxdWlyZSgnLi9zcmMvaHR0cC1tb2NrLmNsYXNzJyksXG4gICAgTW9kZWwgICAgICAgICAgIDogcmVxdWlyZSgnLi9zcmMvbW9kZWwuY2xhc3MnKSxcbiAgICBSZXF1ZXN0ICAgICAgICAgOiByZXF1aXJlKCcuL3NyYy9yZXF1ZXN0LmNsYXNzJyksXG4gICAgU2V0dGluZ3MgICAgICAgIDogU2V0dGluZ3MsXG4gICAgVHJhbnBvcnQgICAgICAgIDogcmVxdWlyZSgnLi9zcmMvdHJhbnNwb3J0LmNsYXNzJyksXG4gICAgVVJMQnVpbGRlciAgICAgIDogcmVxdWlyZSgnLi9zcmMvdXJsLWJ1aWxkZXIuY2xhc3MnKSxcbiAgICBVdGlscyAgICAgICAgICAgOiByZXF1aXJlKCcuL3NyYy91dGlscy5jbGFzcycpXG4gIH07XG5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0pKFByb21pc2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNESzsiLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBwbGFjZUhvbGRlcnNDb3VudCAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gIC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuICByZXR1cm4gYjY0W2xlbiAtIDJdID09PSAnPScgPyAyIDogYjY0W2xlbiAtIDFdID09PSAnPScgPyAxIDogMFxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIHJldHVybiAoYjY0Lmxlbmd0aCAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0NvdW50KGI2NClcbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgaSwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBwbGFjZUhvbGRlcnMgPSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG5cbiAgYXJyID0gbmV3IEFycigobGVuICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzKVxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuXG5cbiAgdmFyIEwgPSAwXG5cbiAgZm9yIChpID0gMDsgaSA8IGw7IGkgKz0gNCkge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbnZhciBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAoaXNBcnJheUJ1ZmZlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbkJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbkJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICB2YXIgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmIChpc0FycmF5QnVmZmVyVmlldyhvYmopIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoaXNBcnJheUJ1ZmZlclZpZXcoc3RyaW5nKSB8fCBpc0FycmF5QnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDApIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXJzIGZyb20gYW5vdGhlciBjb250ZXh0IChpLmUuIGFuIGlmcmFtZSkgZG8gbm90IHBhc3MgdGhlIGBpbnN0YW5jZW9mYCBjaGVja1xuLy8gYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgdmFsaWQuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlciAob2JqKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gJ0FycmF5QnVmZmVyJyAmJlxuICAgICAgdHlwZW9mIG9iai5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJylcbn1cblxuLy8gTm9kZSAwLjEwIHN1cHBvcnRzIGBBcnJheUJ1ZmZlcmAgYnV0IGxhY2tzIGBBcnJheUJ1ZmZlci5pc1ZpZXdgXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyAob2JqKSB7XG4gIHJldHVybiAodHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJykgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KG9iailcbn1cblxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsInZhciBjbG9uZSA9IChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2luc3RhbmNlb2Yob2JqLCB0eXBlKSB7XG4gIHJldHVybiB0eXBlICE9IG51bGwgJiYgb2JqIGluc3RhbmNlb2YgdHlwZTtcbn1cblxudmFyIG5hdGl2ZU1hcDtcbnRyeSB7XG4gIG5hdGl2ZU1hcCA9IE1hcDtcbn0gY2F0Y2goXykge1xuICAvLyBtYXliZSBhIHJlZmVyZW5jZSBlcnJvciBiZWNhdXNlIG5vIGBNYXBgLiBHaXZlIGl0IGEgZHVtbXkgdmFsdWUgdGhhdCBub1xuICAvLyB2YWx1ZSB3aWxsIGV2ZXIgYmUgYW4gaW5zdGFuY2VvZi5cbiAgbmF0aXZlTWFwID0gZnVuY3Rpb24oKSB7fTtcbn1cblxudmFyIG5hdGl2ZVNldDtcbnRyeSB7XG4gIG5hdGl2ZVNldCA9IFNldDtcbn0gY2F0Y2goXykge1xuICBuYXRpdmVTZXQgPSBmdW5jdGlvbigpIHt9O1xufVxuXG52YXIgbmF0aXZlUHJvbWlzZTtcbnRyeSB7XG4gIG5hdGl2ZVByb21pc2UgPSBQcm9taXNlO1xufSBjYXRjaChfKSB7XG4gIG5hdGl2ZVByb21pc2UgPSBmdW5jdGlvbigpIHt9O1xufVxuXG4vKipcbiAqIENsb25lcyAoY29waWVzKSBhbiBPYmplY3QgdXNpbmcgZGVlcCBjb3B5aW5nLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gc3VwcG9ydHMgY2lyY3VsYXIgcmVmZXJlbmNlcyBieSBkZWZhdWx0LCBidXQgaWYgeW91IGFyZSBjZXJ0YWluXG4gKiB0aGVyZSBhcmUgbm8gY2lyY3VsYXIgcmVmZXJlbmNlcyBpbiB5b3VyIG9iamVjdCwgeW91IGNhbiBzYXZlIHNvbWUgQ1BVIHRpbWVcbiAqIGJ5IGNhbGxpbmcgY2xvbmUob2JqLCBmYWxzZSkuXG4gKlxuICogQ2F1dGlvbjogaWYgYGNpcmN1bGFyYCBpcyBmYWxzZSBhbmQgYHBhcmVudGAgY29udGFpbnMgY2lyY3VsYXIgcmVmZXJlbmNlcyxcbiAqIHlvdXIgcHJvZ3JhbSBtYXkgZW50ZXIgYW4gaW5maW5pdGUgbG9vcCBhbmQgY3Jhc2guXG4gKlxuICogQHBhcmFtIGBwYXJlbnRgIC0gdGhlIG9iamVjdCB0byBiZSBjbG9uZWRcbiAqIEBwYXJhbSBgY2lyY3VsYXJgIC0gc2V0IHRvIHRydWUgaWYgdGhlIG9iamVjdCB0byBiZSBjbG9uZWQgbWF5IGNvbnRhaW5cbiAqICAgIGNpcmN1bGFyIHJlZmVyZW5jZXMuIChvcHRpb25hbCAtIHRydWUgYnkgZGVmYXVsdClcbiAqIEBwYXJhbSBgZGVwdGhgIC0gc2V0IHRvIGEgbnVtYmVyIGlmIHRoZSBvYmplY3QgaXMgb25seSB0byBiZSBjbG9uZWQgdG9cbiAqICAgIGEgcGFydGljdWxhciBkZXB0aC4gKG9wdGlvbmFsIC0gZGVmYXVsdHMgdG8gSW5maW5pdHkpXG4gKiBAcGFyYW0gYHByb3RvdHlwZWAgLSBzZXRzIHRoZSBwcm90b3R5cGUgdG8gYmUgdXNlZCB3aGVuIGNsb25pbmcgYW4gb2JqZWN0LlxuICogICAgKG9wdGlvbmFsIC0gZGVmYXVsdHMgdG8gcGFyZW50IHByb3RvdHlwZSkuXG4gKiBAcGFyYW0gYGluY2x1ZGVOb25FbnVtZXJhYmxlYCAtIHNldCB0byB0cnVlIGlmIHRoZSBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzXG4gKiAgICBzaG91bGQgYmUgY2xvbmVkIGFzIHdlbGwuIE5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgb24gdGhlIHByb3RvdHlwZVxuICogICAgY2hhaW4gd2lsbCBiZSBpZ25vcmVkLiAob3B0aW9uYWwgLSBmYWxzZSBieSBkZWZhdWx0KVxuKi9cbmZ1bmN0aW9uIGNsb25lKHBhcmVudCwgY2lyY3VsYXIsIGRlcHRoLCBwcm90b3R5cGUsIGluY2x1ZGVOb25FbnVtZXJhYmxlKSB7XG4gIGlmICh0eXBlb2YgY2lyY3VsYXIgPT09ICdvYmplY3QnKSB7XG4gICAgZGVwdGggPSBjaXJjdWxhci5kZXB0aDtcbiAgICBwcm90b3R5cGUgPSBjaXJjdWxhci5wcm90b3R5cGU7XG4gICAgaW5jbHVkZU5vbkVudW1lcmFibGUgPSBjaXJjdWxhci5pbmNsdWRlTm9uRW51bWVyYWJsZTtcbiAgICBjaXJjdWxhciA9IGNpcmN1bGFyLmNpcmN1bGFyO1xuICB9XG4gIC8vIG1haW50YWluIHR3byBhcnJheXMgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMsIHdoZXJlIGNvcnJlc3BvbmRpbmcgcGFyZW50c1xuICAvLyBhbmQgY2hpbGRyZW4gaGF2ZSB0aGUgc2FtZSBpbmRleFxuICB2YXIgYWxsUGFyZW50cyA9IFtdO1xuICB2YXIgYWxsQ2hpbGRyZW4gPSBbXTtcblxuICB2YXIgdXNlQnVmZmVyID0gdHlwZW9mIEJ1ZmZlciAhPSAndW5kZWZpbmVkJztcblxuICBpZiAodHlwZW9mIGNpcmN1bGFyID09ICd1bmRlZmluZWQnKVxuICAgIGNpcmN1bGFyID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGRlcHRoID09ICd1bmRlZmluZWQnKVxuICAgIGRlcHRoID0gSW5maW5pdHk7XG5cbiAgLy8gcmVjdXJzZSB0aGlzIGZ1bmN0aW9uIHNvIHdlIGRvbid0IHJlc2V0IGFsbFBhcmVudHMgYW5kIGFsbENoaWxkcmVuXG4gIGZ1bmN0aW9uIF9jbG9uZShwYXJlbnQsIGRlcHRoKSB7XG4gICAgLy8gY2xvbmluZyBudWxsIGFsd2F5cyByZXR1cm5zIG51bGxcbiAgICBpZiAocGFyZW50ID09PSBudWxsKVxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBpZiAoZGVwdGggPT09IDApXG4gICAgICByZXR1cm4gcGFyZW50O1xuXG4gICAgdmFyIGNoaWxkO1xuICAgIHZhciBwcm90bztcbiAgICBpZiAodHlwZW9mIHBhcmVudCAhPSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG5cbiAgICBpZiAoX2luc3RhbmNlb2YocGFyZW50LCBuYXRpdmVNYXApKSB7XG4gICAgICBjaGlsZCA9IG5ldyBuYXRpdmVNYXAoKTtcbiAgICB9IGVsc2UgaWYgKF9pbnN0YW5jZW9mKHBhcmVudCwgbmF0aXZlU2V0KSkge1xuICAgICAgY2hpbGQgPSBuZXcgbmF0aXZlU2V0KCk7XG4gICAgfSBlbHNlIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIG5hdGl2ZVByb21pc2UpKSB7XG4gICAgICBjaGlsZCA9IG5ldyBuYXRpdmVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcGFyZW50LnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXNvbHZlKF9jbG9uZSh2YWx1ZSwgZGVwdGggLSAxKSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIHJlamVjdChfY2xvbmUoZXJyLCBkZXB0aCAtIDEpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNsb25lLl9faXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBjaGlsZCA9IFtdO1xuICAgIH0gZWxzZSBpZiAoY2xvbmUuX19pc1JlZ0V4cChwYXJlbnQpKSB7XG4gICAgICBjaGlsZCA9IG5ldyBSZWdFeHAocGFyZW50LnNvdXJjZSwgX19nZXRSZWdFeHBGbGFncyhwYXJlbnQpKTtcbiAgICAgIGlmIChwYXJlbnQubGFzdEluZGV4KSBjaGlsZC5sYXN0SW5kZXggPSBwYXJlbnQubGFzdEluZGV4O1xuICAgIH0gZWxzZSBpZiAoY2xvbmUuX19pc0RhdGUocGFyZW50KSkge1xuICAgICAgY2hpbGQgPSBuZXcgRGF0ZShwYXJlbnQuZ2V0VGltZSgpKTtcbiAgICB9IGVsc2UgaWYgKHVzZUJ1ZmZlciAmJiBCdWZmZXIuaXNCdWZmZXIocGFyZW50KSkge1xuICAgICAgY2hpbGQgPSBuZXcgQnVmZmVyKHBhcmVudC5sZW5ndGgpO1xuICAgICAgcGFyZW50LmNvcHkoY2hpbGQpO1xuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH0gZWxzZSBpZiAoX2luc3RhbmNlb2YocGFyZW50LCBFcnJvcikpIHtcbiAgICAgIGNoaWxkID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIHByb3RvdHlwZSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwYXJlbnQpO1xuICAgICAgICBjaGlsZCA9IE9iamVjdC5jcmVhdGUocHJvdG8pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNoaWxkID0gT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUpO1xuICAgICAgICBwcm90byA9IHByb3RvdHlwZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2lyY3VsYXIpIHtcbiAgICAgIHZhciBpbmRleCA9IGFsbFBhcmVudHMuaW5kZXhPZihwYXJlbnQpO1xuXG4gICAgICBpZiAoaW5kZXggIT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGFsbENoaWxkcmVuW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIGFsbFBhcmVudHMucHVzaChwYXJlbnQpO1xuICAgICAgYWxsQ2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgfVxuXG4gICAgaWYgKF9pbnN0YW5jZW9mKHBhcmVudCwgbmF0aXZlTWFwKSkge1xuICAgICAgcGFyZW50LmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICB2YXIga2V5Q2hpbGQgPSBfY2xvbmUoa2V5LCBkZXB0aCAtIDEpO1xuICAgICAgICB2YXIgdmFsdWVDaGlsZCA9IF9jbG9uZSh2YWx1ZSwgZGVwdGggLSAxKTtcbiAgICAgICAgY2hpbGQuc2V0KGtleUNoaWxkLCB2YWx1ZUNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoX2luc3RhbmNlb2YocGFyZW50LCBuYXRpdmVTZXQpKSB7XG4gICAgICBwYXJlbnQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgZW50cnlDaGlsZCA9IF9jbG9uZSh2YWx1ZSwgZGVwdGggLSAxKTtcbiAgICAgICAgY2hpbGQuYWRkKGVudHJ5Q2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSBpbiBwYXJlbnQpIHtcbiAgICAgIHZhciBhdHRycztcbiAgICAgIGlmIChwcm90bykge1xuICAgICAgICBhdHRycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIGkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXR0cnMgJiYgYXR0cnMuc2V0ID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjaGlsZFtpXSA9IF9jbG9uZShwYXJlbnRbaV0sIGRlcHRoIC0gMSk7XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhwYXJlbnQpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIERvbid0IG5lZWQgdG8gd29ycnkgYWJvdXQgY2xvbmluZyBhIHN5bWJvbCBiZWNhdXNlIGl0IGlzIGEgcHJpbWl0aXZlLFxuICAgICAgICAvLyBsaWtlIGEgbnVtYmVyIG9yIHN0cmluZy5cbiAgICAgICAgdmFyIHN5bWJvbCA9IHN5bWJvbHNbaV07XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwYXJlbnQsIHN5bWJvbCk7XG4gICAgICAgIGlmIChkZXNjcmlwdG9yICYmICFkZXNjcmlwdG9yLmVudW1lcmFibGUgJiYgIWluY2x1ZGVOb25FbnVtZXJhYmxlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRbc3ltYm9sXSA9IF9jbG9uZShwYXJlbnRbc3ltYm9sXSwgZGVwdGggLSAxKTtcbiAgICAgICAgaWYgKCFkZXNjcmlwdG9yLmVudW1lcmFibGUpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2hpbGQsIHN5bWJvbCwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpbmNsdWRlTm9uRW51bWVyYWJsZSkge1xuICAgICAgdmFyIGFsbFByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwYXJlbnQpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxQcm9wZXJ0eU5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBhbGxQcm9wZXJ0eU5hbWVzW2ldO1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocGFyZW50LCBwcm9wZXJ0eU5hbWUpO1xuICAgICAgICBpZiAoZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLmVudW1lcmFibGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZFtwcm9wZXJ0eU5hbWVdID0gX2Nsb25lKHBhcmVudFtwcm9wZXJ0eU5hbWVdLCBkZXB0aCAtIDEpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2hpbGQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjaGlsZDtcbiAgfVxuXG4gIHJldHVybiBfY2xvbmUocGFyZW50LCBkZXB0aCk7XG59XG5cbi8qKlxuICogU2ltcGxlIGZsYXQgY2xvbmUgdXNpbmcgcHJvdG90eXBlLCBhY2NlcHRzIG9ubHkgb2JqZWN0cywgdXNlZnVsbCBmb3IgcHJvcGVydHlcbiAqIG92ZXJyaWRlIG9uIEZMQVQgY29uZmlndXJhdGlvbiBvYmplY3QgKG5vIG5lc3RlZCBwcm9wcykuXG4gKlxuICogVVNFIFdJVEggQ0FVVElPTiEgVGhpcyBtYXkgbm90IGJlaGF2ZSBhcyB5b3Ugd2lzaCBpZiB5b3UgZG8gbm90IGtub3cgaG93IHRoaXNcbiAqIHdvcmtzLlxuICovXG5jbG9uZS5jbG9uZVByb3RvdHlwZSA9IGZ1bmN0aW9uIGNsb25lUHJvdG90eXBlKHBhcmVudCkge1xuICBpZiAocGFyZW50ID09PSBudWxsKVxuICAgIHJldHVybiBudWxsO1xuXG4gIHZhciBjID0gZnVuY3Rpb24gKCkge307XG4gIGMucHJvdG90eXBlID0gcGFyZW50O1xuICByZXR1cm4gbmV3IGMoKTtcbn07XG5cbi8vIHByaXZhdGUgdXRpbGl0eSBmdW5jdGlvbnNcblxuZnVuY3Rpb24gX19vYmpUb1N0cihvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5jbG9uZS5fX29ialRvU3RyID0gX19vYmpUb1N0cjtcblxuZnVuY3Rpb24gX19pc0RhdGUobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09ICdvYmplY3QnICYmIF9fb2JqVG9TdHIobykgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmNsb25lLl9faXNEYXRlID0gX19pc0RhdGU7XG5cbmZ1bmN0aW9uIF9faXNBcnJheShvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgX19vYmpUb1N0cihvKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmNsb25lLl9faXNBcnJheSA9IF9faXNBcnJheTtcblxuZnVuY3Rpb24gX19pc1JlZ0V4cChvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgX19vYmpUb1N0cihvKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5jbG9uZS5fX2lzUmVnRXhwID0gX19pc1JlZ0V4cDtcblxuZnVuY3Rpb24gX19nZXRSZWdFeHBGbGFncyhyZSkge1xuICB2YXIgZmxhZ3MgPSAnJztcbiAgaWYgKHJlLmdsb2JhbCkgZmxhZ3MgKz0gJ2cnO1xuICBpZiAocmUuaWdub3JlQ2FzZSkgZmxhZ3MgKz0gJ2knO1xuICBpZiAocmUubXVsdGlsaW5lKSBmbGFncyArPSAnbSc7XG4gIHJldHVybiBmbGFncztcbn1cbmNsb25lLl9fZ2V0UmVnRXhwRmxhZ3MgPSBfX2dldFJlZ0V4cEZsYWdzO1xuXG5yZXR1cm4gY2xvbmU7XG59KSgpO1xuXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBjbG9uZTtcbn1cbiIsInZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgb2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4vbGliL2tleXMuanMnKTtcbnZhciBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vbGliL2lzX2FyZ3VtZW50cy5qcycpO1xuXG52YXIgZGVlcEVxdWFsID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYWN0dWFsLCBleHBlY3RlZCwgb3B0cykge1xuICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBEYXRlICYmIGV4cGVjdGVkIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zLiBPdGhlciBwYWlycyB0aGF0IGRvIG5vdCBib3RoIHBhc3MgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5ID09LlxuICB9IGVsc2UgaWYgKCFhY3R1YWwgfHwgIWV4cGVjdGVkIHx8IHR5cGVvZiBhY3R1YWwgIT0gJ29iamVjdCcgJiYgdHlwZW9mIGV4cGVjdGVkICE9ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG9wdHMuc3RyaWN0ID8gYWN0dWFsID09PSBleHBlY3RlZCA6IGFjdHVhbCA9PSBleHBlY3RlZDtcblxuICAvLyA3LjQuIEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCwgb3B0cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWRPck51bGwodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyICh4KSB7XG4gIGlmICgheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIHgubGVuZ3RoICE9PSAnbnVtYmVyJykgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIHguY29weSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgeC5zbGljZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoeC5sZW5ndGggPiAwICYmIHR5cGVvZiB4WzBdICE9PSAnbnVtYmVyJykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYiwgb3B0cykge1xuICB2YXIgaSwga2V5O1xuICBpZiAoaXNVbmRlZmluZWRPck51bGwoYSkgfHwgaXNVbmRlZmluZWRPck51bGwoYikpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvLyBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuXG4gIGlmIChhLnByb3RvdHlwZSAhPT0gYi5wcm90b3R5cGUpIHJldHVybiBmYWxzZTtcbiAgLy9+fn5JJ3ZlIG1hbmFnZWQgdG8gYnJlYWsgT2JqZWN0LmtleXMgdGhyb3VnaCBzY3Jld3kgYXJndW1lbnRzIHBhc3NpbmcuXG4gIC8vICAgQ29udmVydGluZyB0byBhcnJheSBzb2x2ZXMgdGhlIHByb2JsZW0uXG4gIGlmIChpc0FyZ3VtZW50cyhhKSkge1xuICAgIGlmICghaXNBcmd1bWVudHMoYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYSA9IHBTbGljZS5jYWxsKGEpO1xuICAgIGIgPSBwU2xpY2UuY2FsbChiKTtcbiAgICByZXR1cm4gZGVlcEVxdWFsKGEsIGIsIG9wdHMpO1xuICB9XG4gIGlmIChpc0J1ZmZlcihhKSkge1xuICAgIGlmICghaXNCdWZmZXIoYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYVtpXSAhPT0gYltpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0cnkge1xuICAgIHZhciBrYSA9IG9iamVjdEtleXMoYSksXG4gICAgICAgIGtiID0gb2JqZWN0S2V5cyhiKTtcbiAgfSBjYXRjaCAoZSkgey8vaGFwcGVucyB3aGVuIG9uZSBpcyBhIHN0cmluZyBsaXRlcmFsIGFuZCB0aGUgb3RoZXIgaXNuJ3RcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghZGVlcEVxdWFsKGFba2V5XSwgYltrZXldLCBvcHRzKSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0eXBlb2YgYSA9PT0gdHlwZW9mIGI7XG59XG4iLCJ2YXIgc3VwcG9ydHNBcmd1bWVudHNDbGFzcyA9IChmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3VtZW50cylcbn0pKCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnRzQXJndW1lbnRzQ2xhc3MgPyBzdXBwb3J0ZWQgOiB1bnN1cHBvcnRlZDtcblxuZXhwb3J0cy5zdXBwb3J0ZWQgPSBzdXBwb3J0ZWQ7XG5mdW5jdGlvbiBzdXBwb3J0ZWQob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn07XG5cbmV4cG9ydHMudW5zdXBwb3J0ZWQgPSB1bnN1cHBvcnRlZDtcbmZ1bmN0aW9uIHVuc3VwcG9ydGVkKG9iamVjdCl7XG4gIHJldHVybiBvYmplY3QgJiZcbiAgICB0eXBlb2Ygb2JqZWN0ID09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIG9iamVjdC5sZW5ndGggPT0gJ251bWJlcicgJiZcbiAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnY2FsbGVlJykgJiZcbiAgICAhT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgJ2NhbGxlZScpIHx8XG4gICAgZmFsc2U7XG59O1xuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nXG4gID8gT2JqZWN0LmtleXMgOiBzaGltO1xuXG5leHBvcnRzLnNoaW0gPSBzaGltO1xuZnVuY3Rpb24gc2hpbSAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICByZXR1cm4ga2V5cztcbn1cbiIsInZhciBlcXVhbHNPcHRpb25zID0geyBzdHJpY3Q6IHRydWUgfTtcclxudmFyIF9lcXVhbHMgPSByZXF1aXJlKCdkZWVwLWVxdWFsJyk7XHJcbnZhciBhcmVFcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgcmV0dXJuIF9lcXVhbHMoYSwgYiwgZXF1YWxzT3B0aW9ucyk7XHJcbn07XHJcbnZhciBoZWxwZXJzXzEgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcclxuZXhwb3J0cy5Kc29uUGF0Y2hFcnJvciA9IGhlbHBlcnNfMS5QYXRjaEVycm9yO1xyXG5leHBvcnRzLmRlZXBDbG9uZSA9IGhlbHBlcnNfMS5fZGVlcENsb25lO1xyXG4vKiBXZSB1c2UgYSBKYXZhc2NyaXB0IGhhc2ggdG8gc3RvcmUgZWFjaFxyXG4gZnVuY3Rpb24uIEVhY2ggaGFzaCBlbnRyeSAocHJvcGVydHkpIHVzZXNcclxuIHRoZSBvcGVyYXRpb24gaWRlbnRpZmllcnMgc3BlY2lmaWVkIGluIHJmYzY5MDIuXHJcbiBJbiB0aGlzIHdheSwgd2UgY2FuIG1hcCBlYWNoIHBhdGNoIG9wZXJhdGlvblxyXG4gdG8gaXRzIGRlZGljYXRlZCBmdW5jdGlvbiBpbiBlZmZpY2llbnQgd2F5LlxyXG4gKi9cclxuLyogVGhlIG9wZXJhdGlvbnMgYXBwbGljYWJsZSB0byBhbiBvYmplY3QgKi9cclxudmFyIG9iak9wcyA9IHtcclxuICAgIGFkZDogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xyXG4gICAgICAgIG9ialtrZXldID0gdGhpcy52YWx1ZTtcclxuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQgfTtcclxuICAgIH0sXHJcbiAgICByZW1vdmU6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcclxuICAgICAgICB2YXIgcmVtb3ZlZCA9IG9ialtrZXldO1xyXG4gICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcclxuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHJlbW92ZWQ6IHJlbW92ZWQgfTtcclxuICAgIH0sXHJcbiAgICByZXBsYWNlOiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XHJcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBvYmpba2V5XTtcclxuICAgICAgICBvYmpba2V5XSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCByZW1vdmVkOiByZW1vdmVkIH07XHJcbiAgICB9LFxyXG4gICAgbW92ZTogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xyXG4gICAgICAgIC8qIGluIGNhc2UgbW92ZSB0YXJnZXQgb3ZlcndyaXRlcyBhbiBleGlzdGluZyB2YWx1ZSxcclxuICAgICAgICByZXR1cm4gdGhlIHJlbW92ZWQgdmFsdWUsIHRoaXMgY2FuIGJlIHRheGluZyBwZXJmb3JtYW5jZS13aXNlLFxyXG4gICAgICAgIGFuZCBpcyBwb3RlbnRpYWxseSB1bm5lZWRlZCAqL1xyXG4gICAgICAgIHZhciByZW1vdmVkID0gZ2V0VmFsdWVCeVBvaW50ZXIoZG9jdW1lbnQsIHRoaXMucGF0aCk7XHJcbiAgICAgICAgaWYgKHJlbW92ZWQpIHtcclxuICAgICAgICAgICAgcmVtb3ZlZCA9IGhlbHBlcnNfMS5fZGVlcENsb25lKHJlbW92ZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb3JpZ2luYWxWYWx1ZSA9IGFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCB7IG9wOiBcInJlbW92ZVwiLCBwYXRoOiB0aGlzLmZyb20gfSkucmVtb3ZlZDtcclxuICAgICAgICBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgeyBvcDogXCJhZGRcIiwgcGF0aDogdGhpcy5wYXRoLCB2YWx1ZTogb3JpZ2luYWxWYWx1ZSB9KTtcclxuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHJlbW92ZWQ6IHJlbW92ZWQgfTtcclxuICAgIH0sXHJcbiAgICBjb3B5OiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XHJcbiAgICAgICAgdmFyIHZhbHVlVG9Db3B5ID0gZ2V0VmFsdWVCeVBvaW50ZXIoZG9jdW1lbnQsIHRoaXMuZnJvbSk7XHJcbiAgICAgICAgLy8gZW5mb3JjZSBjb3B5IGJ5IHZhbHVlIHNvIGZ1cnRoZXIgb3BlcmF0aW9ucyBkb24ndCBhZmZlY3Qgc291cmNlIChzZWUgaXNzdWUgIzE3NylcclxuICAgICAgICBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgeyBvcDogXCJhZGRcIiwgcGF0aDogdGhpcy5wYXRoLCB2YWx1ZTogaGVscGVyc18xLl9kZWVwQ2xvbmUodmFsdWVUb0NvcHkpIH0pO1xyXG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCB9O1xyXG4gICAgfSxcclxuICAgIHRlc3Q6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcclxuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHRlc3Q6IGFyZUVxdWFscyhvYmpba2V5XSwgdGhpcy52YWx1ZSkgfTtcclxuICAgIH0sXHJcbiAgICBfZ2V0OiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IG9ialtrZXldO1xyXG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCB9O1xyXG4gICAgfVxyXG59O1xyXG4vKiBUaGUgb3BlcmF0aW9ucyBhcHBsaWNhYmxlIHRvIGFuIGFycmF5LiBNYW55IGFyZSB0aGUgc2FtZSBhcyBmb3IgdGhlIG9iamVjdCAqL1xyXG52YXIgYXJyT3BzID0ge1xyXG4gICAgYWRkOiBmdW5jdGlvbiAoYXJyLCBpLCBkb2N1bWVudCkge1xyXG4gICAgICAgIGlmIChoZWxwZXJzXzEuaXNJbnRlZ2VyKGkpKSB7XHJcbiAgICAgICAgICAgIGFyci5zcGxpY2UoaSwgMCwgdGhpcy52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhcnJbaV0gPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0aGlzIG1heSBiZSBuZWVkZWQgd2hlbiB1c2luZyAnLScgaW4gYW4gYXJyYXlcclxuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIGluZGV4OiBpIH07XHJcbiAgICB9LFxyXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoYXJyLCBpLCBkb2N1bWVudCkge1xyXG4gICAgICAgIHZhciByZW1vdmVkTGlzdCA9IGFyci5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCByZW1vdmVkOiByZW1vdmVkTGlzdFswXSB9O1xyXG4gICAgfSxcclxuICAgIHJlcGxhY2U6IGZ1bmN0aW9uIChhcnIsIGksIGRvY3VtZW50KSB7XHJcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBhcnJbaV07XHJcbiAgICAgICAgYXJyW2ldID0gdGhpcy52YWx1ZTtcclxuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHJlbW92ZWQ6IHJlbW92ZWQgfTtcclxuICAgIH0sXHJcbiAgICBtb3ZlOiBvYmpPcHMubW92ZSxcclxuICAgIGNvcHk6IG9iak9wcy5jb3B5LFxyXG4gICAgdGVzdDogb2JqT3BzLnRlc3QsXHJcbiAgICBfZ2V0OiBvYmpPcHMuX2dldFxyXG59O1xyXG4vKipcclxuICogUmV0cmlldmVzIGEgdmFsdWUgZnJvbSBhIEpTT04gZG9jdW1lbnQgYnkgYSBKU09OIHBvaW50ZXIuXHJcbiAqIFJldHVybnMgdGhlIHZhbHVlLlxyXG4gKlxyXG4gKiBAcGFyYW0gZG9jdW1lbnQgVGhlIGRvY3VtZW50IHRvIGdldCB0aGUgdmFsdWUgZnJvbVxyXG4gKiBAcGFyYW0gcG9pbnRlciBhbiBlc2NhcGVkIEpTT04gcG9pbnRlclxyXG4gKiBAcmV0dXJuIFRoZSByZXRyaWV2ZWQgdmFsdWVcclxuICovXHJcbmZ1bmN0aW9uIGdldFZhbHVlQnlQb2ludGVyKGRvY3VtZW50LCBwb2ludGVyKSB7XHJcbiAgICBpZiAocG9pbnRlciA9PSAnJykge1xyXG4gICAgICAgIHJldHVybiBkb2N1bWVudDtcclxuICAgIH1cclxuICAgIHZhciBnZXRPcmlnaW5hbERlc3RpbmF0aW9uID0geyBvcDogXCJfZ2V0XCIsIHBhdGg6IHBvaW50ZXIgfTtcclxuICAgIGFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCBnZXRPcmlnaW5hbERlc3RpbmF0aW9uKTtcclxuICAgIHJldHVybiBnZXRPcmlnaW5hbERlc3RpbmF0aW9uLnZhbHVlO1xyXG59XHJcbmV4cG9ydHMuZ2V0VmFsdWVCeVBvaW50ZXIgPSBnZXRWYWx1ZUJ5UG9pbnRlcjtcclxuLyoqXHJcbiAqIEFwcGx5IGEgc2luZ2xlIEpTT04gUGF0Y2ggT3BlcmF0aW9uIG9uIGEgSlNPTiBkb2N1bWVudC5cclxuICogUmV0dXJucyB0aGUge25ld0RvY3VtZW50LCByZXN1bHR9IG9mIHRoZSBvcGVyYXRpb24uXHJcbiAqIEl0IG1vZGlmaWVzIHRoZSBgZG9jdW1lbnRgIGFuZCBgb3BlcmF0aW9uYCBvYmplY3RzIC0gaXQgZ2V0cyB0aGUgdmFsdWVzIGJ5IHJlZmVyZW5jZS5cclxuICogSWYgeW91IHdvdWxkIGxpa2UgdG8gYXZvaWQgdG91Y2hpbmcgeW91ciB2YWx1ZXMsIGNsb25lIHRoZW06XHJcbiAqIGBqc29ucGF0Y2guYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIGpzb25wYXRjaC5fZGVlcENsb25lKG9wZXJhdGlvbikpYC5cclxuICpcclxuICogQHBhcmFtIGRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBwYXRjaFxyXG4gKiBAcGFyYW0gb3BlcmF0aW9uIFRoZSBvcGVyYXRpb24gdG8gYXBwbHlcclxuICogQHBhcmFtIHZhbGlkYXRlT3BlcmF0aW9uIGBmYWxzZWAgaXMgd2l0aG91dCB2YWxpZGF0aW9uLCBgdHJ1ZWAgdG8gdXNlIGRlZmF1bHQganNvbnBhdGNoJ3MgdmFsaWRhdGlvbiwgb3IgeW91IGNhbiBwYXNzIGEgYHZhbGlkYXRlT3BlcmF0aW9uYCBjYWxsYmFjayB0byBiZSB1c2VkIGZvciB2YWxpZGF0aW9uLlxyXG4gKiBAcGFyYW0gbXV0YXRlRG9jdW1lbnQgV2hldGhlciB0byBtdXRhdGUgdGhlIG9yaWdpbmFsIGRvY3VtZW50IG9yIGNsb25lIGl0IGJlZm9yZSBhcHBseWluZ1xyXG4gKiBAcmV0dXJuIGB7bmV3RG9jdW1lbnQsIHJlc3VsdH1gIGFmdGVyIHRoZSBvcGVyYXRpb25cclxuICovXHJcbmZ1bmN0aW9uIGFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCBvcGVyYXRpb24sIHZhbGlkYXRlT3BlcmF0aW9uLCBtdXRhdGVEb2N1bWVudCkge1xyXG4gICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uID09PSB2b2lkIDApIHsgdmFsaWRhdGVPcGVyYXRpb24gPSBmYWxzZTsgfVxyXG4gICAgaWYgKG11dGF0ZURvY3VtZW50ID09PSB2b2lkIDApIHsgbXV0YXRlRG9jdW1lbnQgPSB0cnVlOyB9XHJcbiAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24pIHtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbGlkYXRlT3BlcmF0aW9uID09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGVPcGVyYXRpb24ob3BlcmF0aW9uLCAwLCBkb2N1bWVudCwgb3BlcmF0aW9uLnBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFsaWRhdG9yKG9wZXJhdGlvbiwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyogUk9PVCBPUEVSQVRJT05TICovXHJcbiAgICBpZiAob3BlcmF0aW9uLnBhdGggPT09IFwiXCIpIHtcclxuICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCB9O1xyXG4gICAgICAgIGlmIChvcGVyYXRpb24ub3AgPT09ICdhZGQnKSB7XHJcbiAgICAgICAgICAgIHJldHVyblZhbHVlLm5ld0RvY3VtZW50ID0gb3BlcmF0aW9uLnZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gJ3JlcGxhY2UnKSB7XHJcbiAgICAgICAgICAgIHJldHVyblZhbHVlLm5ld0RvY3VtZW50ID0gb3BlcmF0aW9uLnZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5yZW1vdmVkID0gZG9jdW1lbnQ7IC8vZG9jdW1lbnQgd2UgcmVtb3ZlZFxyXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gJ21vdmUnIHx8IG9wZXJhdGlvbi5vcCA9PT0gJ2NvcHknKSB7XHJcbiAgICAgICAgICAgIHJldHVyblZhbHVlLm5ld0RvY3VtZW50ID0gZ2V0VmFsdWVCeVBvaW50ZXIoZG9jdW1lbnQsIG9wZXJhdGlvbi5mcm9tKTsgLy8gZ2V0IHRoZSB2YWx1ZSBieSBqc29uLXBvaW50ZXIgaW4gYGZyb21gIGZpZWxkXHJcbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24ub3AgPT09ICdtb3ZlJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUucmVtb3ZlZCA9IGRvY3VtZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSAndGVzdCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuVmFsdWUudGVzdCA9IGFyZUVxdWFscyhkb2N1bWVudCwgb3BlcmF0aW9uLnZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlLnRlc3QgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCAnVEVTVF9PUEVSQVRJT05fRkFJTEVEJywgMCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBkb2N1bWVudDtcclxuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09ICdyZW1vdmUnKSB7XHJcbiAgICAgICAgICAgIHJldHVyblZhbHVlLnJlbW92ZWQgPSBkb2N1bWVudDtcclxuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gJ19nZXQnKSB7XHJcbiAgICAgICAgICAgIG9wZXJhdGlvbi52YWx1ZSA9IGRvY3VtZW50O1xyXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdPcGVyYXRpb24gYG9wYCBwcm9wZXJ0eSBpcyBub3Qgb25lIG9mIG9wZXJhdGlvbnMgZGVmaW5lZCBpbiBSRkMtNjkwMicsICdPUEVSQVRJT05fT1BfSU5WQUxJRCcsIDAsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSAvKiBFTkQgUk9PVCBPUEVSQVRJT05TICovXHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoIW11dGF0ZURvY3VtZW50KSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50ID0gaGVscGVyc18xLl9kZWVwQ2xvbmUoZG9jdW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGF0aCA9IG9wZXJhdGlvbi5wYXRoIHx8IFwiXCI7XHJcbiAgICAgICAgdmFyIGtleXMgPSBwYXRoLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgdmFyIG9iaiA9IGRvY3VtZW50O1xyXG4gICAgICAgIHZhciB0ID0gMTsgLy9za2lwIGVtcHR5IGVsZW1lbnQgLSBodHRwOi8vanNwZXJmLmNvbS90by1zaGlmdC1vci1ub3QtdG8tc2hpZnRcclxuICAgICAgICB2YXIgbGVuID0ga2V5cy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGV4aXN0aW5nUGF0aEZyYWdtZW50ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHZhciBrZXkgPSB2b2lkIDA7XHJcbiAgICAgICAgdmFyIHZhbGlkYXRlRnVuY3Rpb24gPSB2b2lkIDA7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWxpZGF0ZU9wZXJhdGlvbiA9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlRnVuY3Rpb24gPSB2YWxpZGF0ZU9wZXJhdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlRnVuY3Rpb24gPSB2YWxpZGF0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGtleSA9IGtleXNbdF07XHJcbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nUGF0aEZyYWdtZW50ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob2JqW2tleV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1BhdGhGcmFnbWVudCA9IGtleXMuc2xpY2UoMCwgdCkuam9pbignLycpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0ID09IGxlbiAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdQYXRoRnJhZ21lbnQgPSBvcGVyYXRpb24ucGF0aDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nUGF0aEZyYWdtZW50ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVGdW5jdGlvbihvcGVyYXRpb24sIDAsIGRvY3VtZW50LCBleGlzdGluZ1BhdGhGcmFnbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHQrKztcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJy0nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gb2JqLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbiAmJiAhaGVscGVyc18xLmlzSW50ZWdlcihrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKFwiRXhwZWN0ZWQgYW4gdW5zaWduZWQgYmFzZS0xMCBpbnRlZ2VyIHZhbHVlLCBtYWtpbmcgdGhlIG5ldyByZWZlcmVuY2VkIHZhbHVlIHRoZSBhcnJheSBlbGVtZW50IHdpdGggdGhlIHplcm8tYmFzZWQgaW5kZXhcIiwgXCJPUEVSQVRJT05fUEFUSF9JTExFR0FMX0FSUkFZX0lOREVYXCIsIDAsIG9wZXJhdGlvbi5wYXRoLCBvcGVyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gLy8gb25seSBwYXJzZSBrZXkgd2hlbiBpdCdzIGFuIGludGVnZXIgZm9yIGBhcnIucHJvcGAgdG8gd29ya1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhlbHBlcnNfMS5pc0ludGVnZXIoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSB+fmtleTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodCA+PSBsZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24gJiYgb3BlcmF0aW9uLm9wID09PSBcImFkZFwiICYmIGtleSA+IG9iai5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoXCJUaGUgc3BlY2lmaWVkIGluZGV4IE1VU1QgTk9UIGJlIGdyZWF0ZXIgdGhhbiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBhcnJheVwiLCBcIk9QRVJBVElPTl9WQUxVRV9PVVRfT0ZfQk9VTkRTXCIsIDAsIG9wZXJhdGlvbi5wYXRoLCBvcGVyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBhcnJPcHNbb3BlcmF0aW9uLm9wXS5jYWxsKG9wZXJhdGlvbiwgb2JqLCBrZXksIGRvY3VtZW50KTsgLy8gQXBwbHkgcGF0Y2hcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuVmFsdWUudGVzdCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoXCJUZXN0IG9wZXJhdGlvbiBmYWlsZWRcIiwgJ1RFU1RfT1BFUkFUSU9OX0ZBSUxFRCcsIDAsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICYmIGtleS5pbmRleE9mKCd+JykgIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSBoZWxwZXJzXzEudW5lc2NhcGVQYXRoQ29tcG9uZW50KGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodCA+PSBsZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBvYmpPcHNbb3BlcmF0aW9uLm9wXS5jYWxsKG9wZXJhdGlvbiwgb2JqLCBrZXksIGRvY3VtZW50KTsgLy8gQXBwbHkgcGF0Y2hcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuVmFsdWUudGVzdCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoXCJUZXN0IG9wZXJhdGlvbiBmYWlsZWRcIiwgJ1RFU1RfT1BFUkFUSU9OX0ZBSUxFRCcsIDAsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb2JqID0gb2JqW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuYXBwbHlPcGVyYXRpb24gPSBhcHBseU9wZXJhdGlvbjtcclxuLyoqXHJcbiAqIEFwcGx5IGEgZnVsbCBKU09OIFBhdGNoIGFycmF5IG9uIGEgSlNPTiBkb2N1bWVudC5cclxuICogUmV0dXJucyB0aGUge25ld0RvY3VtZW50LCByZXN1bHR9IG9mIHRoZSBwYXRjaC5cclxuICogSXQgbW9kaWZpZXMgdGhlIGBkb2N1bWVudGAgb2JqZWN0IGFuZCBgcGF0Y2hgIC0gaXQgZ2V0cyB0aGUgdmFsdWVzIGJ5IHJlZmVyZW5jZS5cclxuICogSWYgeW91IHdvdWxkIGxpa2UgdG8gYXZvaWQgdG91Y2hpbmcgeW91ciB2YWx1ZXMsIGNsb25lIHRoZW06XHJcbiAqIGBqc29ucGF0Y2guYXBwbHlQYXRjaChkb2N1bWVudCwganNvbnBhdGNoLl9kZWVwQ2xvbmUocGF0Y2gpKWAuXHJcbiAqXHJcbiAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gcGF0Y2hcclxuICogQHBhcmFtIHBhdGNoIFRoZSBwYXRjaCB0byBhcHBseVxyXG4gKiBAcGFyYW0gdmFsaWRhdGVPcGVyYXRpb24gYGZhbHNlYCBpcyB3aXRob3V0IHZhbGlkYXRpb24sIGB0cnVlYCB0byB1c2UgZGVmYXVsdCBqc29ucGF0Y2gncyB2YWxpZGF0aW9uLCBvciB5b3UgY2FuIHBhc3MgYSBgdmFsaWRhdGVPcGVyYXRpb25gIGNhbGxiYWNrIHRvIGJlIHVzZWQgZm9yIHZhbGlkYXRpb24uXHJcbiAqIEByZXR1cm4gQW4gYXJyYXkgb2YgYHtuZXdEb2N1bWVudCwgcmVzdWx0fWAgYWZ0ZXIgdGhlIHBhdGNoXHJcbiAqL1xyXG5mdW5jdGlvbiBhcHBseVBhdGNoKGRvY3VtZW50LCBwYXRjaCwgdmFsaWRhdGVPcGVyYXRpb24pIHtcclxuICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbikge1xyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXRjaCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ1BhdGNoIHNlcXVlbmNlIG11c3QgYmUgYW4gYXJyYXknLCAnU0VRVUVOQ0VfTk9UX0FOX0FSUkFZJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIHJlc3VsdHMgPSBuZXcgQXJyYXkocGF0Y2gubGVuZ3RoKTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGhfMSA9IHBhdGNoLmxlbmd0aDsgaSA8IGxlbmd0aF8xOyBpKyspIHtcclxuICAgICAgICByZXN1bHRzW2ldID0gYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIHBhdGNoW2ldLCB2YWxpZGF0ZU9wZXJhdGlvbik7XHJcbiAgICAgICAgZG9jdW1lbnQgPSByZXN1bHRzW2ldLm5ld0RvY3VtZW50OyAvLyBpbiBjYXNlIHJvb3Qgd2FzIHJlcGxhY2VkXHJcbiAgICB9XHJcbiAgICByZXN1bHRzLm5ld0RvY3VtZW50ID0gZG9jdW1lbnQ7XHJcbiAgICByZXR1cm4gcmVzdWx0cztcclxufVxyXG5leHBvcnRzLmFwcGx5UGF0Y2ggPSBhcHBseVBhdGNoO1xyXG4vKipcclxuICogQXBwbHkgYSBzaW5nbGUgSlNPTiBQYXRjaCBPcGVyYXRpb24gb24gYSBKU09OIGRvY3VtZW50LlxyXG4gKiBSZXR1cm5zIHRoZSB1cGRhdGVkIGRvY3VtZW50LlxyXG4gKiBTdWl0YWJsZSBhcyBhIHJlZHVjZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gcGF0Y2hcclxuICogQHBhcmFtIG9wZXJhdGlvbiBUaGUgb3BlcmF0aW9uIHRvIGFwcGx5XHJcbiAqIEByZXR1cm4gVGhlIHVwZGF0ZWQgZG9jdW1lbnRcclxuICovXHJcbmZ1bmN0aW9uIGFwcGx5UmVkdWNlcihkb2N1bWVudCwgb3BlcmF0aW9uKSB7XHJcbiAgICB2YXIgb3BlcmF0aW9uUmVzdWx0ID0gYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIG9wZXJhdGlvbik7XHJcbiAgICBpZiAob3BlcmF0aW9uUmVzdWx0LnRlc3QgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoXCJUZXN0IG9wZXJhdGlvbiBmYWlsZWRcIiwgJ1RFU1RfT1BFUkFUSU9OX0ZBSUxFRCcsIDAsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9wZXJhdGlvblJlc3VsdC5uZXdEb2N1bWVudDtcclxufVxyXG5leHBvcnRzLmFwcGx5UmVkdWNlciA9IGFwcGx5UmVkdWNlcjtcclxuLyoqXHJcbiAqIFZhbGlkYXRlcyBhIHNpbmdsZSBvcGVyYXRpb24uIENhbGxlZCBmcm9tIGBqc29ucGF0Y2gudmFsaWRhdGVgLiBUaHJvd3MgYEpzb25QYXRjaEVycm9yYCBpbiBjYXNlIG9mIGFuIGVycm9yLlxyXG4gKiBAcGFyYW0ge29iamVjdH0gb3BlcmF0aW9uIC0gb3BlcmF0aW9uIG9iamVjdCAocGF0Y2gpXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIGluZGV4IG9mIG9wZXJhdGlvbiBpbiB0aGUgc2VxdWVuY2VcclxuICogQHBhcmFtIHtvYmplY3R9IFtkb2N1bWVudF0gLSBvYmplY3Qgd2hlcmUgdGhlIG9wZXJhdGlvbiBpcyBzdXBwb3NlZCB0byBiZSBhcHBsaWVkXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZXhpc3RpbmdQYXRoRnJhZ21lbnRdIC0gY29tZXMgYWxvbmcgd2l0aCBgZG9jdW1lbnRgXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0b3Iob3BlcmF0aW9uLCBpbmRleCwgZG9jdW1lbnQsIGV4aXN0aW5nUGF0aEZyYWdtZW50KSB7XHJcbiAgICBpZiAodHlwZW9mIG9wZXJhdGlvbiAhPT0gJ29iamVjdCcgfHwgb3BlcmF0aW9uID09PSBudWxsIHx8IEFycmF5LmlzQXJyYXkob3BlcmF0aW9uKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdPcGVyYXRpb24gaXMgbm90IGFuIG9iamVjdCcsICdPUEVSQVRJT05fTk9UX0FOX09CSkVDVCcsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFvYmpPcHNbb3BlcmF0aW9uLm9wXSkge1xyXG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdPcGVyYXRpb24gYG9wYCBwcm9wZXJ0eSBpcyBub3Qgb25lIG9mIG9wZXJhdGlvbnMgZGVmaW5lZCBpbiBSRkMtNjkwMicsICdPUEVSQVRJT05fT1BfSU5WQUxJRCcsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBvcGVyYXRpb24ucGF0aCAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcignT3BlcmF0aW9uIGBwYXRoYCBwcm9wZXJ0eSBpcyBub3QgYSBzdHJpbmcnLCAnT1BFUkFUSU9OX1BBVEhfSU5WQUxJRCcsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5wYXRoLmluZGV4T2YoJy8nKSAhPT0gMCAmJiBvcGVyYXRpb24ucGF0aC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgLy8gcGF0aHMgdGhhdCBhcmVuJ3QgZW1wdHkgc3RyaW5nIHNob3VsZCBzdGFydCB3aXRoIFwiL1wiXHJcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ09wZXJhdGlvbiBgcGF0aGAgcHJvcGVydHkgbXVzdCBzdGFydCB3aXRoIFwiL1wiJywgJ09QRVJBVElPTl9QQVRIX0lOVkFMSUQnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgob3BlcmF0aW9uLm9wID09PSAnbW92ZScgfHwgb3BlcmF0aW9uLm9wID09PSAnY29weScpICYmIHR5cGVvZiBvcGVyYXRpb24uZnJvbSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcignT3BlcmF0aW9uIGBmcm9tYCBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCAoYXBwbGljYWJsZSBpbiBgbW92ZWAgYW5kIGBjb3B5YCBvcGVyYXRpb25zKScsICdPUEVSQVRJT05fRlJPTV9SRVFVSVJFRCcsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChvcGVyYXRpb24ub3AgPT09ICdhZGQnIHx8IG9wZXJhdGlvbi5vcCA9PT0gJ3JlcGxhY2UnIHx8IG9wZXJhdGlvbi5vcCA9PT0gJ3Rlc3QnKSAmJiBvcGVyYXRpb24udmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdPcGVyYXRpb24gYHZhbHVlYCBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCAoYXBwbGljYWJsZSBpbiBgYWRkYCwgYHJlcGxhY2VgIGFuZCBgdGVzdGAgb3BlcmF0aW9ucyknLCAnT1BFUkFUSU9OX1ZBTFVFX1JFUVVJUkVEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKG9wZXJhdGlvbi5vcCA9PT0gJ2FkZCcgfHwgb3BlcmF0aW9uLm9wID09PSAncmVwbGFjZScgfHwgb3BlcmF0aW9uLm9wID09PSAndGVzdCcpICYmIGhlbHBlcnNfMS5oYXNVbmRlZmluZWQob3BlcmF0aW9uLnZhbHVlKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdPcGVyYXRpb24gYHZhbHVlYCBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCAoYXBwbGljYWJsZSBpbiBgYWRkYCwgYHJlcGxhY2VgIGFuZCBgdGVzdGAgb3BlcmF0aW9ucyknLCAnT1BFUkFUSU9OX1ZBTFVFX0NBTk5PVF9DT05UQUlOX1VOREVGSU5FRCcsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGRvY3VtZW50KSB7XHJcbiAgICAgICAgaWYgKG9wZXJhdGlvbi5vcCA9PSBcImFkZFwiKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXRoTGVuID0gb3BlcmF0aW9uLnBhdGguc3BsaXQoXCIvXCIpLmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIGV4aXN0aW5nUGF0aExlbiA9IGV4aXN0aW5nUGF0aEZyYWdtZW50LnNwbGl0KFwiL1wiKS5sZW5ndGg7XHJcbiAgICAgICAgICAgIGlmIChwYXRoTGVuICE9PSBleGlzdGluZ1BhdGhMZW4gKyAxICYmIHBhdGhMZW4gIT09IGV4aXN0aW5nUGF0aExlbikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ0Nhbm5vdCBwZXJmb3JtIGFuIGBhZGRgIG9wZXJhdGlvbiBhdCB0aGUgZGVzaXJlZCBwYXRoJywgJ09QRVJBVElPTl9QQVRIX0NBTk5PVF9BREQnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSAncmVwbGFjZScgfHwgb3BlcmF0aW9uLm9wID09PSAncmVtb3ZlJyB8fCBvcGVyYXRpb24ub3AgPT09ICdfZ2V0Jykge1xyXG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uLnBhdGggIT09IGV4aXN0aW5nUGF0aEZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcignQ2Fubm90IHBlcmZvcm0gdGhlIG9wZXJhdGlvbiBhdCBhIHBhdGggdGhhdCBkb2VzIG5vdCBleGlzdCcsICdPUEVSQVRJT05fUEFUSF9VTlJFU09MVkFCTEUnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSAnbW92ZScgfHwgb3BlcmF0aW9uLm9wID09PSAnY29weScpIHtcclxuICAgICAgICAgICAgdmFyIGV4aXN0aW5nVmFsdWUgPSB7IG9wOiBcIl9nZXRcIiwgcGF0aDogb3BlcmF0aW9uLmZyb20sIHZhbHVlOiB1bmRlZmluZWQgfTtcclxuICAgICAgICAgICAgdmFyIGVycm9yID0gdmFsaWRhdGUoW2V4aXN0aW5nVmFsdWVdLCBkb2N1bWVudCk7XHJcbiAgICAgICAgICAgIGlmIChlcnJvciAmJiBlcnJvci5uYW1lID09PSAnT1BFUkFUSU9OX1BBVEhfVU5SRVNPTFZBQkxFJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ0Nhbm5vdCBwZXJmb3JtIHRoZSBvcGVyYXRpb24gZnJvbSBhIHBhdGggdGhhdCBkb2VzIG5vdCBleGlzdCcsICdPUEVSQVRJT05fRlJPTV9VTlJFU09MVkFCTEUnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy52YWxpZGF0b3IgPSB2YWxpZGF0b3I7XHJcbi8qKlxyXG4gKiBWYWxpZGF0ZXMgYSBzZXF1ZW5jZSBvZiBvcGVyYXRpb25zLiBJZiBgZG9jdW1lbnRgIHBhcmFtZXRlciBpcyBwcm92aWRlZCwgdGhlIHNlcXVlbmNlIGlzIGFkZGl0aW9uYWxseSB2YWxpZGF0ZWQgYWdhaW5zdCB0aGUgb2JqZWN0IGRvY3VtZW50LlxyXG4gKiBJZiBlcnJvciBpcyBlbmNvdW50ZXJlZCwgcmV0dXJucyBhIEpzb25QYXRjaEVycm9yIG9iamVjdFxyXG4gKiBAcGFyYW0gc2VxdWVuY2VcclxuICogQHBhcmFtIGRvY3VtZW50XHJcbiAqIEByZXR1cm5zIHtKc29uUGF0Y2hFcnJvcnx1bmRlZmluZWR9XHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZShzZXF1ZW5jZSwgZG9jdW1lbnQsIGV4dGVybmFsVmFsaWRhdG9yKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzZXF1ZW5jZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ1BhdGNoIHNlcXVlbmNlIG11c3QgYmUgYW4gYXJyYXknLCAnU0VRVUVOQ0VfTk9UX0FOX0FSUkFZJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkb2N1bWVudCkge1xyXG4gICAgICAgICAgICAvL2Nsb25lIGRvY3VtZW50IGFuZCBzZXF1ZW5jZSBzbyB0aGF0IHdlIGNhbiBzYWZlbHkgdHJ5IGFwcGx5aW5nIG9wZXJhdGlvbnNcclxuICAgICAgICAgICAgYXBwbHlQYXRjaChoZWxwZXJzXzEuX2RlZXBDbG9uZShkb2N1bWVudCksIGhlbHBlcnNfMS5fZGVlcENsb25lKHNlcXVlbmNlKSwgZXh0ZXJuYWxWYWxpZGF0b3IgfHwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBleHRlcm5hbFZhbGlkYXRvciA9IGV4dGVybmFsVmFsaWRhdG9yIHx8IHZhbGlkYXRvcjtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXF1ZW5jZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxWYWxpZGF0b3Ioc2VxdWVuY2VbaV0sIGksIGRvY3VtZW50LCB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIGV4cG9ydHMuSnNvblBhdGNoRXJyb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnRzLnZhbGlkYXRlID0gdmFsaWRhdGU7XHJcbiIsInZhciBlcXVhbHNPcHRpb25zID0geyBzdHJpY3Q6IHRydWUgfTtcclxudmFyIF9lcXVhbHMgPSByZXF1aXJlKCdkZWVwLWVxdWFsJyk7XHJcbnZhciBhcmVFcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgcmV0dXJuIF9lcXVhbHMoYSwgYiwgZXF1YWxzT3B0aW9ucyk7XHJcbn07XHJcbnZhciBoZWxwZXJzXzEgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcclxudmFyIGNvcmVfMSA9IHJlcXVpcmUoJy4vY29yZScpO1xyXG4vKiBleHBvcnQgYWxsIGNvcmUgZnVuY3Rpb25zICovXHJcbnZhciBjb3JlXzIgPSByZXF1aXJlKCcuL2NvcmUnKTtcclxuZXhwb3J0cy5hcHBseU9wZXJhdGlvbiA9IGNvcmVfMi5hcHBseU9wZXJhdGlvbjtcclxuZXhwb3J0cy5hcHBseVBhdGNoID0gY29yZV8yLmFwcGx5UGF0Y2g7XHJcbmV4cG9ydHMuYXBwbHlSZWR1Y2VyID0gY29yZV8yLmFwcGx5UmVkdWNlcjtcclxuZXhwb3J0cy5nZXRWYWx1ZUJ5UG9pbnRlciA9IGNvcmVfMi5nZXRWYWx1ZUJ5UG9pbnRlcjtcclxuZXhwb3J0cy52YWxpZGF0ZSA9IGNvcmVfMi52YWxpZGF0ZTtcclxuZXhwb3J0cy52YWxpZGF0b3IgPSBjb3JlXzIudmFsaWRhdG9yO1xyXG4vKiBleHBvcnQgc29tZSBoZWxwZXJzICovXHJcbnZhciBoZWxwZXJzXzIgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcclxuZXhwb3J0cy5Kc29uUGF0Y2hFcnJvciA9IGhlbHBlcnNfMi5QYXRjaEVycm9yO1xyXG5leHBvcnRzLmRlZXBDbG9uZSA9IGhlbHBlcnNfMi5fZGVlcENsb25lO1xyXG5leHBvcnRzLmVzY2FwZVBhdGhDb21wb25lbnQgPSBoZWxwZXJzXzIuZXNjYXBlUGF0aENvbXBvbmVudDtcclxuZXhwb3J0cy51bmVzY2FwZVBhdGhDb21wb25lbnQgPSBoZWxwZXJzXzIudW5lc2NhcGVQYXRoQ29tcG9uZW50O1xyXG52YXIgYmVmb3JlRGljdCA9IFtdO1xyXG52YXIgTWlycm9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1pcnJvcihvYmopIHtcclxuICAgICAgICB0aGlzLm9ic2VydmVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMub2JqID0gb2JqO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE1pcnJvcjtcclxufSgpKTtcclxudmFyIE9ic2VydmVySW5mbyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBPYnNlcnZlckluZm8oY2FsbGJhY2ssIG9ic2VydmVyKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcclxuICAgIH1cclxuICAgIHJldHVybiBPYnNlcnZlckluZm87XHJcbn0oKSk7XHJcbmZ1bmN0aW9uIGdldE1pcnJvcihvYmopIHtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBiZWZvcmVEaWN0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGJlZm9yZURpY3RbaV0ub2JqID09PSBvYmopIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJlZm9yZURpY3RbaV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldE9ic2VydmVyRnJvbU1pcnJvcihtaXJyb3IsIGNhbGxiYWNrKSB7XHJcbiAgICBmb3IgKHZhciBqID0gMCwgbGVuZ3RoID0gbWlycm9yLm9ic2VydmVycy5sZW5ndGg7IGogPCBsZW5ndGg7IGorKykge1xyXG4gICAgICAgIGlmIChtaXJyb3Iub2JzZXJ2ZXJzW2pdLmNhbGxiYWNrID09PSBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICByZXR1cm4gbWlycm9yLm9ic2VydmVyc1tqXS5vYnNlcnZlcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVtb3ZlT2JzZXJ2ZXJGcm9tTWlycm9yKG1pcnJvciwgb2JzZXJ2ZXIpIHtcclxuICAgIGZvciAodmFyIGogPSAwLCBsZW5ndGggPSBtaXJyb3Iub2JzZXJ2ZXJzLmxlbmd0aDsgaiA8IGxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgaWYgKG1pcnJvci5vYnNlcnZlcnNbal0ub2JzZXJ2ZXIgPT09IG9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgIG1pcnJvci5vYnNlcnZlcnMuc3BsaWNlKGosIDEpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBEZXRhY2ggYW4gb2JzZXJ2ZXIgZnJvbSBhbiBvYmplY3RcclxuICovXHJcbmZ1bmN0aW9uIHVub2JzZXJ2ZShyb290LCBvYnNlcnZlcikge1xyXG4gICAgb2JzZXJ2ZXIudW5vYnNlcnZlKCk7XHJcbn1cclxuZXhwb3J0cy51bm9ic2VydmUgPSB1bm9ic2VydmU7XHJcbi8qKlxyXG4gKiBPYnNlcnZlcyBjaGFuZ2VzIG1hZGUgdG8gYW4gb2JqZWN0LCB3aGljaCBjYW4gdGhlbiBiZSByZXRyaWV2ZWQgdXNpbmcgZ2VuZXJhdGVcclxuICovXHJcbmZ1bmN0aW9uIG9ic2VydmUob2JqLCBjYWxsYmFjaykge1xyXG4gICAgdmFyIHBhdGNoZXMgPSBbXTtcclxuICAgIHZhciByb290ID0gb2JqO1xyXG4gICAgdmFyIG9ic2VydmVyO1xyXG4gICAgdmFyIG1pcnJvciA9IGdldE1pcnJvcihvYmopO1xyXG4gICAgaWYgKCFtaXJyb3IpIHtcclxuICAgICAgICBtaXJyb3IgPSBuZXcgTWlycm9yKG9iaik7XHJcbiAgICAgICAgYmVmb3JlRGljdC5wdXNoKG1pcnJvcik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBvYnNlcnZlciA9IGdldE9ic2VydmVyRnJvbU1pcnJvcihtaXJyb3IsIGNhbGxiYWNrKTtcclxuICAgIH1cclxuICAgIGlmIChvYnNlcnZlcikge1xyXG4gICAgICAgIHJldHVybiBvYnNlcnZlcjtcclxuICAgIH1cclxuICAgIG9ic2VydmVyID0ge307XHJcbiAgICBtaXJyb3IudmFsdWUgPSBoZWxwZXJzXzEuX2RlZXBDbG9uZShvYmopO1xyXG4gICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgb2JzZXJ2ZXIuY2FsbGJhY2sgPSBjYWxsYmFjaztcclxuICAgICAgICBvYnNlcnZlci5uZXh0ID0gbnVsbDtcclxuICAgICAgICB2YXIgZGlydHlDaGVjayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZ2VuZXJhdGUob2JzZXJ2ZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIGZhc3RDaGVjayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KG9ic2VydmVyLm5leHQpO1xyXG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0ID0gc2V0VGltZW91dChkaXJ0eUNoZWNrKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBpZiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZmFzdENoZWNrKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGZhc3RDaGVjayk7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZmFzdENoZWNrKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZmFzdENoZWNrKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmYXN0Q2hlY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmF0dGFjaEV2ZW50KCdvbm1vdXNldXAnLCBmYXN0Q2hlY2spO1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmF0dGFjaEV2ZW50KCdvbmtleXVwJywgZmFzdENoZWNrKTtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hdHRhY2hFdmVudCgnb25tb3VzZWRvd24nLCBmYXN0Q2hlY2spO1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmF0dGFjaEV2ZW50KCdvbmtleWRvd24nLCBmYXN0Q2hlY2spO1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmF0dGFjaEV2ZW50KCdvbmNoYW5nZScsIGZhc3RDaGVjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvYnNlcnZlci5wYXRjaGVzID0gcGF0Y2hlcztcclxuICAgIG9ic2VydmVyLm9iamVjdCA9IG9iajtcclxuICAgIG9ic2VydmVyLnVub2JzZXJ2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBnZW5lcmF0ZShvYnNlcnZlcik7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KG9ic2VydmVyLm5leHQpO1xyXG4gICAgICAgIHJlbW92ZU9ic2VydmVyRnJvbU1pcnJvcihtaXJyb3IsIG9ic2VydmVyKTtcclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgaWYgKHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGZhc3RDaGVjayk7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBmYXN0Q2hlY2spO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGZhc3RDaGVjayk7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZhc3RDaGVjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZGV0YWNoRXZlbnQoJ29ubW91c2V1cCcsIGZhc3RDaGVjayk7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZGV0YWNoRXZlbnQoJ29ua2V5dXAnLCBmYXN0Q2hlY2spO1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRldGFjaEV2ZW50KCdvbm1vdXNlZG93bicsIGZhc3RDaGVjayk7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZGV0YWNoRXZlbnQoJ29ua2V5ZG93bicsIGZhc3RDaGVjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgbWlycm9yLm9ic2VydmVycy5wdXNoKG5ldyBPYnNlcnZlckluZm8oY2FsbGJhY2ssIG9ic2VydmVyKSk7XHJcbiAgICByZXR1cm4gb2JzZXJ2ZXI7XHJcbn1cclxuZXhwb3J0cy5vYnNlcnZlID0gb2JzZXJ2ZTtcclxuLyoqXHJcbiAqIEdlbmVyYXRlIGFuIGFycmF5IG9mIHBhdGNoZXMgZnJvbSBhbiBvYnNlcnZlclxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGUob2JzZXJ2ZXIpIHtcclxuICAgIHZhciBtaXJyb3I7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYmVmb3JlRGljdC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChiZWZvcmVEaWN0W2ldLm9iaiA9PT0gb2JzZXJ2ZXIub2JqZWN0KSB7XHJcbiAgICAgICAgICAgIG1pcnJvciA9IGJlZm9yZURpY3RbaV07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9nZW5lcmF0ZShtaXJyb3IudmFsdWUsIG9ic2VydmVyLm9iamVjdCwgb2JzZXJ2ZXIucGF0Y2hlcywgXCJcIik7XHJcbiAgICBpZiAob2JzZXJ2ZXIucGF0Y2hlcy5sZW5ndGgpIHtcclxuICAgICAgICBjb3JlXzEuYXBwbHlQYXRjaChtaXJyb3IudmFsdWUsIG9ic2VydmVyLnBhdGNoZXMpO1xyXG4gICAgfVxyXG4gICAgdmFyIHRlbXAgPSBvYnNlcnZlci5wYXRjaGVzO1xyXG4gICAgaWYgKHRlbXAubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIG9ic2VydmVyLnBhdGNoZXMgPSBbXTtcclxuICAgICAgICBpZiAob2JzZXJ2ZXIuY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIuY2FsbGJhY2sodGVtcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRlbXA7XHJcbn1cclxuZXhwb3J0cy5nZW5lcmF0ZSA9IGdlbmVyYXRlO1xyXG4vLyBEaXJ0eSBjaGVjayBpZiBvYmogaXMgZGlmZmVyZW50IGZyb20gbWlycm9yLCBnZW5lcmF0ZSBwYXRjaGVzIGFuZCB1cGRhdGUgbWlycm9yXHJcbmZ1bmN0aW9uIF9nZW5lcmF0ZShtaXJyb3IsIG9iaiwgcGF0Y2hlcywgcGF0aCkge1xyXG4gICAgaWYgKG9iaiA9PT0gbWlycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBvYmoudG9KU09OID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICBvYmogPSBvYmoudG9KU09OKCk7XHJcbiAgICB9XHJcbiAgICB2YXIgbmV3S2V5cyA9IGhlbHBlcnNfMS5fb2JqZWN0S2V5cyhvYmopO1xyXG4gICAgdmFyIG9sZEtleXMgPSBoZWxwZXJzXzEuX29iamVjdEtleXMobWlycm9yKTtcclxuICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XHJcbiAgICB2YXIgZGVsZXRlZCA9IGZhbHNlO1xyXG4gICAgLy9pZiBldmVyIFwibW92ZVwiIG9wZXJhdGlvbiBpcyBpbXBsZW1lbnRlZCBoZXJlLCBtYWtlIHN1cmUgdGhpcyB0ZXN0IHJ1bnMgT0s6IFwic2hvdWxkIG5vdCBnZW5lcmF0ZSB0aGUgc2FtZSBwYXRjaCB0d2ljZSAobW92ZSlcIlxyXG4gICAgZm9yICh2YXIgdCA9IG9sZEtleXMubGVuZ3RoIC0gMTsgdCA+PSAwOyB0LS0pIHtcclxuICAgICAgICB2YXIga2V5ID0gb2xkS2V5c1t0XTtcclxuICAgICAgICB2YXIgb2xkVmFsID0gbWlycm9yW2tleV07XHJcbiAgICAgICAgaWYgKGhlbHBlcnNfMS5oYXNPd25Qcm9wZXJ0eShvYmosIGtleSkgJiYgIShvYmpba2V5XSA9PT0gdW5kZWZpbmVkICYmIG9sZFZhbCAhPT0gdW5kZWZpbmVkICYmIEFycmF5LmlzQXJyYXkob2JqKSA9PT0gZmFsc2UpKSB7XHJcbiAgICAgICAgICAgIHZhciBuZXdWYWwgPSBvYmpba2V5XTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbGRWYWwgPT0gXCJvYmplY3RcIiAmJiBvbGRWYWwgIT0gbnVsbCAmJiB0eXBlb2YgbmV3VmFsID09IFwib2JqZWN0XCIgJiYgbmV3VmFsICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIF9nZW5lcmF0ZShvbGRWYWwsIG5ld1ZhbCwgcGF0Y2hlcywgcGF0aCArIFwiL1wiICsgaGVscGVyc18xLmVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob2xkVmFsICE9PSBuZXdWYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaGVzLnB1c2goeyBvcDogXCJyZXBsYWNlXCIsIHBhdGg6IHBhdGggKyBcIi9cIiArIGhlbHBlcnNfMS5lc2NhcGVQYXRoQ29tcG9uZW50KGtleSksIHZhbHVlOiBoZWxwZXJzXzEuX2RlZXBDbG9uZShuZXdWYWwpIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXRjaGVzLnB1c2goeyBvcDogXCJyZW1vdmVcIiwgcGF0aDogcGF0aCArIFwiL1wiICsgaGVscGVyc18xLmVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSB9KTtcclxuICAgICAgICAgICAgZGVsZXRlZCA9IHRydWU7IC8vIHByb3BlcnR5IGhhcyBiZWVuIGRlbGV0ZWRcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIWRlbGV0ZWQgJiYgbmV3S2V5cy5sZW5ndGggPT0gb2xkS2V5cy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IG5ld0tleXMubGVuZ3RoOyB0KyspIHtcclxuICAgICAgICB2YXIga2V5ID0gbmV3S2V5c1t0XTtcclxuICAgICAgICBpZiAoIWhlbHBlcnNfMS5oYXNPd25Qcm9wZXJ0eShtaXJyb3IsIGtleSkgJiYgb2JqW2tleV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBwYXRjaGVzLnB1c2goeyBvcDogXCJhZGRcIiwgcGF0aDogcGF0aCArIFwiL1wiICsgaGVscGVyc18xLmVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSwgdmFsdWU6IGhlbHBlcnNfMS5fZGVlcENsb25lKG9ialtrZXldKSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZSBhbiBhcnJheSBvZiBwYXRjaGVzIGZyb20gdGhlIGRpZmZlcmVuY2VzIGluIHR3byBvYmplY3RzXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wYXJlKHRyZWUxLCB0cmVlMikge1xyXG4gICAgdmFyIHBhdGNoZXMgPSBbXTtcclxuICAgIF9nZW5lcmF0ZSh0cmVlMSwgdHJlZTIsIHBhdGNoZXMsICcnKTtcclxuICAgIHJldHVybiBwYXRjaGVzO1xyXG59XHJcbmV4cG9ydHMuY29tcGFyZSA9IGNvbXBhcmU7XHJcbiIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbi8qIVxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vU3RhcmNvdW50ZXItSmFjay9KU09OLVBhdGNoXHJcbiAqIChjKSAyMDE3IEpvYWNoaW0gV2VzdGVyXHJcbiAqIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG52YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcclxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBrZXkpIHtcclxuICAgIHJldHVybiBfaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XHJcbn1cclxuZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eSA9IGhhc093blByb3BlcnR5O1xyXG5mdW5jdGlvbiBfb2JqZWN0S2V5cyhvYmopIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcclxuICAgICAgICB2YXIga2V5cyA9IG5ldyBBcnJheShvYmoubGVuZ3RoKTtcclxuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGtleXMubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAga2V5c1trXSA9IFwiXCIgKyBrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ga2V5cztcclxuICAgIH1cclxuICAgIGlmIChPYmplY3Qua2V5cykge1xyXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopO1xyXG4gICAgfVxyXG4gICAgdmFyIGtleXMgPSBbXTtcclxuICAgIGZvciAodmFyIGkgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5KG9iaiwgaSkpIHtcclxuICAgICAgICAgICAga2V5cy5wdXNoKGkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBrZXlzO1xyXG59XHJcbmV4cG9ydHMuX29iamVjdEtleXMgPSBfb2JqZWN0S2V5cztcclxuO1xyXG4vKipcclxuKiBEZWVwbHkgY2xvbmUgdGhlIG9iamVjdC5cclxuKiBodHRwczovL2pzcGVyZi5jb20vZGVlcC1jb3B5LXZzLWpzb24tc3RyaW5naWZ5LWpzb24tcGFyc2UvMjUgKHJlY3Vyc2l2ZURlZXBDb3B5KVxyXG4qIEBwYXJhbSAge2FueX0gb2JqIHZhbHVlIHRvIGNsb25lXHJcbiogQHJldHVybiB7YW55fSBjbG9uZWQgb2JqXHJcbiovXHJcbmZ1bmN0aW9uIF9kZWVwQ2xvbmUob2JqKSB7XHJcbiAgICBzd2l0Y2ggKHR5cGVvZiBvYmopIHtcclxuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XHJcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpOyAvL0Zhc3RlciB0aGFuIEVTNSBjbG9uZSAtIGh0dHA6Ly9qc3BlcmYuY29tL2RlZXAtY2xvbmluZy1vZi1vYmplY3RzLzVcclxuICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsOyAvL3RoaXMgaXMgaG93IEpTT04uc3RyaW5naWZ5IGJlaGF2ZXMgZm9yIGFycmF5IGl0ZW1zXHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIG9iajsgLy9ubyBuZWVkIHRvIGNsb25lIHByaW1pdGl2ZXNcclxuICAgIH1cclxufVxyXG5leHBvcnRzLl9kZWVwQ2xvbmUgPSBfZGVlcENsb25lO1xyXG4vLzN4IGZhc3RlciB0aGFuIGNhY2hlZCAvXlxcZCskLy50ZXN0KHN0cilcclxuZnVuY3Rpb24gaXNJbnRlZ2VyKHN0cikge1xyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgdmFyIGxlbiA9IHN0ci5sZW5ndGg7XHJcbiAgICB2YXIgY2hhckNvZGU7XHJcbiAgICB3aGlsZSAoaSA8IGxlbikge1xyXG4gICAgICAgIGNoYXJDb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaWYgKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSB7XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmV4cG9ydHMuaXNJbnRlZ2VyID0gaXNJbnRlZ2VyO1xyXG4vKipcclxuKiBFc2NhcGVzIGEganNvbiBwb2ludGVyIHBhdGhcclxuKiBAcGFyYW0gcGF0aCBUaGUgcmF3IHBvaW50ZXJcclxuKiBAcmV0dXJuIHRoZSBFc2NhcGVkIHBhdGhcclxuKi9cclxuZnVuY3Rpb24gZXNjYXBlUGF0aENvbXBvbmVudChwYXRoKSB7XHJcbiAgICBpZiAocGF0aC5pbmRleE9mKCcvJykgPT09IC0xICYmIHBhdGguaW5kZXhPZignficpID09PSAtMSlcclxuICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL34vZywgJ34wJykucmVwbGFjZSgvXFwvL2csICd+MScpO1xyXG59XHJcbmV4cG9ydHMuZXNjYXBlUGF0aENvbXBvbmVudCA9IGVzY2FwZVBhdGhDb21wb25lbnQ7XHJcbi8qKlxyXG4gKiBVbmVzY2FwZXMgYSBqc29uIHBvaW50ZXIgcGF0aFxyXG4gKiBAcGFyYW0gcGF0aCBUaGUgZXNjYXBlZCBwb2ludGVyXHJcbiAqIEByZXR1cm4gVGhlIHVuZXNjYXBlZCBwYXRoXHJcbiAqL1xyXG5mdW5jdGlvbiB1bmVzY2FwZVBhdGhDb21wb25lbnQocGF0aCkge1xyXG4gICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvfjEvZywgJy8nKS5yZXBsYWNlKC9+MC9nLCAnficpO1xyXG59XHJcbmV4cG9ydHMudW5lc2NhcGVQYXRoQ29tcG9uZW50ID0gdW5lc2NhcGVQYXRoQ29tcG9uZW50O1xyXG5mdW5jdGlvbiBfZ2V0UGF0aFJlY3Vyc2l2ZShyb290LCBvYmopIHtcclxuICAgIHZhciBmb3VuZDtcclxuICAgIGZvciAodmFyIGtleSBpbiByb290KSB7XHJcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5KHJvb3QsIGtleSkpIHtcclxuICAgICAgICAgICAgaWYgKHJvb3Rba2V5XSA9PT0gb2JqKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXNjYXBlUGF0aENvbXBvbmVudChrZXkpICsgJy8nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiByb290W2tleV0gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICBmb3VuZCA9IF9nZXRQYXRoUmVjdXJzaXZlKHJvb3Rba2V5XSwgb2JqKTtcclxuICAgICAgICAgICAgICAgIGlmIChmb3VuZCAhPSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlc2NhcGVQYXRoQ29tcG9uZW50KGtleSkgKyAnLycgKyBmb3VuZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAnJztcclxufVxyXG5leHBvcnRzLl9nZXRQYXRoUmVjdXJzaXZlID0gX2dldFBhdGhSZWN1cnNpdmU7XHJcbmZ1bmN0aW9uIGdldFBhdGgocm9vdCwgb2JqKSB7XHJcbiAgICBpZiAocm9vdCA9PT0gb2JqKSB7XHJcbiAgICAgICAgcmV0dXJuICcvJztcclxuICAgIH1cclxuICAgIHZhciBwYXRoID0gX2dldFBhdGhSZWN1cnNpdmUocm9vdCwgb2JqKTtcclxuICAgIGlmIChwYXRoID09PSAnJykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9iamVjdCBub3QgZm91bmQgaW4gcm9vdFwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiAnLycgKyBwYXRoO1xyXG59XHJcbmV4cG9ydHMuZ2V0UGF0aCA9IGdldFBhdGg7XHJcbi8qKlxyXG4qIFJlY3Vyc2l2ZWx5IGNoZWNrcyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYW55IHVuZGVmaW5lZCB2YWx1ZXMgaW5zaWRlLlxyXG4qL1xyXG5mdW5jdGlvbiBoYXNVbmRlZmluZWQob2JqKSB7XHJcbiAgICBpZiAob2JqID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChvYmopIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChoYXNVbmRlZmluZWQob2JqW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgdmFyIG9iaktleXMgPSBfb2JqZWN0S2V5cyhvYmopO1xyXG4gICAgICAgICAgICB2YXIgb2JqS2V5c0xlbmd0aCA9IG9iaktleXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iaktleXNMZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc1VuZGVmaW5lZChvYmpbb2JqS2V5c1tpXV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZXhwb3J0cy5oYXNVbmRlZmluZWQgPSBoYXNVbmRlZmluZWQ7XHJcbnZhciBQYXRjaEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhQYXRjaEVycm9yLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUGF0Y2hFcnJvcihtZXNzYWdlLCBuYW1lLCBpbmRleCwgb3BlcmF0aW9uLCB0cmVlKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSk7XHJcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcclxuICAgICAgICB0aGlzLm9wZXJhdGlvbiA9IG9wZXJhdGlvbjtcclxuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFBhdGNoRXJyb3I7XHJcbn0oRXJyb3IpKTtcclxuZXhwb3J0cy5QYXRjaEVycm9yID0gUGF0Y2hFcnJvcjtcclxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBtYXAob2JqW2tdLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBtYXAgKHhzLCBmKSB7XG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiIsImNvbnN0IEVuZHBvaW50Q29uZmlnID0gcmVxdWlyZSgnLi9lbmRwb2ludC1jb25maWcuY2xhc3MuanMnKTtcbmNvbnN0IEVuZHBvaW50ID0gcmVxdWlyZSgnLi9lbmRwb2ludC5jbGFzcy5qcycpO1xuY29uc3QgQ2FjaGUgPSByZXF1aXJlKCcuL2NhY2hlLmNsYXNzJyk7XG5jb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4vdXRpbHMuY2xhc3MnKS5jbG9uZTtcblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBiYXNlIGNvbmZpZ3VyYXRpb24gZm9yIGFuIEFQSVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIEFQSUNvbmZpZyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY29uZmlnID0geyBoZWFkZXJzIDoge30sIHVybCA6ICcnIH07XG4gICAgdGhpcy5lbmRwb2ludHMgPSB7fTtcbiAgICB0aGlzLmNhY2hlID0gbmV3IENhY2hlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgLyBTZXRzIGJhc2UgYXBpIHVybFxuICAgKiBAcGFyYW0ge3N0cmluZz19IHVybCAtIEJhc2UgdXJsIHRoYXQgdGhpcyBlbmRwb2ludCB0YWxrcyB0b1xuICAgKiBAcmV0dXJucyB7KHRoaXN8c3RyaW5nKX1cbiAgICovXG4gIGJhc2VVcmwodXJsKSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgdXJsKSB7XG4gICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB1cmwpIHtcbiAgICAgICAgdGhpcy5jb25maWcudXJsID0gdXJsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbmZpZy51cmw7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgZW5kcG9pbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVuZHBvaW50TmFtZSAtIFRoZSBuYW1lIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGdldCB0aGlzIGVuZHBvaW50XG4gICAqIEByZXR1cm5zIHtAbGluayBFbmRwb2ludH0gQW4gaW5zdGFuY2Ugb2YgRW5kcG9pbnRcbiAgICovXG4gIGVuZHBvaW50KGVuZHBvaW50TmFtZSA9ICdfX2RlZmF1bHRfXycpIHtcbiAgICBsZXQgY29uZmlnID0gbmV3IEVuZHBvaW50Q29uZmlnKCkuYXBpKHRoaXMpO1xuICAgIHRoaXNbIGVuZHBvaW50TmFtZSBdID0gbmV3IEVuZHBvaW50KGNvbmZpZyk7XG4gICAgcmV0dXJuIHRoaXNbIGVuZHBvaW50TmFtZSBdO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGhlYWRlcnMgdGhhdCBhbGwgY2FsbHMgd2lsbCB1c2UuIEhlbHBmdWwgZm9yIGF1dGhlbnRpY2F0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0PX0gaGVhZGVycyAtIEtleSAvIHZhbHVlIHBhaXJzIG9mIGhlYWRlcnNcbiAgICogQHJldHVybnMge3RoaXMgfCBvYmplY3R9XG4gICAqL1xuICBjb21tb25IZWFkZXJzKGhlYWRlcnMpIHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBoZWFkZXJzKSB7XG4gICAgICB0aGlzLmNvbmZpZy5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY2xvbmUodGhpcy5jb25maWcuaGVhZGVycyk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQVBJQ29uZmlnOyIsIi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIENhY2hlIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIGNhY2hlIG9iamVjdFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5vYmplY3RzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgdHRsIDogNjAwMDAsXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2hlcyBhbiBvYmplY3QgZnJvbSB0aGUgY2FjaGUgdXNpbmcgdGhlIG9iamVjdCdzIG5hbWUgKHR5cGljYWxseSB0aGUgdXJsKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBcbiAgICogQHJldHVybnMgeyhvYmplY3R8QXJyYXl8dW5kZWZpbmVkKX0gVGhlIGZvdW5kIG9iamVjdCBvciBhcnJheSBpZiBleGlzdHMsIG90aGVyd2lzZSB1bmRlZmluZWRcbiAgICovXG4gIGdldChuYW1lKSB7XG4gICAgbGV0IG5vdyA9IERhdGUubm93KCk7XG4gICAgbGV0IG9iaiA9IHRoaXMub2JqZWN0cy5nZXQobmFtZSk7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2Ygb2JqICYmIG5vdyAtIG9ialswXSA8IHRoaXMuY29uZmlnLnR0bCkge1xuICAgICAgbGV0IGNhY2hlZE9iamVjdCA9IG9ialsxXTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjYWNoZWRPYmplY3QsJ19fZnJvbUNhY2hlJywge3ZhbHVlIDogdHJ1ZX0pO1xuICAgICAgcmV0dXJuIGNhY2hlZE9iamVjdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vYmplY3RzLmRlbGV0ZShuYW1lKTsgLy9pbiBjYXNlIHRoZSBvYmplY3QgZXhpc3RzIGJ1dCBoYXMgZXhwaXJlZFxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFN0b3JlcyBhbnkgb2JqZWN0IG9yIHByaW1pdGl2ZSBpbnRvIHRoZSBjYWNoZSB1c2luZyBpdCdzIG5hbWVcbiAgICogTk9URTogUHJpbWl0aXZlcyBXSUxMIGJlIGNvbnZlcnRlZCB0byBvYmplY3RzIHByaW9yIHRvIGNhY2hpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgXG4gICAqIEBwYXJhbSB7KHN0cmluZ3xudW1iZXJ8Ym9vbGVhbnxvYmplY3QpfSB2YWx1ZSBcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHN1Y2Nlc3NcbiAgICovXG4gIHB1dChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIG5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBuYW1lIGF0dHJpYnV0ZScpO1xuICAgIH1cbiAgICAvL2NvbnZlcnQgcHJpbWl0aXZlIHN0cmluZ3MgdG8gc3RyaW5nIG9iamVjdHMgc28gd2UgY2FuIGFkZCBfX2Zyb21DYWNoZWRcbiAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB2YWx1ZSkge1xuICAgICAgdmFsdWUgPSBuZXcgU3RyaW5nKHZhbHVlKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgfVxuICAgIGlmICgnbnVtYmVyJyA9PT0gdHlwZW9mIHZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IG5ldyBOdW1iZXIodmFsdWUpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICB9XG4gICAgaWYgKCdib29sZWFuJyA9PT0gdHlwZW9mIHZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IG5ldyBCb29sZWFuKHZhbHVlKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lICAgICAgXG4gICAgfVxuICAgIHRoaXMub2JqZWN0cy5zZXQobmFtZSwgW0RhdGUubm93KCksIHZhbHVlXSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gb2JqZWN0IGZyb20gdGhlIGNhY2hlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFxuICAgKi9cbiAgaW52YWxpZGF0ZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMub2JqZWN0cy5kZWxldGUobmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIENoYW5nZXMgdGhlIGRlZmF1bHQgdGltZSB0byBsaXZlIG9mIG9iamVjdHMgaW4gdGhlIGNhY2hlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdUVEwgXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBzdWNjZXNzXG4gICAqL1xuICBzZXRUVEwobmV3VFRMKSB7XG4gICAgaWYgKCdudW1iZXInICE9PSB0eXBlb2YgbmV3VFRMKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgVFRMIHZhbHVlJyk7XG4gICAgfVxuICAgIHRoaXMuY29uZmlnLnR0bCA9IG5ld1RUTDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuIFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENhY2hlOyIsImNvbnN0IE1vZGVsID0gcmVxdWlyZSgnLi9tb2RlbC5jbGFzcycpO1xuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuL3V0aWxzLmNsYXNzJykuY2xvbmU7XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBFbmRwb2ludENvbmZpZyB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgdGhpcy5jb25maWcgPSB7IGFwaSA6IHt9fTtcblxuICAgIGxldCBkZWZhdWx0cyA9IHtcbiAgICAgICd1cmwnIDogJy8nLFxuICAgICAgJ3Jlc3BvbnNlVHlwZScgOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICdpbnN0YW50aWF0b3InIDogTW9kZWxcbiAgICB9O1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5jb25maWcsIGRlZmF1bHRzLCBjbG9uZShjb25maWcpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIG9yIHNldHMgdGhlIGV4cGVjdGVkIG1lZGlhIHJldHVybiB0eXBlLiBVbHRpbWF0ZWx5LCBpdCBpcyB1cCB0byB0aGUgdHJhbnNwb3J0XG4gICAqIHRvIHVzZSB0aGlzIHNldHRpbmcgdG8gY29ycmVjdGx5IHRhbGsgdG8gdGhlIGFwaVxuICAgKiBOb3RlIC0gVGhpcyBpcyBjdXJyZW50bHkgdW51c2VkXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbmV3VHlwZSAtIFRoZSBuZXcgbWVkaWEgdHlwZSB0aGF0IHRoaXMgZW5kcG9pbnQgY29tbXVuaWNhdGVzIHdpdGhcbiAgICovXG4gIG1lZGlhVHlwZShuZXdUeXBlKSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbmV3VHlwZSkge1xuICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgbmV3VHlwZSkge1xuICAgICAgICB0aGlzLmNvbmZpZy5yZXNwb25zZVR5cGUgPSBuZXdUeXBlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbmZpZy5yZXNwb25zZVR5cGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyAvIHNldHMgdGhlIEFQSSBjb25maWd1cmF0aW9uIG9iamVjdC4gVGhpcyBpcyBuZWVkZWQgc28gZWFjaFxuICAgKiBlbmRwb2ludCBjYW4gc2hhcmUgY29tbW9uIHNldHRpbmdzXG4gICAqIEBwYXJhbSB7QVBJQ29uZmlnfSBjb25maWcgLSBUaGUgcGFyZW50IGFwaSBjb25maWd1cmF0aW9uIFxuICAgKiBAcmV0dXJucyB7KHRoaXMgfCBvYmplY3QpfVxuICAgKi9cbiAgYXBpKGNvbmZpZykge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGNvbmZpZykge1xuICAgICAgaWYgKCdvYmplY3QnID09PSB0eXBlb2YgY29uZmlnICYmIGNvbmZpZyAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5hcGkgPSBjbG9uZShjb25maWcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbmZpZy5hcGk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgYmFzZSB1cmwgZnJvbSB0aGUgdW5kZXJseWluZyBhcGkgY29uZmlndXJhdGlvbiBcbiAgICogQHJldHVybnMge3N0cmluZ30gQ3VycmVudCByb290IHVybFxuICAgKi9cbiAgYmFzZVVybCgpIHtcbiAgICBpZiAoIXRoaXMuY29uZmlnLmFwaSB8fCAhdGhpcy5jb25maWcuYXBpLmJhc2VVcmwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmFwaS5iYXNlVXJsKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgLyBzZXRzIHRoZSBlbmRwb2ludCdzIHJlbGF0aXZlIHVybFxuICAgKiBAcGFyYW0ge3N0cmluZz19IG5ld1VybCAtIFVybCB0byB1c2UgZm9yIHRoaXMgZW5kcG9pbnRcbiAgICogQHJldHVybnMgeyh0aGlzIHwgc3RyaW5nKX0gVGhpcyBpbnN0YW5jZSBvciB0aGUgY3VycmVudCB1cmxcbiAgICovXG4gIHVybChuZXdVcmwpIHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBuZXdVcmwpIHtcbiAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIG5ld1VybCkge1xuICAgICAgICB0aGlzLmNvbmZpZy51cmwgPSBuZXdVcmw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLnVybDtcbiAgfVxuICAvKipcbiAgICogR2V0cyAvIHNldHMgdGhlIGluc3RhbnRpYXRvciBmdW5jdGlvbiB0byB1c2Ugd2hlbiBjcmVhdGluZyBhIG5ldyBtb2RlbC4gXG4gICAqIEBwYXJhbSB7KGZ1bmN0aW9ufGNsYXNzKT19IGluc3RhbnRpYXRvciAtIHRoZSBmdW5jdGlvbiBvciBjbGFzcyB0byB1c2UgZm9yIGluc3RhbnRpYXRpb25cbiAgICogQHJldHVybnMgeyh0aGlzfGZ1bmN0aW9uKX0gVGhpcyBpbnN0YW5jZSBvciB0aGUgY3VycmVudCBpbnNhbnRpYXRpb24gZnVuY3Rpb24gXG4gICAqL1xuICBtb2RlbChuZXdGbikge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG5ld0ZuKSB7XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIG5ld0ZuKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmluc3RhbnRpYXRvciA9IG5ld0ZuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbmZpZy5pbnN0YW50aWF0b3I7XG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVuZHBvaW50Q29uZmlnOyIsImNvbnN0IFVSTEJ1aWxkZXIgPSByZXF1aXJlKCcuL3VybC1idWlsZGVyLmNsYXNzJyk7XG5jb25zdCBSZXF1ZXN0ID0gcmVxdWlyZSgnLi9yZXF1ZXN0LmNsYXNzJyk7XG5jb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4vdXRpbHMuY2xhc3MnKS5jbG9uZTtcbmNvbnN0IG5vb3AgPSByZXF1aXJlKCcuL3V0aWxzLmNsYXNzJykubm9vcDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVuZHBvaW50IGluc3RhbmNlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgRW5kcG9pbnQge1xuICBjb25zdHJ1Y3RvcihlbmRwb2ludENvbmZpZyA9IHt9KSB7XG4gICAgaWYgKCFlbmRwb2ludENvbmZpZyB8fCAnZnVuY3Rpb24nICE9PSB0eXBlb2YgZW5kcG9pbnRDb25maWcubW9kZWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBlbmRwb2ludCBjb25maWd1cmF0aW9uLicpO1xuICAgIH1cbiAgICB0aGlzLmVuZHBvaW50Q29uZmlnID0gY2xvbmUoZW5kcG9pbnRDb25maWcpO1xuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgYWxsb3dGcm9tQ2FjaGUgOiB0cnVlLFxuICAgICAgbWV0aG9kIDogJ2dldCcsXG4gICAgICB0YXJnZXQgOiAnJyxcbiAgICAgIHF1ZXJ5IDoge31cbiAgICB9O1xuICAgIHRoaXMuY2FjaGUgPSB0aGlzLmVuZHBvaW50Q29uZmlnLmFwaSgpLmNhY2hlO1xuICB9XG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZXMgYSBuZXcgbW9kZWwgaW5zdGFuY2UgYW5kIHJldHVybnMgaXRcbiAgICogQHBhcmFtIHtvYmplY3Q9fSBkYXRhIC0gSW5pdGlhbGl6YXRpb24gZGF0YSBmb3IgdGhlIG5ldyBtb2RlbCBpbnN0YW5jZVxuICAgKiBAcmV0dXJucyB7QGxpbmsgTW9kZWx9IE5ldyBpbnN0YW5jZSBvZiBNb2RlbFxuICAgKi9cbiAgY3JlYXRlTmV3KGRhdGEgPSB7fSkge1xuICAgIGxldCByb290ID0gbmV3IFVSTEJ1aWxkZXIoW1xuICAgICAgdGhpcy5lbmRwb2ludENvbmZpZy5iYXNlVXJsKCksXG4gICAgICB0aGlzLmVuZHBvaW50Q29uZmlnLnVybCgpXG4gICAgXSk7XG4gICAgZGF0YVsnQHJvb3QnXSA9IHJvb3Q7XG4gICAgbGV0IGluc3RhbnRpYXRvciA9IHRoaXMuZW5kcG9pbnRDb25maWcubW9kZWwoKTtcbiAgICBsZXQgaW5zdGFuY2UgPSBuZXcgaW5zdGFudGlhdG9yKGRhdGEpO1xuICAgIGluc3RhbmNlLmNvbmZpZyh0aGlzLmVuZHBvaW50Q29uZmlnKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgLyBzZXRzIGluc3RhbnRpYXRvciB0byB1c2Ugd2hlbiBjcmVhdGluZyBhIG5ldyBtb2RlbCBpbnN0YW5jZS4gSW5zdGFudGlhdG9yICpzaG91bGQqIGluaGVyaXRcbiAgICogZnJvbSB7QGxpbmsgTW9kZWx9XG4gICAqIEBwYXJhbSB7KGZ1bmN0aW9ufGNsYXNzKT19IGluc3RhbnRpYXRvciAtIEZ1bmN0aW9uIG9yIGNsYXNzIHRvIHVzZSB3aGVuIGluc3RhbnRpYXRpbmcgbW9kZWxcbiAgICogQHJldHVybnMgeyh0aGlzfGZ1bmN0aW9uKX0gQ3VycmVudCBpbnN0YW50aWF0b3IgZnVuY3Rpb24gb3IgdGhpcyBpbnN0YW5jZVxuICAgKi9cbiAgbW9kZWwoaW5zdGFudGlhdG9yKSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgaW5zdGFudGlhdG9yKSB7XG4gICAgICB0aGlzLmVuZHBvaW50Q29uZmlnLm1vZGVsKGluc3RhbnRpYXRvcik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZW5kcG9pbnRDb25maWcubW9kZWwoKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyAvIHNldHMgdGhlIGVuZHBvaW50J3MgcmVsYXRpdmUgdXJsXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gdXJsIC0gVGhlIG5ldyB1cmwgdmFsdWVcbiAgICogQHJldHVybnMgeyh0aGlzfHN0cmluZyl9IFRoaXMgaW5zdGFuY2Ugb3IgdGhlIGN1cnJlbnQgdXJsXG4gICAqL1xuICB1cmwobmV3VXJsKSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbmV3VXJsKSB7XG4gICAgICB0aGlzLmVuZHBvaW50Q29uZmlnLnVybChuZXdVcmwpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVuZHBvaW50Q29uZmlnLnVybCgpO1xuICB9XG4gIC8qKlxuICAgKiBCdWlsZHMgYSBxdWVyeSB0byBmaW5kIGFuIG9iamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQgaWRlbnRpZmllclxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSB0aGUgdW5pcXVlIG1vZGVsIGlkZW50aWZpZXJcbiAgICogQHJldHVybnMge3RoaXN9XG4gICAqL1xuICBmaW5kQnlJZChpZCkge1xuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbW9kZWwgaWRlbnRpZmllcicpO1xuICAgIH1cbiAgICB0aGlzLmNvbmZpZy50YXJnZXQgPSBuZXcgVVJMQnVpbGRlcihbXG4gICAgICB0aGlzLmVuZHBvaW50Q29uZmlnLmJhc2VVcmwoKSxcbiAgICAgIHRoaXMuZW5kcG9pbnRDb25maWcudXJsKCksXG4gICAgICBpZFxuICAgIF0pO1xuICAgIHRoaXMuY29uZmlnLm1ldGhvZCA9ICdnZXQnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcXVlcnkgdG8gZmluZCBvYmplY3RzIHRoYXQgbWF0Y2ggdGhlIG9wdGlvbmFsIHF1ZXJ5XG4gICAqIEBwYXJhbSB7b2JqZWN0PX0gcXVlcnlcbiAgICogQHJldHVybnMge3RoaXN9XG4gICAqL1xuICBmaW5kKHF1ZXJ5KSB7XG4gICAgdGhpcy5jb25maWcudGFyZ2V0ID0gbmV3IFVSTEJ1aWxkZXIoW1xuICAgICAgdGhpcy5lbmRwb2ludENvbmZpZy5iYXNlVXJsKCksXG4gICAgICB0aGlzLmVuZHBvaW50Q29uZmlnLnVybCgpXG4gICAgXSk7XG4gICAgdGhpcy5jb25maWcubWV0aG9kID0gJ2dldCc7XG4gICAgdGhpcy5jb25maWcucXVlcnkuc2VhcmNoID0gSlNPTi5zdHJpbmdpZnkocXVlcnkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAgKiBBdCB0aGUgbW9tZW50LCB0aGlzIGJlaGF2ZXMgZXhhY3RseSB0aGUgc2FtZSBhcyAuZmluZCwgYnV0IHVzZXMgdGhlXG4gICAgKiBTRUFSQ0ggdmVyYiBpbnN0ZWFkXG4gICAgKiBAcGFyYW0ge29iamVjdH0gcXVlcnlcbiAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICovXG4gIHNlYXJjaChxdWVyeSkge1xuICAgIHRoaXMuY29uZmlnLnRhcmdldCA9IG5ldyBVUkxCdWlsZGVyKFtcbiAgICAgIHRoaXMuZW5kcG9pbnRDb25maWcuYmFzZVVybCgpLFxuICAgICAgdGhpcy5lbmRwb2ludENvbmZpZy51cmwoKVxuICAgIF0pO1xuICAgIHRoaXMuY29uZmlnLm1ldGhvZCA9ICdzZWFyY2gnO1xuICAgIHRoaXMuY29uZmlnLnF1ZXJ5LnNlYXJjaCA9IEpTT04uc3RyaW5naWZ5KHF1ZXJ5KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcXVlcnkgdG8gZmluZCBhIHVuaXF1ZSBtb2RlbCB3aXRoIHRoZSBzcGVjaWZpZWQgaWRcbiAgICogYW5kIHJlcGxhY2VzIGl0J3MgZGF0YSB3aXRoIHRoZSBzcGVjaWZpZWQgYm9keSBvYmplY3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gdGhlIHVuaXF1ZSBtb2RlbCBpZGVudGlmaWVyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEByZXR1cm5zIHt0aGlzfVxuICAgKi9cbiAgZmluZEJ5SWRBbmRVcGRhdGUoaWQsIGJvZHkpIHtcbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBpZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1vZGVsIGlkZW50aWZpZXInKTtcbiAgICB9XG4gICAgaWYgKCdvYmplY3QnICE9PSB0eXBlb2YgYm9keSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJvZHkgb2JqZWN0Jyk7XG4gICAgfVxuICAgIHRoaXMuY29uZmlnLnRhcmdldCA9IG5ldyBVUkxCdWlsZGVyKFtcbiAgICAgIHRoaXMuZW5kcG9pbnRDb25maWcuYmFzZVVybCgpLFxuICAgICAgdGhpcy5lbmRwb2ludENvbmZpZy51cmwoKSxcbiAgICAgIGlkXG4gICAgXSk7XG4gICAgdGhpcy5jb25maWcuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5jb25maWcubWV0aG9kID0gJ3B1dCc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHF1ZXJ5IHRoYXQgZmluZHMgYSBtb2RlbCB3aXRoIHRoZSBzcGVjaWZpZWQgaWQgYW5kXG4gICAqIHJlbW92ZXMgaXQgZnJvbSB0aGUgZGF0YWJhc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gdGhlIHVuaXF1ZSBtb2RlbCBpZGVudGlmaWVyXG4gICAqIEByZXR1cm5zIHt0aGlzfVxuICAgKi9cbiAgZmluZEJ5SWRBbmRSZW1vdmUoaWQpIHtcbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBpZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1vZGVsIGlkZW50aWZpZXInKTtcbiAgICB9XG4gICAgdGhpcy5jb25maWcudGFyZ2V0ID0gbmV3IFVSTEJ1aWxkZXIoW1xuICAgICAgdGhpcy5lbmRwb2ludENvbmZpZy5iYXNlVXJsKCksXG4gICAgICB0aGlzLmVuZHBvaW50Q29uZmlnLnVybCgpLFxuICAgICAgaWRcbiAgICBdKTtcbiAgICB0aGlzLmNvbmZpZy5tZXRob2QgPSAnZGVsZXRlJztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBxdWVyeSByZXF1ZXN0IHNob3VsZCBhbGxvdyBvYmplY3RzIGZyb20gdGhlIGNhY2hlXG4gICAqIG9yIHJlcXVpcmUgb2JqZWN0cyBiZSBmcmVzaCBmcm9tIHRoZSBhcGlcbiAgICogQHBhcmFtIHtib29sZWFuPX0gYWxsb3cgLSBTcGVjaWZ5IGlmIHVzaW5nIHRoZSBjYWNoZSBpcyBhbGxvd2VkXG4gICAqIEByZXR1cm5zIHsodGhpcyB8IGJvb2xlYW4pfSBUaGlzIGluc3RhbmNlIG9yIHRoZSBjdXJyZW50IGFsbG93IHZhbHVlXG4gICAqL1xuICBhbGxvd0Zyb21DYWNoZShhbGxvdykge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGFsbG93KSB7XG4gICAgICBpZiAoJ2Jvb2xlYW4nID09PSB0eXBlb2YgYWxsb3cpIHtcbiAgICAgICAgdGhpcy5jb25maWcuYWxsb3dGcm9tQ2FjaGUgPSBhbGxvdztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb25maWcuYWxsb3dGcm9tQ2FjaGU7XG4gIH1cblxuICAvKipcbiAgICogUnVucyB0aGUgcXVlcnkgdGhhdCBoYXMgYmVlbiBjcmVhdGVkIHVzaW5nIHRoZSBmaW5kL2ZpbmRCeS4uIGNhbGxzXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb249fSBjYiAtIEZ1bmN0aW9uIHRvIGNhbGwgb24gY29tcGxldGlvbiAoc3VjY2VzcyBvciBmYWlsdXJlKVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGV4ZWMoY2IgPSBub29wKSB7XG4gICAgbGV0IGFsbG93RnJvbUNhY2hlID0gdGhpcy5hbGxvd0Zyb21DYWNoZSgpO1xuICAgIGxldCBtb2RlbENvbnN0cnVjdG9yID0gdGhpcy5lbmRwb2ludENvbmZpZy5tb2RlbCgpO1xuICAgIGxldCBlbmRwb2ludENvbmZpZyA9IHRoaXMuZW5kcG9pbnRDb25maWc7XG5cbiAgICBsZXQgaGVhZGVycyA9IHt9O1xuICAgIHRyeSB7XG4gICAgICBoZWFkZXJzID0gdGhpcy5lbmRwb2ludENvbmZpZy5hcGkoKS5jb21tb25IZWFkZXJzKCk7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICAvLyBjb25zb2xlLmVycm9yKCdVbmFibGUgdG8gZ2V0IGNvbW1vbiBoZWFkZXJzLiBTb21ldGhpbmcgd2VudFxcJ3Qgd3JvbmcgKHVubGVzcyB5b3UgYXJlIHVuaXQgdGVzdGluZykuICcpO1xuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKGhlYWRlcnMsIHRoaXMuY29uZmlnLmhlYWRlcnMpO1xuXG4gICAgbGV0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgpXG4gICAgICAubWV0aG9kKHRoaXMuY29uZmlnLm1ldGhvZClcbiAgICAgIC5ib2R5KHRoaXMuY29uZmlnLmJvZHkgfHwge30pXG4gICAgICAucXVlcnkodGhpcy5jb25maWcucXVlcnkgfHwge30pXG4gICAgICAuaGVhZGVycyhoZWFkZXJzIHx8IHt9KVxuICAgICAgLnVybCh0aGlzLmNvbmZpZy50YXJnZXQudG9TdHJpbmcoKSk7XG5cbiAgICBsZXQgUHJvbWlzZSA9IHJlcXVpcmUoJy4vc2V0dGluZ3MnKS5nZXRQcm9taXNlKCk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaGFzQ2FjaGUoKSkge1xuICAgICAgICBsZXQgY2FjaGVkT2JqZWN0ID0gY2FjaGUuZ2V0KHJlcXVlc3QudXJsKCkpO1xuICAgICAgICBpZiAoY2FjaGVkT2JqZWN0ICYmIGFsbG93RnJvbUNhY2hlKSB7XG4gICAgICAgICAgY2IobnVsbCwgY2FjaGVkT2JqZWN0KTtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShjYWNoZWRPYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL2RvIGFjdHVhbCAnZ2V0J1xuICAgICAgcmVxdWVzdC5leGVjKCkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgIGxldCBkYXRhID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgbGV0IG1vZGVsO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgbW9kZWwgPSBkYXRhLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgbGV0IGVudHJ5ID0gbmV3IG1vZGVsQ29uc3RydWN0b3IoaXRlbSk7XG4gICAgICAgICAgICBlbnRyeS5jb25maWcoZW5kcG9pbnRDb25maWcpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVudHJ5LCAnX19yZXF1ZXN0JywgeyB2YWx1ZSA6IGNsb25lKHJlcXVlc3QpLCBlbnVtZXJhYmxlIDogZmFsc2UgfSk7XG4gICAgICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW9kZWwgPSBuZXcgbW9kZWxDb25zdHJ1Y3RvcihkYXRhKTtcbiAgICAgICAgICBtb2RlbC5jb25maWcoZW5kcG9pbnRDb25maWcpO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2RlbCwgJ19fcmVxdWVzdCcsIHsgdmFsdWUgOiBjbG9uZShyZXF1ZXN0KSwgZW51bWVyYWJsZSA6IGZhbHNlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzQ2FjaGUoKSkge1xuICAgICAgICAgIGNhY2hlLnB1dChyZXF1ZXN0LnVybCgpLCBtb2RlbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2IobnVsbCwgbW9kZWwpO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShtb2RlbCk7XG4gICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICBpZiAodGhpcy5oYXNDYWNoZSgpKSB7XG4gICAgICAgICAgY2FjaGUuaW52YWxpZGF0ZShyZXF1ZXN0LnVybCgpKTtcbiAgICAgICAgfVxuICAgICAgICBjYihlcnIpO1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUXVlcnkgaGVscGVyIHRvIHNraXAgcmVjb3JkcyByZXR1cm5lZCBmcm9tIHRoZSBhcGkgKGlmIHN1cHBvcnRlZCkuIENvbWJpbmVkXG4gICAqIHdpdGggdGhlIC5saW1pdCBtZXRob2QsIHRoaXMgZnVuY3Rpb24gaXMgZ3JlYXQgZm9yIHBhZ2luYXRpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNraXBBbW91bnRcbiAgICogQHJldHVybnMgdGhpc1xuICAgKi9cbiAgc2tpcChza2lwQW1vdW50ID0gMCkge1xuICAgIGlmICgnbnVtYmVyJyA9PT0gdHlwZW9mIHNraXBBbW91bnQpIHtcbiAgICAgIHRoaXMuY29uZmlnLnF1ZXJ5LnNraXAgPSBza2lwQW1vdW50O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuIC8qKlxuICAqIFF1ZXJ5IGhlbHBlciB0byBsaW1pdCB0aGUgbnVtYmVyIG9mIHJlc3VsdHMgcmV0dXJuZWQgKHByb3ZpZGVkIHRoZSBhcGlcbiAgKiBzdXBwb3J0cyBpdClcbiAgKiBAcGFyYW0ge251bWJlcn0gbGltaXRBbW91bnRcbiAgKiBAcmV0dXJucyB0aGlzXG4gICovXG4gIGxpbWl0KGxpbWl0QW1vdW50ID0gMCkge1xuICAgIGlmICgnbnVtYmVyJyA9PT0gdHlwZW9mIGxpbWl0QW1vdW50KSB7XG4gICAgICB0aGlzLmNvbmZpZy5xdWVyeS5saW1pdCA9IGxpbWl0QW1vdW50O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogU2V0cyBhIGxpc3Qgb2YgZmllbGRzIHRvIHJldHVybiBmcm9tIHRoZSBhcGkgKGlmIHN1cHBvcnRlZCkuXG4gICAqIEBwYXJhbSB7KHN0cmluZ3xzdHJpbmdbXSl9IGZpZWxkcyAtIGEgbGlzdCBvZiBmaWVsZHMgdG8gcmV0dXJuIGZyb20gdGhlIGFwaVxuICAgKiBAcmV0dXJucyB0aGlzXG4gICAqL1xuICBzZWxlY3QoZmllbGRzID0gJycpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmaWVsZHMpKSB7XG4gICAgICBmaWVsZHMgPSBmaWVsZHMuam9pbignICcpO1xuICAgIH1cbiAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBmaWVsZHMpIHtcbiAgICAgIHRoaXMuY29uZmlnLnF1ZXJ5LmZpZWxkcyA9IGZpZWxkcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgY2FjaGUgb2JqZWN0IGhhcyBiZWVuIHNldCBhbmQgaXMgdmFsaWRcbiAgICogQGFjY2VzcyBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaGFzQ2FjaGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGUgJiYgJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHRoaXMuY2FjaGU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFbmRwb2ludDtcbiIsIi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIEhUVFBNb2NrIHtcblx0Y29uc3RydWN0b3IodmVyYm9zZSA9IGZhbHNlKSB7XG5cdFx0dGhpcy5saXN0ZW5lcnMgPSB7fTtcblx0XHR0aGlzLnZlcmJvc2UgPSB2ZXJib3NlO1xuXHR9XG5cdC8qKlxuXHQgKiBNb2NrIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBYTUxIdHRwUmVxdWVzdCBvcGVuIG1ldGhvZFxuXHQgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvWE1MSHR0cFJlcXVlc3Qvb3Blbn1cblx0ICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZCBcblx0ICogQHBhcmFtIHtzdHJpbmd9IHVybCBcblx0ICogQHJldHVybnMge3VuZGVmaW5lZH1cblx0ICovXG5cdG9wZW4obWV0aG9kLCB1cmwpIHtcblx0XHR0aGlzLmxvZyhgT3BlbmluZyAke3VybH0gdXNpbmcgJHttZXRob2R9YCk7XG5cdH1cblx0LyoqXG5cdCAqIE1vY2sgcmVwcmVzZW50YXRpb24gb2YgdGhlIFhNTEh0dHBSZXF1ZXN0IHNlbmQgbWV0aG9kXG5cdCAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9YTUxIdHRwUmVxdWVzdC9zZW5kfVxuXHQgKiBAcGFyYW0ge29iamVjdH0gYm9keSBcblx0ICogQHJldHVybnMge3VuZGVmaW5lZH1cblx0ICovXG5cdHNlbmQoYm9keSkge1xuXHRcdHRoaXMubG9nKGBTZW5kaW5nIHdpdGggJHtib2R5fWApO1xuXHRcdGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgdGhpcy5saXN0ZW5lcnMubG9hZCkge1xuXHRcdFx0bGV0IG1vY2tSZXNwb25zZSA9IHtcblx0XHRcdFx0cmVzcG9uc2UgOiB7J21vY2tfcmVzcG9uc2UnIDogdHJ1ZSwgJ2RhdGEnIDogWydvYmoxJ119LFxuXHRcdFx0XHRyZXNwb25zZVRleHQgOiBcInsnbW9ja19yZXNwb25zZScgOiB0cnVlfVwiLFxuXHRcdFx0XHRzdGF0dXMgOiAyMDAsXG5cdFx0XHRcdHN0YXR1c1RleHQgOiAnMjAwJyxcblx0XHRcdFx0cmVzcG9uc2VVUkwgOiAnL21vY2stY2FsbCdcblx0XHRcdH07XG5cdFx0XHRPYmplY3QuYXNzaWduKHRoaXMsIG1vY2tSZXNwb25zZSk7XG5cdFx0XHR0aGlzLmxpc3RlbmVycy5sb2FkKCk7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQgKiBNb2NrIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBYTUxIdHRwUmVxdWVzdCBnZXRBbGxSZXNwb25zZUhlYWRlcnMgbWV0aG9kXG5cdCAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9YTUxIdHRwUmVxdWVzdC9nZXRBbGxSZXNwb25zZUhlYWRlcnN9XG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBtb2NrIGhlYWRlcnNcblx0ICovXG5cdGdldEFsbFJlc3BvbnNlSGVhZGVycygpIHtcblx0XHRyZXR1cm4gXCJNb2NrLUhlYWRlcnM6IHRydWVcIjtcblx0fVxuXHQvKipcblx0ICogUmVwcmVzZW50YXRpb24gb2YgSmF2YXNjcmlwdCdzIGFkZEV2ZW50TGlzdGVuZXIgZGVzaWduZWQgdG8gaG9vayBpbnRvIHRoaXNcblx0ICogbW9jayBYTUxIdHRwUmVxdWVzdCBvYmplY3Rcblx0ICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2FkZEV2ZW50TGlzdGVuZXJ9XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiBmb3Jcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBjYWxsIHdoZW4gZXZlbnQgaXMgdHJpZ2dlcmVkXG5cdCAqL1xuXHRhZGRFdmVudExpc3RlbmVyKG5hbWUsIGNhbGxiYWNrKSB7XG5cdFx0dGhpcy5sb2coYCR7bmFtZX0gbGlzdGVuZXIgcmVnaXN0ZXJlZGApO1xuXHRcdHRoaXMubGlzdGVuZXJzW25hbWVdID0gY2FsbGJhY2s7XG5cdH1cblx0LyoqXG5cdCAqIEp1c3QgYSBzdHViIHNvIHdlIGhhdmUgYSB1bmlmb3JtIGludGVyZmFjZSBiZXR3ZWVuIHRoaXMgYW5kIHRoZSByZWFsIHRoaW5nXG5cdCAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9zZXRSZXF1ZXN0SGVhZGVyfVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaGVhZGVyIFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgXG5cdCAqL1xuXHRzZXRSZXF1ZXN0SGVhZGVyKGhlYWRlciwgdmFsdWUpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHQvKipcblx0ICogSGVscGVyIGZ1bmN0aW9uIGZvciBsb2dnaW5nIHN0YXR1cyBvdXRwdXQgYmFzZWQgb24gdGhpcyBvYmplY3QncyBcblx0ICogdmVyYm9zaXR5IHNldHRpbmdzICh0cnVlL2ZhbHNlKVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBcblx0ICovXG5cdGxvZyhtZXNzYWdlKSB7XG5cdFx0aWYgKHRoaXMudmVyYm9zZSA9PT0gdHJ1ZSkge1xuXHRcdFx0Y29uc29sZS5sb2cobWVzc2FnZSk7XG5cdFx0fVxuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSFRUUE1vY2s7XG4iLCJjb25zdCBqc29ucGF0Y2ggPSByZXF1aXJlKCdmYXN0LWpzb24tcGF0Y2gnKTtcbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi91dGlscy5jbGFzcycpLmNsb25lO1xuY29uc3Qgbm9vcCA9IHJlcXVpcmUoJy4vdXRpbHMuY2xhc3MnKS5ub29wO1xuY29uc3QgUmVxdWVzdCA9IHJlcXVpcmUoJy4vcmVxdWVzdC5jbGFzcycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBNb2RlbCB7XG4gIGNvbnN0cnVjdG9yKGRhdGEgPSB7fSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX19jb25maWcnLCB7ZW51bWVyYWJsZSA6IGZhbHNlLCB3cml0YWJsZSA6IHRydWV9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ19fcmVzcG9uc2UnLCB7ZW51bWVyYWJsZSA6IGZhbHNlLCB3cml0YWJsZSA6IHRydWV9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ19fb3JpZ2luYWwnLCB7dmFsdWUgOiBkYXRhLCB3cml0YWJsZSA6IHRydWV9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ19fcmV2aXNpb24nLCB7dmFsdWUgOiBEYXRlLm5vdygpLCB3cml0YWJsZSA6IHRydWV9KTtcblxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2xvbmUoZGF0YSkpO1xuICB9XG4gIC8qKlxuICAgKiBQZXJzaXN0cyB0aGlzIG1vZGVsIGJhY2sgdG8gdGhlIGFwaVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uPX0gY2IgLSBDYWxsYmFjayB0byBpbnZva2Ugb24gY29tcGxldGlvbiAoZmFpbHVyZSBvciBzdWNjZXNzKVxuICAgKiBAcmV0dXJucyB7UmVxdWVzdH1cbiAgICovXG4gIHNhdmUoY2IgPSBub29wKSB7XG4gICAgbGV0IGhlYWRlcnMgPSB7fTtcbiAgICB0cnkge1xuICAgICAgaGVhZGVycyA9IHRoaXMuX19jb25maWcuYXBpKCkuY29tbW9uSGVhZGVycygpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgLy9pZ25vcmVcbiAgICB9XG5cbiAgICBsZXQgbWV0aG9kID0gdGhpcy5pZCA/ICdwdXQnIDogJ3Bvc3QnO1xuICAgIGxldCBpbnN0YW5jZSA9IHRoaXM7XG5cbiAgICBsZXQgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KClcbiAgICAgIC51cmwodGhpcy5tYWtlSHJlZigpKVxuICAgICAgLm1ldGhvZChtZXRob2QpXG4gICAgICAuaGVhZGVycyhoZWFkZXJzKVxuICAgICAgLmJvZHkodGhpcylcbiAgICAgIC5leGVjKClcbiAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICBPYmplY3QuYXNzaWduKGluc3RhbmNlLCBjbG9uZShyZXNwb25zZS5kYXRhKSk7XG4gICAgICAgIGluc3RhbmNlLl9fcmV2aXNpb24gPSBEYXRlLm5vdygpO1xuICAgICAgICBpbnN0YW5jZS5fX3Jlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIGluc3RhbmNlLm1ha2VDbGVhbigpO1xuICAgICAgICBjYigpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICBjYihlcnIpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9KTtcblxuICAgIHJldHVybiByZXF1ZXN0O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYSBsaXN0IG9mIGNoYW5nZXMgdGhhdCBoYXZlIG9jY3VyZWQgc2luY2UgdGhlIGxhc3QgZ2V0L3NhdmVcbiAgICogQHJldHVybnMge1JlcXVlc3R9XG4gICAqL1xuICBjaGFuZ2VzKCkge1xuICAgIGxldCBoZWFkZXJzID0gdGhpcy5fX2NvbmZpZy5hcGkoKS5jb21tb25IZWFkZXJzKCk7XG4gICAgbGV0IHRhcmdldFVybCA9IHRoaXNbJ0BjaGFuZ2VzJ107XG4gICAgbGV0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgpXG4gICAgICAudXJsKHRhcmdldFVybClcbiAgICAgIC5xdWVyeSh7c2VhcmNoIDoge3NpbmNlIDogdGhpcy5fX3JldmlzaW9ufX0pXG4gICAgICAubWV0aG9kKCdnZXQnKVxuICAgICAgLmhlYWRlcnMoaGVhZGVycylcbiAgICAgIC5leGVjKCk7XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnRzIGxpc3RlbmluZyBmb3IgY2hhbmdlcyBhbmQgY2FsbHMgb25DaGFuZ2Ugd2hlbmV2ZXIgdGhleSBhcmUgZGV0ZWN0ZWRcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gb25DaGFuZ2UgLSBGdW5jdGlvbiB0byBjYWxsIHdoZW4gY2hhbmdlcyBkZXRlY3RlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVmcmVzaFJhdGUgLSB0aGUgZHVyYXRpb24gKGluIG1pbGxpc2Vjb25kcykgYmV0d2VlbiBjaGVja3NcbiAgICogQHJldHVybnMge3RoaXN9XG4gICAqL1xuICBzdWJzY3JpYmUob25DaGFuZ2UsIHR0bCA9IDMwMDApIHtcbiAgICBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB0aGlzLmNoYW5nZXMoKS50aGVuKGNoYW5nZUxpc3QgPT4ge1xuICAgICAgICBpZiAoY2hhbmdlTGlzdCAmJiBjaGFuZ2VMaXN0Lmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuX19yZXZpc2lvbiA9IERhdGUubm93KCk7XG4gICAgICAgICAgb25DaGFuZ2UoY2hhbmdlTGlzdCwgRGF0ZS5ub3coKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sdHRsKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1dHMgb25seSB0aGUgY2hhbmdlcyAoaW4gcGF0Y2ggbm90YXRpb24pIGJhY2sgdG8gdGhlIGFwaS4gVGhlXG4gICAqIHNlcnZlci1zaWRlIGVuZHBvaW50IG11c3Qgc3VwcG9ydCBQQVRDSFxuICAgKiBAcmV0dXJucyB7UmVxdWVzdH1cbiAgICovXG4gIHVwZGF0ZSgpIHtcbiAgICAvL3VzZSBwYXRjaFxuICAgIGxldCBoZWFkZXJzID0gdGhpcy5fX2NvbmZpZy5hcGkoKS5jb21tb25IZWFkZXJzKCk7XG5cbiAgICBsZXQgcGF0Y2hlcyA9IHRoaXMuZ2V0RGlmZnMoKTtcbiAgICBsZXQgdGFyZ2V0VXJsID0gdGhpcy5tYWtlSHJlZigpO1xuICAgIGxldCBpbnN0YW5jZSA9IHRoaXM7XG4gICAgbGV0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgpXG4gICAgICAudXJsKHRhcmdldFVybClcbiAgICAgIC5tZXRob2QoJ3BhdGNoJylcbiAgICAgIC5oZWFkZXJzKGhlYWRlcnMpXG4gICAgICAuYm9keShwYXRjaGVzKVxuICAgICAgLmV4ZWMoKVxuICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oaW5zdGFuY2UsIGNsb25lKHJlc3BvbnNlLmRhdGEpKTtcbiAgICAgICAgaW5zdGFuY2UuX19yZXZpc2lvbiA9IERhdGUubm93KCk7XG4gICAgICAgIGluc3RhbmNlLl9fcmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgaW5zdGFuY2UubWFrZUNsZWFuKCk7XG4gICAgICB9KTtcbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB1bmRlcmx5aW5nIEFQSSBjb25maWdcbiAgICogQHBhcmFtIHtFbmRwb2ludENvbmZpZ30gZW5kcG9pbnRDb25maWdcbiAgICovXG4gIGNvbmZpZyhlbmRwb2ludENvbmZpZyA9IHt9KSB7XG4gICAgdGhpcy5fX2NvbmZpZyA9IGVuZHBvaW50Q29uZmlnO1xuICB9XG5cbiAgbWFrZUhyZWYoKSB7XG4gICAgbGV0IGNvcnJlY3RIcmVmO1xuICAgIGlmICgnb2JqZWN0JyA9PT0gdHlwZW9mIHRoaXMuX19jb25maWcpIHtcbiAgICAgIGNvcnJlY3RIcmVmID0gdGhpcy5fX2NvbmZpZy5iYXNlVXJsKCkgKyAnLycgKyB0aGlzLl9fY29uZmlnLnVybCgpICsgJy8nO1xuICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdGhpcy5pZCApIHtcbiAgICAgICAgY29ycmVjdEhyZWYgKz0gdGhpcy5pZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29ycmVjdEhyZWYgPSAnL19fdW5pdF90ZXN0X18nO1xuICAgIH1cbiAgICByZXR1cm4gY29ycmVjdEhyZWY7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgZGlmZnMgY29tcGFyaW5nIHRoaXMgdmVyc2lvbiB0byB0aGUgbGFzdFxuICAgKiBzeW5jZWQgdmVyc2lvbiBmcm9tIHRoZSBzZXJ2ZXJcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge29iamVjdFtdfSBBcnJheSBvZiBjaGFuZ2VzXG4gICAqL1xuICBnZXREaWZmcygpIHtcbiAgICByZXR1cm4ganNvbnBhdGNoLmNvbXBhcmUodGhpcy5fX29yaWdpbmFsLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBzdGF0dXMgb2YgdGhpcyBtb2RlbFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGlzRGlydHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGlmZnMoKS5sZW5ndGggPiAwO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgb3V0IHRoZSBjaGFuZ2UgaGlzdG9yeSBhbmQgc3luY3MgdGhlIHVuZGVybHlpbmcgb3JpZ2luYWwgdmVyc2lvblxuICAgKiB0byB0aGUgY3VycmVudCB2ZXJzaW9uXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICBtYWtlQ2xlYW4oKSB7XG4gICAgdGhpcy5fX29yaWdpbmFsID0gY2xvbmUodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGlzIG1vZGFsIGZyb20gdGhlIGFwaVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uPX0gY2IgLSBGdW5jdGlvbiB0byBjYWxsIG9uIGNvbXBsZXRldGlvbiAoc3VjY2VzcyBvciBmYWlsdXJlKVxuICAgKiBAcmV0dXJucyB7UmVxdWVzdH1cbiAgICovXG4gIHJlbW92ZShjYiA9IG5vb3ApIHtcbiAgICBsZXQgaGVhZGVycyA9IHt9O1xuICAgIHRyeSB7XG4gICAgICBoZWFkZXJzID0gdGhpcy5fX2NvbmZpZy5hcGkoKS5jb21tb25IZWFkZXJzKCk7XG4gICAgfSBjYXRjaChlKSB7fVxuXG4gICAgbGV0IHRhcmdldFVybCA9IHRoaXMubWFrZUhyZWYoKTtcbiAgICBsZXQgaW5zdGFuY2UgPSB0aGlzO1xuXG4gICAgbGV0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgpXG4gICAgICAudXJsKHRhcmdldFVybClcbiAgICAgIC5tZXRob2QoJ2RlbGV0ZScpXG4gICAgICAuaGVhZGVycyhoZWFkZXJzKVxuICAgICAgLmV4ZWMoKVxuICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGluc3RhbmNlLl9fcmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgcmV0dXJuIGNiKCk7XG4gICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICBjYihlcnIpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9KTtcbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gTW9kZWw7XG4iLCJjb25zdCBUcmFuc3BvcnQgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC5jbGFzcy5qcycpO1xuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuL3V0aWxzLmNsYXNzJykuY2xvbmU7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdD19IGNvbmZpZ1xuICovXG5jbGFzcyBSZXF1ZXN0IHtcbiAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgdXJsOiAnLycsXG4gICAgICBoZWFkZXJzOiB7fSxcbiAgICAgIGRhdGE6IHVuZGVmaW5lZCxcbiAgICAgIHJlc3BvbnNlVHlwZSA6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIHBhcmFtcyA6IHt9XG4gICAgfTtcbiAgICB0aGlzLmNvbmZpZyA9IHt9O1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5jb25maWcsIGRlZmF1bHRzLCBjb25maWcpO1xuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlcyB0aGUgY3VycmVudCByZXF1ZXN0IHVzaW5nIHRoZSB1bmRlcmx5aW5nIHRyYW5zcG9ydCBtZWNoYW5pc20gKGllIGh0dHApXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgZXhlYygpIHtcbiAgICBsZXQgb3JpZ2luYWxSZXF1ZXN0ID0gdGhpcztcbiAgICBsZXQgUHJvbWlzZSA9IHJlcXVpcmUoJy4vc2V0dGluZ3MnKS5nZXRQcm9taXNlKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIG9yaWdpbmFsUmVxdWVzdC50cmFuc3BvcnQgPSBuZXcgVHJhbnNwb3J0KG9yaWdpbmFsUmVxdWVzdCk7XG5cbiAgICAgIG9yaWdpbmFsUmVxdWVzdC50cmFuc3BvcnRcbiAgICAgIC5leGVjKClcbiAgICAgIC50aGVuKGZ1bmN0aW9uIHN1Y2Nlc3NDYWxsYmFjayhyZXNwb25zZSkge1xuICAgICAgICByZXNwb25zZS5kYXRhID0gY2xvbmUocmVzcG9uc2UucmVzcG9uc2UpO1xuICAgICAgICAvLyBvcmlnaW5hbFJlcXVlc3QucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgcmVzcG9uc2UucmVxdWVzdCA9IG9yaWdpbmFsUmVxdWVzdDtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgfSwgZnVuY3Rpb24gZXJyb3JDYWxsYmFjayhyZXNwb25zZSkge1xuICAgICAgICAvLyBvcmlnaW5hbFJlcXVlc3QucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgcmVzcG9uc2UucmVxdWVzdCA9IG9yaWdpbmFsUmVxdWVzdDsgICAgICAgIFxuICAgICAgICByZXR1cm4gcmVqZWN0KHJlc3BvbnNlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIC8gc2V0cyB0aGUgcXVlcnkgb2JqZWN0IHRvIHVzZVxuICAgKiBAcGFyYW0ge29iamVjdD19IG5ld1F1ZXJ5IFxuICAgKiBAcmV0dXJucyB7KHRoaXMgfCBvYmplY3QpfVxuICAgKi9cbiAgcXVlcnkobmV3UXVlcnkpIHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBuZXdRdWVyeSkge1xuICAgICAgaWYgKCdvYmplY3QnID09PSB0eXBlb2YgbmV3UXVlcnkgJiYgbmV3UXVlcnkgIT09IG51bGwpIHtcbiAgICAgICAgbmV3UXVlcnkgPSBjbG9uZShuZXdRdWVyeSk7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbmZpZy5wYXJhbXMgPSBuZXdRdWVyeTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25maWcucGFyYW1zO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldHMgLyBzZXRzIHRoZSBodHRwIHZlcmIgKG1ldGhvZCkgdG8gdXNlIChpZSBnZXQscHV0LHBvc3QsIGV0YylcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBuZXdNZXRob2QgXG4gICAqIEByZXR1cm5zIHsodGhpcyB8IHN0cmluZyl9XG4gICAqL1xuICBtZXRob2QobmV3TWV0aG9kKSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbmV3TWV0aG9kKSB7XG4gICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBuZXdNZXRob2QpIHtcbiAgICAgICAgdGhpcy5jb25maWcubWV0aG9kID0gbmV3TWV0aG9kO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5tZXRob2Q7XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogR2V0cyAvIHNldHMgdGhlIHRhcmdldCB1cmwgdG8gbWFrZSB0aGUgcmVxdWVzdCB0b1xuICAgKiBAcGFyYW0ge3N0cmluZz19IG5ld1VybCBcbiAgICogQHJldHVybnMgeyh0aGlzIHwgc3RyaW5nKX1cbiAgICovXG4gIHVybChuZXdVcmwpIHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBuZXdVcmwpIHtcbiAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIG5ld1VybCkge1xuICAgICAgICB0aGlzLmNvbmZpZy51cmwgPSBuZXdVcmw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnVybDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyAvIHNldHMgaGVhZGVycyAoa2V5IC8gdmFsdWUgcGFpcnMgKSB0byB1c2UgZm9yIHRoZSByZXF1ZXN0XG4gICAqIEBwYXJhbSB7b2JqZWN0PX0gbmV3SGVhZGVyT2JqIFxuICAgKiBAcmV0dXJucyB7KHRoaXMgfCBvYmplY3QpfVxuICAgKi9cbiAgaGVhZGVycyhuZXdIZWFkZXJPYmopIHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBuZXdIZWFkZXJPYmopIHtcbiAgICAgIGlmICgnb2JqZWN0JyA9PT0gdHlwZW9mIG5ld0hlYWRlck9iaiAmJiBuZXdIZWFkZXJPYmogIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jb25maWcuaGVhZGVycyA9IGNsb25lKG5ld0hlYWRlck9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmhlYWRlcnM7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgLyBzZXRzIHRoZSByZXF1ZXN0IGJvZHlcbiAgICogQHBhcmFtIHtvYmplY3Q9fSBuZXdCb2R5IFxuICAgKiBAcmV0dXJucyB7KHRoaXMgfCBvYmplY3QgfCB1bmRlZmluZWQpfVxuICAgKi9cbiAgYm9keShuZXdCb2R5KSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbmV3Qm9keSkge1xuICAgICAgaWYgKCdvYmplY3QnID09PSB0eXBlb2YgbmV3Qm9keSAmJiBuZXdCb2R5ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmRhdGEgPSBjbG9uZShuZXdCb2R5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25maWcuZGF0YTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgcmVzcG9uc2UgdHlwZSBmb3IgdGhlIHJlcXVlc3RcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBuZXdUeXBlIFxuICAgKiBAcmV0dXJucyB7KHRoaXMgfCBzdHJpbmcpfVxuICAgKi9cbiAgbWVkaWFUeXBlKG5ld1R5cGUpIHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBuZXdUeXBlKSB7XG4gICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBuZXdUeXBlKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLnJlc3BvbnNlVHlwZSA9IG5ld1R5cGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGlzIHJlcXVlc3QncyBjb25maWd1cmF0aW9uc1xuICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKCBKU09OLnN0cmluZ2lmeSh0aGlzLmNvbmZpZykgKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlcXVlc3Q7XG4iLCIvKipcbiAqIFJlZmVyZW5jZSBwb2ludCBmb3IgYWxsIG9mIHRoZSBzZGsgbW9kdWxlcyB0byBmaW5kIGNvbW1vblxuICogc2V0dGluZ3MsIHN1Y2ggYXMgd2hhdCBwcm9taXNlIHRvIHVzZVxuICogQHNpbmdsZXRvblxuICogQG5hbWVzcGFjZSBPZmZpY2VCb3RTREsuU2V0dGluZ3NcbiAqL1xubGV0IHNldHRpbmdzID0ge1xuICBfcCA6IFByb21pc2UsXG4gIHNldFByb21pc2VMaWIgOiBmdW5jdGlvbihwKSB7XG4gICAgdGhpcy5fcCA9IHA7XG4gIH0sXG4gIGdldFByb21pc2UgOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzZXR0aW5nczsiLCJjb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4vdXRpbHMuY2xhc3MnKS5jbG9uZTtcbmNvbnN0IHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgVHJhbnNwb3J0IHtcblx0Y29uc3RydWN0b3IocmVxdWVzdCkge1xuXHRcdGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIHdpbmRvdyAmJiB3aW5kb3cuWE1MSHR0cFJlcXVlc3QpIHtcblx0XHRcdHRoaXMuSFRUUFJlcXVlc3QgPSB3aW5kb3cuWE1MSHR0cFJlcXVlc3Q7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuSFRUUFJlcXVlc3QgPSByZXF1aXJlKCcuL2h0dHAtbW9jay5jbGFzcy5qcycpOyAvL3VzZWQgZm9yIE5vZGUgYmFzZWQgdGVzdHNcblx0XHR9XG5cdFx0dGhpcy5zZXRSZXF1ZXN0KHJlcXVlc3QpO1xuXHR9XG5cdC8qKlxuXHQgKiBTdG9yZXMgdGhlIHJlcXVlc3Qgb2JqZWN0IGZvciB1c2UgbGF0ZXIgKGllIHdoZW4gLmV4ZWMoKSBnZXRzIGNhbGxlZCkuIEhlbHBmdWxsIFxuXHQgKiBpZiBidWlsZGluZyB0aGUgdHJhbnNwb3J0IHJlcXVlc3QgdXAgaW5zdGVhZCBvZiBwYXNzaW5nIGV2ZXJ5dGhpbmcgaW50byBjb25zdHJ1Y3Rvci5cblx0ICogQHBhcmFtIHtSZXF1ZXN0fSByZXF1ZXN0IFxuXHQgKiBAcmV0dXJucyB7dGhpc31cblx0ICovXG5cdHNldFJlcXVlc3QocmVxdWVzdCkge1xuXHRcdHRoaXMucmVxdWVzdCA9IGNsb25lKHJlcXVlc3QpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQgKiBNYWtlcyB0aGUgYWN0dWFsIGFwaSBjYWxsIHVzaW5nIHRoZSBSZXF1ZXN0IG9iamVjdCB0aGF0IHdhcyBwYXNzZWQgaW50byB0aGUgY29uc3RydWN0b3IgXG5cdCAqIG9yIGFkZGVkIHVzaW5nIHRoZSBzZXRSZXF1ZXN0IG1ldGhvZC5cblx0ICogQHJldHVybnMge1Byb21pc2V9XG5cdCAqL1xuXHRleGVjKCkge1xuXHRcdGxldCBQcm9taXNlID0gcmVxdWlyZSgnLi9zZXR0aW5ncycpLmdldFByb21pc2UoKTtcdFx0XG5cdFx0bGV0IGluc3RhbmNlID0gdGhpcztcblx0XHRcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdFx0XG5cdFx0XHRsZXQgaHR0cEluc3RhbmNlID0gbmV3IGluc3RhbmNlLkhUVFBSZXF1ZXN0KCk7XG5cdFx0XHRsZXQgdXJsID0gaW5zdGFuY2UucmVxdWVzdC51cmwoKSA7XG5cblx0XHRcdGxldCBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeShpbnN0YW5jZS5yZXF1ZXN0LnF1ZXJ5KCkpO1xuXHRcdFx0aWYgKHF1ZXJ5ICYmIHF1ZXJ5Lmxlbmd0aCkge1xuXHRcdFx0XHR1cmwgPSB1cmwgKyAnPycgKyBxdWVyeTtcblx0XHRcdH1cblx0XHRcdGxldCBib2R5ID0gaW5zdGFuY2UucmVxdWVzdC5ib2R5KCk7XG5cdFx0XHRpZiAoJ29iamVjdCcgPT09IHR5cGVvZiBib2R5KSB7XG5cdFx0XHRcdGJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aHR0cEluc3RhbmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHRyYW5zZmVyQ29tcGxldGUpO1xuXHRcdFx0aHR0cEluc3RhbmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCB0cmFuc2ZlckZhaWxlZCk7XG5cdFx0XHRodHRwSW5zdGFuY2UuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIHRyYW5zZmVyQWJvcnRlZCk7XG5cdFx0XHRodHRwSW5zdGFuY2Uub3BlbiggaW5zdGFuY2UucmVxdWVzdC5tZXRob2QoKS50b1VwcGVyQ2FzZSgpLCB1cmwgKTtcblx0XHRcdGh0dHBJbnN0YW5jZS5yZXNwb25zZVR5cGUgPSAnanNvbic7XG5cdFx0XHRcblx0XHRcdGxldCBoZWFkZXJzID0gaW5zdGFuY2UucmVxdWVzdC5oZWFkZXJzKCk7XG5cdFx0XHRodHRwSW5zdGFuY2Uuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBpbnN0YW5jZS5yZXF1ZXN0Lm1lZGlhVHlwZSgpKTtcdFxuXHRcdFx0XG5cdFx0XHRmb3IgKCBsZXQgaGVhZGVyTmFtZSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRodHRwSW5zdGFuY2Uuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXJOYW1lLCBoZWFkZXJzW2hlYWRlck5hbWVdKTtcblx0XHRcdH1cblx0XHRcdGh0dHBJbnN0YW5jZS5zZW5kKCBib2R5ICk7XG5cblx0XHRcdC8qKlxuXHRcdFx0XHQqIEhhbmRsZXI6QWJvcnRlZFxuXHRcdFx0XHQqL1xuXHRcdFx0ZnVuY3Rpb24gdHJhbnNmZXJBYm9ydGVkKCkge1xuXHRcdFx0XHRsZXQgZmFpbGVkID0gbmV3IEVycm9yKCdUcmFuc2ZlciBjYW5jZWxsZWQuJyk7XG5cdFx0XHRcdHJlamVjdChmYWlsZWQpO1xuXHRcdFx0fVxuXHRcdFx0LyoqXG5cdFx0XHRcdCogSGFuZGxlcjpGYWlsZWRcblx0XHRcdFx0Ki9cblx0XHRcdGZ1bmN0aW9uIHRyYW5zZmVyRmFpbGVkKGUpIHtcblx0XHRcdFx0cmVqZWN0KGh0dHBJbnN0YW5jZSk7XG5cdFx0XHR9XG5cdFx0XHQvKipcblx0XHRcdFx0KiBIYW5kbGVyOkZpbmlzaGVkXG5cdFx0XHRcdCovXG5cdFx0XHRmdW5jdGlvbiB0cmFuc2ZlckNvbXBsZXRlKCkge1x0XG5cdFx0XHRcdGlmIChodHRwSW5zdGFuY2Uuc3RhdHVzIDwgNDAwKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZShodHRwSW5zdGFuY2UpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlamVjdChodHRwSW5zdGFuY2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc3BvcnQ7XG4iLCIvKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmdbXX0gYXJncyBcbiAqL1xuY2xhc3MgVVJMQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKGFyZ3MgPSBbXSkge1xuICAgIGlmICghYXJncyB8fCAnZnVuY3Rpb24nICE9PSB0eXBlb2YgYXJncy5qb2luKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VSTCBCdWlsZGVyIHJlcXVpcmVzIHBhcmFtIDEgdG8gYmUgYW4gYXJyYXkuJyk7XG4gICAgfVxuICAgIHRoaXMudGFyZ2V0ID0gYXJncy5maWx0ZXIoaXRlbSA9PiB7XG4gICAgICByZXR1cm4gaXRlbSAhPT0gJy8nO1xuICAgIH0pLmpvaW4oJy8nKSB8fCBcIi9cIjtcbiAgfVxuICAvKipcbiAgICogQHJldHVybnMge3N0cmluZ30gdXJsXG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy50YXJnZXQgfHwgJyc7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBVUkxCdWlsZGVyOyIsInZhciBjbG9uZV9saWIgPSByZXF1aXJlKCdjbG9uZScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBVdGlscyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICB9XG4gICAgLyoqXG4gICAgICogRG9lcyBub3RoaW5nXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBzdGF0aWMgbm9vcCgpIHtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkZWVwIGNvcHkgb2YgdGhlIHBhc3NlZCBpbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqIC0gT2JqZWN0IHRvIGNvcHlcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDb3BpZWQgb2JqZWN0XG4gICAgICovXG4gICAgc3RhdGljIGNsb25lKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAvLyByZXR1cm4gY2xvbmVfbGliKG9iaik7XG4gICAgICAgIC8vIHJldHVybiBwcml2YXRlQ2xvbmUob2JqKTtcbiAgICB9XG59XG4vKipcbiAqIEFsbG93cyBvdXIgc3RhdGljIG1ldGhvZCB0byBjYWxsIHRoaXMgcmVjdXJzaXZlbHlcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBDb3BpZWQgb2JqZWN0IFxuICovXG5mdW5jdGlvbiBwcml2YXRlQ2xvbmUob2JqKSB7XG4gICBpZihvYmogPT09IG51bGwgfHwgdHlwZW9mKG9iaikgIT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICB9XG4gICB2YXIgdGVtcCA9IG5ldyBvYmouY29uc3RydWN0b3IoKTtcbiAgIGZvcih2YXIga2V5IGluIG9iaikge1xuICAgICAgdGVtcFtrZXldID0gcHJpdmF0ZUNsb25lKG9ialtrZXldKTtcbiAgIH1cbiAgIHJldHVybiB0ZW1wO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFV0aWxzOyJdfQ=="}